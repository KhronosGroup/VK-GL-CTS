
group varying "Varying linkage"
    group rules "Rules"

        case input_type_mismatch
            version 310 es
            desc "Tessellation control shader input type mismatch"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump vec2 tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID].x;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case output_type_mismatch
            version 310 es
            desc "Tessellation evaluation shader output type mismatch"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump vec2 te_out;
                void main()
                {
                    out0 = te_out.x + te_out.y;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case internal_type_mismatch
            version 310 es
            desc "Tessellation control and evaluation shader varying type mismatch"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump vec2 tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2].x + tc_out[0].y;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case input_different_precision
            version 310 es
            desc "Tessellation control shader input precisions different"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out highp float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in lowp float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case output_different_precision
            version 310 es
            desc "Tessellation evaluation shader output precisions different"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out highp float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in lowp float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case internal_different_precision
            version 310 es
            desc "Tessellation control and evaluation shader varying precisions different"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out highp float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in lowp float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case input_no_declaration
            version 310 es
            desc "Tessellation control shader input with no matching output"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case output_no_declaration
            version 310 es
            desc "Tessellation evaluation shader without output for an fragment shader input"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                void main()
                {
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                void main()
                {
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case internal_no_declaration
            version 310 es
            desc "Tessellation evaluation shader input without matching output"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                void main()
                {
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case input_superfluous_declaration
            version 310 es
            desc "Tessellation control has no input for an output"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                out mediump float tc_in_unused;
                void main()
                {
                    tc_in = in0;
                    tc_in_unused = in0 + 1.0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case output_superfluous_declaration
            version 310 es
            desc "Tessellation has an output without a matching input"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                out mediump float te_out_unused;
                void main()
                {
                    te_out = tc_out[2];
                    te_out_unused = tc_out[0];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case internal_superfluous_declaration
            version 310 es
            desc "Tessellation control has an output without a matching input"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                out mediump float tc_out_unused[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    tc_out_unused[gl_InvocationID] = tc_in[gl_InvocationID] + 1.0;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case vertex_fragment_same_varying_name_1
            version 310 es
            desc "Tessellation control has an output without a matching input"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 2.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float sharedVaringName;
                void main()
                {
                    sharedVaringName = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float sharedVaringName[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = sharedVaringName[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float sharedVaringName;
                void main()
                {
                    sharedVaringName = 2.0 * tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float sharedVaringName;
                void main()
                {
                    out0 = sharedVaringName;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case vertex_fragment_same_varying_name_2
            version 310 es
            desc "Tessellation control has an output without a matching input"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input vec2 in0 = vec2(1.0, 3.0);
                output float out0 = 4.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump vec2 sharedVaringName;
                void main()
                {
                    sharedVaringName = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump vec2 sharedVaringName[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = sharedVaringName[gl_InvocationID].x + sharedVaringName[gl_InvocationID].y;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float sharedVaringName;
                void main()
                {
                    sharedVaringName = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float sharedVaringName;
                void main()
                {
                    out0 = sharedVaringName;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case invalid_vertex_index
            version 310 es
            desc "Tessellation control output not indexed with gl_InvocationID"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                out mediump float tc_out[];
                void main()
                {
                    tc_out[2 - gl_InvocationID] = float(gl_InvocationID);
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    ${FRAG_COLOR} = vec4(te_out);
                }
            ""
        end

        case input_non_array
            version 310 es
            desc "Tessellation control input in not an array"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in;
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case output_non_array
            version 310 es
            desc "Tessellation control output out not an array"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out; // not an array
                void main()
                {
                    tc_out = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case input_array_size_mismatch
            version 310 es
            desc "Tessellation control input array size is not gl_MaxPatchVertices"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[2]; // not gl_MaxPatchVertices
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case internal_array_size_mismatch
            version 310 es
            desc "Tessellation control output array size is not consistent with layout qualifier"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[2]; // does not match output layout qualifier
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[2];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[1];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case invalid_patch_in_usage
            version 310 es
            desc "Invalid use of the patch_in qualifier in a non-tessellation shader"
            expect compile_or_link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float frag_in;
                out mediump float var;
                void main()
                {
                    frag_in = in0;
                    var = 2.0;
                    ${VERTEX_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                patch in mediump float var; // invalid use of patch_in
                in mediump float frag_in;
                void main()
                {
                    out0 = frag_in * var;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case invalid_patch_out_usage
            version 310 es
            desc "Invalid use of the patch_out qualifier in a non-tessellation shader"
            expect compile_or_link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float frag_in;
                patch out mediump float var;
                void main()
                {
                    frag_in = in0;
                    var = 2.0;
                    ${VERTEX_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float var; // invalid use of patch_out
                in mediump float frag_in;
                void main()
                {
                    out0 = frag_in * var;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case invalid_per_patch_qualifier_usage
            version 310 es
            desc "Invalid use of per-patch qualifier on input variable in tessellation control shader"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                patch in mediump float tc_in; // patch in not allowed in TCS
                patch out mediump float tc_out;
                void main()
                {
                    tc_out = tc_in;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                patch in mediump float tc_out;
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case per_patch_qualifier_mismatch_1
            version 310 es
            desc "Tessellation control output is per-patch qualified, evaluation input is not"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                patch out mediump float tc_out[gl_MaxPatchVertices];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[gl_MaxPatchVertices];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case per_patch_qualifier_mismatch_2
            version 310 es
            desc "Tessellation control output is not per-patch qualified, evaluation input is"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[gl_MaxPatchVertices];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                patch in mediump float tc_out[gl_MaxPatchVertices];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case input_block
            version 310 es
            desc "Tessellation control shader input block"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require extension { "GL_OES_shader_io_blocks" | "GL_EXT_shader_io_blocks" } in { vertex }
            values { output float out0 = 1.0; }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out IOBlockName
                {
                    mediump float var;
                } outputInstanceName;
                void main()
                {
                    outputInstanceName.var = 1.0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in IOBlockName
                {
                    mediump float var;
                } inputInstanceName[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = inputInstanceName[gl_InvocationID].var;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case input_block_non_array
            version 310 es
            desc "Tessellation control shader input block without explicit array"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require extension { "GL_OES_shader_io_blocks" | "GL_EXT_shader_io_blocks" } in { vertex }
            expect compile_or_link_fail
            values { output float out0 = 1.0; }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out IOBlockName
                {
                    mediump float var;
                } outputInstanceName;
                void main()
                {
                    outputInstanceName.var = 1.0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in IOBlockName
                {
                    mediump float var;
                } inputInstanceName;
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = inputInstanceName.var;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float geo_out;
                void main()
                {
                    out0 = geo_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case output_block_non_array
            version 310 es
            desc "Tessellation control shader output block without explicit array"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require extension { "GL_OES_shader_io_blocks" | "GL_EXT_shader_io_blocks" } in { vertex }
            expect compile_or_link_fail
            values { output float out0 = 1.0; }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = 1.0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out IOBlockName
                {
                    mediump float var;
                } outputInstanceName; // not an array
                void main()
                {
                    outputInstanceName.var = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in IOBlockName
                {
                    mediump float var;
                } outputInstanceName[];
                out mediump float te_out;
                void main()
                {
                    te_out = outputInstanceName[2].var;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case input_block_array_size_mismatch
            version 310 es
            desc "Tessellation control shader input block array, size not gl_MaxPatchVertices"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require extension { "GL_OES_shader_io_blocks" | "GL_EXT_shader_io_blocks" } in { vertex }
            expect compile_or_link_fail
            values { output float out0 = 1.0; }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out IOBlockName
                {
                    mediump float var;
                } outputInstanceName;
                void main()
                {
                    outputInstanceName.var = 1.0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in IOBlockName
                {
                    mediump float var;
                } inputInstanceName[4]; // not gl_MaxPatchVertices
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = inputInstanceName[gl_InvocationID + 1].var;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float geo_out;
                void main()
                {
                    out0 = geo_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case output_block
            version 310 es
            desc "Tessellation shader output block"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require extension { "GL_OES_shader_io_blocks" | "GL_EXT_shader_io_blocks" } in { fragment }
            values { output float out0 = 1.0; }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                void main()
                {
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                out IOBlockName
                {
                    mediump float var;
                } outputInstanceName;
                void main()
                {
                    outputInstanceName.var = 1.0;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in IOBlockName
                {
                    mediump float var;
                } inputInstanceName;
                void main()
                {
                    out0 = inputInstanceName.var;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case output_block_array
            version 310 es
            desc "Tessellation shader output block array"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require extension { "GL_OES_shader_io_blocks" | "GL_EXT_shader_io_blocks" } in { fragment }
            values { output float out0 = 1.0; }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                void main()
                {
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                out IOBlockName
                {
                    mediump float var;
                } outputInstanceName[2];
                void main()
                {
                    outputInstanceName[0].var = 2.0;
                    outputInstanceName[1].var = 1.0;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in IOBlockName
                {
                    mediump float var;
                } inputInstanceName[2];
                void main()
                {
                    out0 = inputInstanceName[0].var - inputInstanceName[1].var;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case unspecified_vertex_count
            version 310 es
            desc "Tessellation shader unspecified vertex count"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                void main()
                {
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                void main()
                {
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                void main()
                {
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case unspecified_primitive_mode
            version 310 es
            desc "Tessellation shader unspecified vertex count"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            expect compile_or_link_fail
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                void main()
                {
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                void main()
                {
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                void main()
                {
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end
    end

    group qualifiers "Varying qualifiers"
        case smooth
            version 310 es
            desc "Smooth varying"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                smooth out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                smooth in mediump float tc_in[];
                smooth out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                smooth in mediump float tc_out[];
                smooth out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                smooth in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case flat
            version 310 es
            desc "Flat varying"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                flat out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                flat in mediump float tc_in[];
                flat out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                flat in mediump float tc_out[];
                flat out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                flat in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case centroid
            version 310 es
            desc "Centroid varying"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                centroid out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                centroid in mediump float tc_in[];
                centroid out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                centroid in mediump float tc_out[];
                centroid out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                centroid in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case sample
            version 310 es
            desc "Sample varying"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require extension { "GL_OES_shader_multisample_interpolation" }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                sample out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                sample in mediump float tc_in[];
                sample out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                sample in mediump float tc_out[];
                sample out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                sample in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case patch
            version 310 es
            desc "Pre-patch varying"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                patch out mediump float tc_out;
                void main()
                {
                    tc_out = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                patch in mediump float tc_out;
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end
    end

    import "linkage_tessellation_varying_types.test"
end

group uniform "Uniform"
    group rules "Rules"
        case type_mismatch_1
            version 310 es
            desc "uniform type mismatch between vertex and tessellation control shaders"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                uniform mediump float val;
                out mediump float vtx_out;
                void main()
                {
                    vtx_out = val;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                uniform mediump vec2 val;
                in mediump float vtx_out[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = vtx_out[0] + val.x + val.y;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    ${FRAG_COLOR} = vec4(te_out);
                }
            ""
        end

        case type_mismatch_2
            version 310 es
            desc "uniform type mismatch between fragment and tessellation eval shaders"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float vtx_out;
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                void main()
                {
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                uniform mediump vec3 val;
                out mediump float te_out;
                void main()
                {
                    te_out = val.x + val.y + val.z;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                uniform mediump vec4 val;
                in mediump float te_out;
                void main()
                {
                    ${FRAG_COLOR} = vec4(te_out) + val;
                }
            ""
        end

        case type_mismatch_3
            version 310 es
            desc "uniform type mismatch between tessellation control and eval shaders"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float vtx_out;
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                uniform mediump vec4 val;
                out mediump vec4 tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = val;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                uniform mediump vec3 val;
                in mediump vec4 tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[0].w * val.z;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    ${FRAG_COLOR} = vec4(te_out);
                }
            ""
        end

        case type_mismatch_4
            version 310 es
            desc "uniform type mismatch between vertex and tessellation control shaders"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require limit "GL_MAX_VERTEX_ATOMIC_COUNTERS" > 0
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                layout(binding=0) uniform atomic_uint u_var;
                out mediump float vtx_out;
                void main()
                {
                    uint result = atomicCounterIncrement(u_var);
                    vtx_out = float(result);
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                uniform mediump float u_var;
                in mediump float vtx_out[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = vtx_out[0] + u_var;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    ${FRAG_COLOR} = vec4(te_out);
                }
            ""
        end

        case type_mismatch_5
            version 310 es
            desc "uniform type mismatch between vertex and tessellation control shaders"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            require limit "GL_MAX_VERTEX_IMAGE_UNIFORMS" > 0
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                layout(binding=0) layout(rgba8i) uniform readonly highp iimage2D u_var;
                out mediump float vtx_out;
                void main()
                {
                    int result = imageSize(u_var).x;
                    vtx_out = float(result);
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                uniform mediump float u_var;
                in mediump float vtx_out[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = vtx_out[0] + u_var;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    ${FRAG_COLOR} = vec4(te_out);
                }
            ""
        end

        case precision_mismatch_1
            version 310 es
            desc "uniform precision mismatch between tessellation control and eval shaders"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float vtx_out;
                void main()
                {
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                uniform mediump vec4 val;
                out mediump vec4 tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = val;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                uniform highp vec4 val;
                in mediump vec4 tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[0].w * val.z;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    ${FRAG_COLOR} = vec4(te_out);
                }
            ""
        end

        case precision_mismatch_2
            version 310 es
            desc "uniform precision mismatch between vertex and tessellation control shaders"
            expect link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                uniform highp float val;
                out mediump float vtx_out;
                void main()
                {
                    vtx_out = val;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                uniform mediump float val;
                in mediump float vtx_out[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = vtx_out[0] + val;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    ${FRAG_COLOR} = vec4(te_out);
                }
            ""
        end

        case struct_partial_usage
            version 310 es
            desc "uniform is partially used in different shader stages"
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                uniform float val.vtxVal = 1.5;
                uniform float val.tcVal = 2.5;
                uniform float val.teVal = 6.0;
                uniform float val.fragVal = 11.0;
                output float out0 = 68.5;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                struct S
                {
                    mediump float vtxVal;
                    mediump float tcVal;
                    mediump float teVal;
                    mediump float fragVal;
                };
                uniform S val;
                out mediump float vtx_out;
                void main()
                {
                    vtx_out = val.vtxVal;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                struct S
                {
                    mediump float vtxVal;
                    mediump float tcVal;
                    mediump float teVal;
                    mediump float fragVal;
                };
                uniform S val;
                in mediump float vtx_out[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = vtx_out[0] + 2.0 * val.tcVal;
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                struct S
                {
                    mediump float vtxVal;
                    mediump float tcVal;
                    mediump float teVal;
                    mediump float fragVal;
                };
                uniform S val;
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2] + 3.0 * val.teVal;
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                struct S
                {
                    mediump float vtxVal;
                    mediump float tcVal;
                    mediump float teVal;
                    mediump float fragVal;
                };
                uniform S val;
                in mediump float te_out;
                void main()
                {
                    out0 = te_out + 4.0 * val.fragVal;
                    ${FRAGMENT_OUTPUT};
                }
            ""
        end
    end

    import "linkage_tessellation_uniform_types.test"
end

group layout_declarations "Layout linkage"
    group rules "Rules"

        case primitive_mode_mismatch
            version 310 es
            desc "Tessellation evaluation shader primitive mode mismatch"
            expect compile_or_link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                layout (triangles) in;
                layout (isolines) in;
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case spacing_mode_mismatch
            version 310 es
            desc "Tessellation evaluation shader spacing mode mismatch"
            expect compile_or_link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                layout (triangles, equal_spacing) in;
                layout (triangles, fractional_odd_spacing) in;
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case vertex_order_mismatch
            version 310 es
            desc "Tessellation evaluation shader vertex order mismatch"
            expect compile_or_link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                layout (triangles, cw) in;
                layout (triangles, ccw) in;
                    in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case vertex_count_mismatch
            version 310 es
            desc "Tessellation control shader vertex count mismatch"
            expect compile_or_link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                layout (vertices=3) out;
                layout (vertices=4) out;
                in mediump float tc_in[];
                out mediump float tc_out[];
                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end
    end
end

group barriers "Barriers"
    group rules "Rules"

        case invalid_barrier_usage_within_control_flow
            version 310 es
            desc "Tessellation control shader invalid barrier usage within control flow statement"
            expect compile_or_link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];

                void main()
                {
                    if (gl_InvocationID == 0)
                        barrier(); // error: within control flow

                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end

        case invalid_barrier_usage_after_return
            version 310 es
            desc "Tessellation control shader invalid barrier usage after main() returns"
            expect compile_or_link_fail
            require extension { "GL_OES_tessellation_shader" | "GL_EXT_tessellation_shader" } in { tessellation_control, tessellation_evaluation }
            values
            {
                input float in0 = 1.0;
                output float out0 = 1.0;
            }
            vertex ""
                #version 310 es
                ${VERTEX_DECLARATIONS}
                out mediump float tc_in;
                void main()
                {
                    tc_in = in0;
                    ${VERTEX_OUTPUT}
                }
            ""
            tessellation_control ""
                #version 310 es
                ${TESSELLATION_CONTROL_DECLARATIONS}
                in mediump float tc_in[];
                out mediump float tc_out[];

                void main()
                {
                    tc_out[gl_InvocationID] = tc_in[gl_InvocationID];
                    ${TESSELLATION_CONTROL_OUTPUT}

                    return;
                    barrier(); // error: barrier() after return
                }
            ""
            tessellation_evaluation ""
                #version 310 es
                ${TESSELLATION_EVALUATION_DECLARATIONS}
                in mediump float tc_out[];
                out mediump float te_out;
                void main()
                {
                    te_out = tc_out[2];
                    ${TESSELLATION_EVALUATION_OUTPUT}
                }
            ""
            fragment ""
                #version 310 es
                precision mediump float;
                ${FRAGMENT_DECLARATIONS}
                in mediump float te_out;
                void main()
                {
                    out0 = te_out;
                    ${FRAGMENT_OUTPUT}
                }
            ""
        end
    end
end
