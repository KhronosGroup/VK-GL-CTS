#ifndef _ESEXTCTESSELLATIONSHADERTRIANGLES_HPP
#define _ESEXTCTESSELLATIONSHADERTRIANGLES_HPP
/*-------------------------------------------------------------------------
 * OpenGL Conformance Test Suite
 * -----------------------------
 *
 * Copyright (c) 2014-2016 The Khronos Group Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */ /*!
 * \file
 * \brief
 */ /*-------------------------------------------------------------------*/

#include "../esextcTestCaseBase.hpp"
#include "esextcTessellationShaderUtils.hpp"
#include "gluShaderUtil.hpp"
#include "tcuDefs.hpp"

namespace glcts
{
/** A DEQP CTS test group that collects all tests that verify triangle
 *  tessellation.
 */
class TessellationShaderTrianglesTests : public glcts::TestCaseGroupBase
{
public:
    /* Public methods */
    TessellationShaderTrianglesTests(glcts::Context &context, const ExtParameters &extParams);

    virtual ~TessellationShaderTrianglesTests(void)
    {
    }

    void init(void);

private:
    /* Private methods */
    TessellationShaderTrianglesTests(const TessellationShaderTrianglesTests &other);
    TessellationShaderTrianglesTests &operator=(const TessellationShaderTrianglesTests &other);
};

/** Implementation of Test Caes 29
 *
 *  Make sure that only a single triangle with (u,v,w) coordinates set to
 *  (0, 0, 1), (1, 0, 0) and (0, 1, 0) is generated by tessellation primitive
 *  generator if the first inner tessellation level and all three outer
 *  tessellation levels are set to one, equal_spacing or
 *  fractional_odd_spacing vertex spacing modes are used AND triangles
 *  geometry is requested.
 *
 *  The test should capture vertices output in TE stage, given the
 *  pre-conditions described in the test summary, and then verify vertex
 *  locations. Assume epsilon 1e-5. A single triangle should be drawn.
 *
 **/
class TessellationShaderTrianglesDegenerateTriangle : public TestCaseBase
{
public:
    /* Public methods */
    TessellationShaderTrianglesDegenerateTriangle(Context &context, const ExtParameters &extParams);

    virtual ~TessellationShaderTrianglesDegenerateTriangle(void)
    {
    }

    virtual void deinit(void);
    void initTest(void);
    virtual IterateResult iterate(void);

private:
    /* Private type definitions */
    typedef struct _test_descriptor
    {
        glw::GLuint po_id;
        glw::GLuint te_id;
        _tessellation_shader_vertex_spacing vertex_spacing;

        _test_descriptor()
        {
            po_id          = 0;
            te_id          = 0;
            vertex_spacing = TESSELLATION_SHADER_VERTEX_SPACING_UNKNOWN;
        }
    } _test_descriptor;

    typedef std::vector<_test_descriptor> _tests;
    typedef _tests::const_iterator _tests_const_iterator;

    /* Private methods */
    void deinitTestDescriptor(_test_descriptor &test);

    void initTestDescriptor(_test_descriptor &test, _tessellation_shader_vertex_spacing vertex_spacing);

    /* Private variables */
    glw::GLuint m_bo_id;
    glw::GLuint m_fs_id;
    glw::GLuint m_tc_id;
    glw::GLuint m_vs_id;
    glw::GLuint m_vao_id;

    _tests m_tests;
};

/** Implementation of Test Case 28
 *
 *  Make sure that modifying second inner tessellation level and fourth outer
 *  tessellation level does not affect geometry generated by tessellation
 *  primitive generator, while in triangles mode.
 *
 *  Technical details:
 *
 *  0. (adapted bullet 0 from test case 25:)
 *     Consider the following set: {1, MAX_TESS_GEN_LEVEL_EXT / 2,
 *     MAX_TESS_GEN_LEVEL_EXT}.
 *
 *  1. For all combinations of values from this set in regard to relevant
 *     inner/outer tessellation levels for triangles generator mode, two
 *     different output vertex sets should be captured in TE:
 *  1a. One for the configuration set considered;
 *  1b. The other one for the configuration set with an exception that
 *      second inner tessellation level and fourth outer tessellation level
 *      have been set to 1/4th of the original value.
 *  2. Test passes if all vertices from the first set can be found in the
 *     second set. (assume epsilon 1e-5)
 *
 **/
class TessellationShaderTrianglesIdenticalTriangles : public TestCaseBase
{
public:
    /* Public methods */
    TessellationShaderTrianglesIdenticalTriangles(Context &context, const ExtParameters &extParams);

    virtual ~TessellationShaderTrianglesIdenticalTriangles(void)
    {
    }

    virtual void deinit(void);
    void initTest(void);
    virtual IterateResult iterate(void);

private:
    /* Private type definitions */
    typedef struct _run
    {
        float base_inner[2];
        float base_outer[4];
        float reference_inner[2];
        float reference_outer[4];

        std::vector<char> base_data;
        std::vector<char> reference_data;
        unsigned int n_vertices;

        _run()
        {
            memset(base_inner, 0, sizeof(base_inner));
            memset(base_outer, 0, sizeof(base_outer));
            memset(reference_inner, 0, sizeof(reference_inner));
            memset(reference_outer, 0, sizeof(reference_outer));

            n_vertices = 0;
        }
    } _run;

    typedef std::vector<_run> _runs;
    typedef _runs::const_iterator _runs_const_iterator;

    /* Private variables */
    glw::GLuint m_vao_id;
    _runs m_runs;
    TessellationShaderUtils *m_utils;
};

/**  Implementation of Test Case 30
 *
 *   Consider triangle tessellation.
 *   Make sure that if inner tessellation level is set to one and any of the outer
 *   tessellation levels is greater than one, the inner tessellation level
 *   will be rounded up to two or three, depending on active vertex spacing mode.
 *
 *   Technical details:
 *
 *   0. Consider a set:
 *
 *      A = {2, MAX_TESS_GEN_LEVEL_EXT / 2, MAX_TESS_GEN_LEVEL_EXT};
 *
 *   1. For all values in A, and for all vertex spacing modes, let x be an
 *      iteration-specific value from the set.
 *   1a. Assuming an inner tessellation level set to 1 and outer tessellation level
 *       set to x, "draw" a single patch. Capture output vertices from TE stage.
 *   1b. Assuming an inner tessellation level set to 1 or 2 (depending on how
 *       the rounding should work for iteration-specific vertex ordering mode)
 *       and outer tessellation level set to x, "draw" a single patch. Capture
 *       output vertices from TE stage to another buffer object region.
 *   1c. Iteration passes if all vertices from the first captured set can be
 *       found in the second captured set. [assume epsilon 1e-5].
 *   2. Test passes if all iteration passed successfully.
 *
 **/
class TessellationShaderTrianglesInnerTessellationLevelRounding : public TestCaseBase
{
public:
    /* Public methods */
    TessellationShaderTrianglesInnerTessellationLevelRounding(Context &context, const ExtParameters &extParams);

    virtual ~TessellationShaderTrianglesInnerTessellationLevelRounding(void)
    {
    }

    virtual void deinit(void);
    virtual IterateResult iterate(void);
    void runTestIterations(void);

private:
    /* Private type definitions */
    typedef struct _run
    {
        float set1_inner[2];
        float set1_outer[4];
        float set2_inner[2];
        float set2_outer[4];
        _tessellation_shader_vertex_spacing vertex_spacing;

        std::vector<char> set1_data;
        std::vector<char> set2_data;
        unsigned int n_vertices;

        _run()
        {
            memset(set1_inner, 0, sizeof(set1_inner));
            memset(set1_outer, 0, sizeof(set1_outer));
            memset(set2_inner, 0, sizeof(set2_inner));
            memset(set2_outer, 0, sizeof(set2_outer));

            n_vertices     = 0;
            vertex_spacing = TESSELLATION_SHADER_VERTEX_SPACING_UNKNOWN;
        }
    } _run;

    typedef std::vector<_run> _runs;
    typedef _runs::const_iterator _runs_const_iterator;

    /* Private variables */
    glw::GLuint m_vao_id;
    _runs m_runs;
    TessellationShaderUtils *m_utils;
};

} // namespace glcts

#endif // _ESEXTCTESSELLATIONSHADERTRIANGLES_HPP
