#ifndef _GL3CTEXTURESWIZZLETESTS_HPP
#define _GL3CTEXTURESWIZZLETESTS_HPP
/*-------------------------------------------------------------------------
 * OpenGL Conformance Test Suite
 * -----------------------------
 *
 * Copyright (c) 2015-2016 The Khronos Group Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 */ /*!
 * \file
 * \brief
 */ /*-------------------------------------------------------------------*/

/**
 * \file  gl3cTextureSwizzleTests.hpp
 * \brief Declares test classes for "Texture Swizzle" functionality.
 */ /*-------------------------------------------------------------------*/

#include "glcTestCase.hpp"
#include "glwDefs.hpp"
#include "glwEnums.hpp"
#include "tcuDefs.hpp"
#include "tcuVector.hpp"
#include <queue>

namespace gl3cts
{
namespace TextureSwizzle
{
class Utils
{
public:
    /** Store information about program object
     *
     **/
    struct programInfo
    {
        programInfo(deqp::Context &context);
        ~programInfo();

        void build(const glw::GLchar *fragment_shader_code, const glw::GLchar *vertex_shader_code);
        void compile(glw::GLuint shader_id, const glw::GLchar *shader_code) const;
        void link() const;

        deqp::Context &m_context;

        glw::GLuint m_fragment_shader_id;
        glw::GLuint m_program_object_id;
        glw::GLuint m_vertex_shader_id;
    };

    /* Public static methods */
    static void replaceToken(const glw::GLchar *token, size_t &search_position, const glw::GLchar *text,
                             std::string &string);
};

/** Implements APIErrors test, description follows:
 *
 * Verifies that errors are generated as expected.
 *
 * Check if:
 * - INVALID_OPERATION is generated by TexParameter* routines when <pname> is
 * one of [TEXTURE_SWIZZLE_R, TEXTURE_SWIZZLE_G, TEXTURE_SWIZZLE_B,
 * TEXTURE_SWIZZLE_A] and <param> is not one of [RED, GREEN, BLUE, ALPHA, ZERO,
 * ONE];
 * - INVALID_OPERATION is generated by TexParameter*v routines when <pname> is
 * TEXTURE_SWIZZLE_RGBA and any of four values pointed by <param> is not one of
 * [RED, GREEN, BLUE, ALPHA, ZERO, ONE].
 **/
class APIErrorsTest : public deqp::TestCase
{
public:
    /* Public methods */
    APIErrorsTest(deqp::Context &context);

    virtual void deinit();
    virtual tcu::TestNode::IterateResult iterate();

private:
    /* Private methods */
    void verifyError(const glw::GLenum expected_error);

    /* Private fields */
    glw::GLuint m_id;
};

/** Implements IntialState test, description follows:
 *
 * Verifies that intial state is as expected.
 *
 * Steps:
 * - create a texture;
 * - verify that query for TEXTURE_SWIZZLE_R results with RED;
 * - verify that query for TEXTURE_SWIZZLE_G results with GREEN;
 * - verify that query for TEXTURE_SWIZZLE_B results with BLUE;
 * - verify that query for TEXTURE_SWIZZLE_A results with ALPHA;
 * - verify that query for TEXTURE_SWIZZLE_RGBA results with [RED, GREEN, BLUE,
 * ALPHA].
 *
 * Use GetTexParameter to query states. If GL_ARB_direct_state_access is
 * supported than repeat the steps with GetTextureParameter.
 * Repeat the steps for all supported texture targets.
 **/
class IntialStateTest : public deqp::TestCase
{
public:
    /* Public methods */
    IntialStateTest(deqp::Context &context);

    virtual void deinit();
    virtual tcu::TestNode::IterateResult iterate();

private:
    /* Private methods */
    void verifyValues(const glw::GLenum texture_target);

    /* Private fields */
    glw::GLuint m_id;
};

/** Implements Smoke test, description follows:
 *
 * Verifies that all swizzle combinations work with all texture access
 * routines.
 *
 * Steps:
 * - prepare a source texture so that each channel is filled with specific
 * value;
 * - for each TEXTURE_SWIZZLE state combination:
 *   * for each channel [R, G, B, A]:
 *     + prepare a 2D single channeled texture with format matching sampled
 *     channel and set it up as output color in framebuffer;
 *     + prepare a program that will implement the following snippet in vertex
 *     stage and output the value of result:
 *
 *       result = texture(source).C;
 *
 *     + set swizzle states with channel specific enums;
 *     + draw a full-screen quad;
 *     + verify that the output texture is filled with correct value;
 *     + set swizzle states with RGBA enum;
 *     + draw a full-screen quad;
 *     + verify that the output texture is filled with correct value;
 *     + prepare a program that will implement the following snippet in
 *     fragment stage and output the value of result:
 *
 *       result = texture(source).C;
 *
 *     + set swizzle states with channel specific enums;
 *     + draw a full-screen quad;
 *     + verify that the output texture is filled with correct value;
 *     + set swizzle states with RGBA enum;
 *     + draw a full-screen quad;
 *     + verify that the output texture is filled with correct value.
 *
 * Value is correct when:
 * - it matches value assigned to the specified channel;
 * - it is one for missing alpha channel;
 * - it is zero for missing channel;
 * - it is one for ONE;
 * - it is zero for ZERO.
 *
 * Before any draw output texture should be cleared.
 * Source texture should be RGBA32UI 2D_ARRAY 1x1 of length 1 with
 * single mipmap at level 0.
 * Dimenssions of destination texture should be 8x8.
 * Repeat the steps for the following texture access routines:
 * - textureProj,
 * - textureLod,
 * - textureOffset,
 * - texelFetch,
 * - texelFetchOffset,
 * - textureProjOffset,
 * - textureLodOffset,
 * - textureProjLod,
 * - textureProjLodOffset,
 * - textureGrad,
 * - textureGradOffset,
 * - textureProjGrad,
 * - textureProjGradOffset.
 **/
class SmokeTest : public deqp::TestCase
{
public:
    /* Public methods */
    SmokeTest(deqp::Context &context);
    SmokeTest(deqp::Context &context, size_t access_idx, size_t channel_idx);
    SmokeTest(deqp::Context &context, const glw::GLchar *name, const glw::GLchar *description);

    virtual void deinit();
    virtual tcu::TestNode::IterateResult iterate();

protected:
    /* Protected types */
    struct testCase
    {
        size_t m_channel_index;
        size_t m_source_texture_format_index;
        size_t m_source_texture_target_index;
        size_t m_texture_access_index;
        glw::GLint m_texture_swizzle_red;
        glw::GLint m_texture_swizzle_green;
        glw::GLint m_texture_swizzle_blue;
        glw::GLint m_texture_swizzle_alpha;
        glw::GLint m_texture_sizes[4];
    };

    /* Protected methods */
    void captureAndVerify(const testCase &test_case, size_t output_format_index, glw::GLint output_channel_size,
                          size_t index_of_swizzled_channel);

    void deinitOutputTexture();
    void deinitTextures();

    void draw(glw::GLenum target, const glw::GLint *texture_swizzle, bool use_rgba_enum);

    void executeTestCase(const testCase &test_case);

    virtual bool fillSourceTexture(size_t format_idx, size_t target_idx);

    std::string getFragmentShader(const testCase &test_case, size_t output_format_index, bool is_tested_stage);

    std::string getVertexShader(const testCase &test_case, bool is_tested_stage);

    bool isTargetSupported(size_t target_idx);

    bool isTargetSuppByAccess(size_t access_idx, size_t target_idx);

    bool isTargetSuppByFormat(size_t format_idx, size_t target_idx);

    void logTestCaseDetials(const testCase &test_case);

    void prepareAndTestProgram(const testCase &test_case, size_t output_format_index, glw::GLint output_channel_size,
                               size_t index_of_swizzled_channel, bool test_vertex_stage);

    std::string prepareArguments(const testCase &test_case);
    std::string prepareCoordinates(const testCase &test_case);

    std::string prepareDerivatives(const testCase &test_case, size_t index);

    std::string prepareOffsets(const testCase &test_case);
    void prepareOutputTexture(size_t format_idx);

    std::string prepareSample();
    void prepareSourceTexture(size_t format_idx, size_t target_idx, glw::GLint out_sizes[4]);

    void testInit();

    virtual void verifyOutputImage(const testCase &test_case, size_t output_format_index,
                                   glw::GLint output_channel_size, size_t index_of_swizzled_channel,
                                   const glw::GLubyte *data);

    /* Protected fields */
    bool m_is_ms_supported;
    glw::GLuint m_prepare_fbo_id;
    glw::GLuint m_out_tex_id;
    glw::GLuint m_source_tex_id;
    glw::GLuint m_test_fbo_id;
    glw::GLuint m_vao_id;

    /* Protected constants */
    static const glw::GLsizei m_depth;
    static const glw::GLsizei m_height;
    static const glw::GLsizei m_width;
    static const glw::GLsizei m_output_height;
    static const glw::GLsizei m_output_width;

    size_t m_access_idx;
    size_t m_channel_idx;
};

/** Implements Functional test, description follows:
 *
 * Verifies that swizzle is respected for textures of different formats and
 * targets.
 *
 * Modify Smoke in the following aspects:
 * - repeat the steps for all supported sized internal formats and
 * texture targets;
 * - repeat the steps for the texture_swizzle combinations listed below;
 * - use only texelFetch routine.
 *
 * List of texture_swizzle combinations to test:
 * - ABGR,
 * - 01RA,
 * - 0000,
 * - 1111,
 * - BBBB.
 *
 * Depth-stencil textures can be sampled only via RED channel. Test should set
 * DEPTH_STENCIL_TEXTURE_MODE to select which channel will be accessed.
 *
 * For multisampled targets maximum supported number of samples should be used
 * and fetch should be done to last sample.
 *
 * Support of multisampled targets by TexParameter* routines was introduced in
 * extension GL_ARB_texture_storage_multisample, which is part of core
 * specification since 4.3. Therefore texture_swizzle functionality may be used
 * with multisampled targets only if either context is at least 4.3 or
 * extension GL_ARB_texture_storage_multisample is supported.
 **/
class FunctionalTest : public SmokeTest
{
public:
    /* Public methods */
    FunctionalTest(deqp::Context &context, size_t format_idx, size_t tgt_idx);

    virtual tcu::TestNode::IterateResult iterate();

protected:
    /* Protected methods */
    virtual bool fillSourceTexture(size_t format_idx, size_t target_idx);

    bool fillMSTexture(size_t format_idx, size_t target_idx);

    void prepareProgram(size_t format_idx, Utils::programInfo &program);

    std::string prepareValues(size_t format_idx);

    virtual void verifyOutputImage(const testCase &test_case, size_t output_format_index,
                                   glw::GLint output_channel_size, size_t index_of_swizzled_channel,
                                   const glw::GLubyte *data);

private:
    /* Private types */
    class wrongResults : public std::exception
    {
    public:
        wrongResults(const FunctionalTest::testCase &test_case) : m_test_case(test_case)
        {
        }

        virtual ~wrongResults() throw()
        {
        }

        virtual const char *what() const throw()
        {
            return "Found pixel with wrong value";
        }

        FunctionalTest::testCase m_test_case;
    };
    size_t m_format_idx;
    size_t m_tgt_idx;
};
} // namespace TextureSwizzle

/** Group class for GPU Shader 5 conformance tests */
class TextureSwizzleTests : public deqp::TestCaseGroup
{
public:
    /* Public methods */
    TextureSwizzleTests(deqp::Context &context);
    virtual ~TextureSwizzleTests()
    {
    }

    virtual void init(void);

private:
    /* Private methods */
    TextureSwizzleTests(const TextureSwizzleTests &);
    TextureSwizzleTests &operator=(const TextureSwizzleTests &);

    void addSmokeTest();
    void addFunctionalTest();
};
} // namespace gl3cts

#endif // _GL3CTEXTURESWIZZLETESTS_HPP
