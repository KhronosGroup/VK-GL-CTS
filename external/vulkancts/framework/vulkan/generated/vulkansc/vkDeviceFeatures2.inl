/* WARNING: This is auto-generated file. Do not modify, since changes will
 * be lost! Modify the generating script instead.
 * This file was generated by /scripts/gen_framework.py
 */

tcu::TestStatus testPhysicalDeviceFeatureVariablePointersFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVariablePointersFeatures deviceVariablePointersFeatures[count];
    const bool                               isVariablePointersFeatures = checkExtension(properties, "VK_KHR_variable_pointers") || context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isVariablePointersFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVariablePointersFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVariablePointersFeatures));
        deviceVariablePointersFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
        deviceVariablePointersFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVariablePointersFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVariablePointersFeatures[0] << TestLog::EndMessage;

    if (
        deviceVariablePointersFeatures[0].variablePointersStorageBuffer != deviceVariablePointersFeatures[1].variablePointersStorageBuffer ||
        deviceVariablePointersFeatures[0].variablePointers != deviceVariablePointersFeatures[1].variablePointers)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVariablePointersFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMultiviewFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceMultiviewFeatures deviceMultiviewFeatures[count];
    const bool                        isMultiviewFeatures = checkExtension(properties, "VK_KHR_multiview") || context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isMultiviewFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceMultiviewFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMultiviewFeatures));
        deviceMultiviewFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
        deviceMultiviewFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceMultiviewFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceMultiviewFeatures[0] << TestLog::EndMessage;

    if (
        deviceMultiviewFeatures[0].multiview != deviceMultiviewFeatures[1].multiview ||
        deviceMultiviewFeatures[0].multiviewGeometryShader != deviceMultiviewFeatures[1].multiviewGeometryShader ||
        deviceMultiviewFeatures[0].multiviewTessellationShader != deviceMultiviewFeatures[1].multiviewTessellationShader)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceMultiviewFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature16BitStorageFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevice16BitStorageFeatures device16BitStorageFeatures[count];
    const bool                           is16BitStorageFeatures = checkExtension(properties, "VK_KHR_16bit_storage") || context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!is16BitStorageFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&device16BitStorageFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice16BitStorageFeatures));
        device16BitStorageFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
        device16BitStorageFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &device16BitStorageFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << device16BitStorageFeatures[0] << TestLog::EndMessage;

    if (
        device16BitStorageFeatures[0].storageBuffer16BitAccess != device16BitStorageFeatures[1].storageBuffer16BitAccess ||
        device16BitStorageFeatures[0].uniformAndStorageBuffer16BitAccess != device16BitStorageFeatures[1].uniformAndStorageBuffer16BitAccess ||
        device16BitStorageFeatures[0].storagePushConstant16 != device16BitStorageFeatures[1].storagePushConstant16 ||
        device16BitStorageFeatures[0].storageInputOutput16 != device16BitStorageFeatures[1].storageInputOutput16)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevice16BitStorageFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderSubgroupExtendedTypesFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures deviceShaderSubgroupExtendedTypesFeatures[count];
    const bool                                          isShaderSubgroupExtendedTypesFeatures = checkExtension(properties, "VK_KHR_shader_subgroup_extended_types") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isShaderSubgroupExtendedTypesFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderSubgroupExtendedTypesFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures));
        deviceShaderSubgroupExtendedTypesFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
        deviceShaderSubgroupExtendedTypesFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderSubgroupExtendedTypesFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderSubgroupExtendedTypesFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderSubgroupExtendedTypesFeatures[0].shaderSubgroupExtendedTypes != deviceShaderSubgroupExtendedTypesFeatures[1].shaderSubgroupExtendedTypes)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSamplerYcbcrConversionFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceSamplerYcbcrConversionFeatures deviceSamplerYcbcrConversionFeatures[count];
    const bool                                     isSamplerYcbcrConversionFeatures = checkExtension(properties, "VK_KHR_sampler_ycbcr_conversion") || context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isSamplerYcbcrConversionFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceSamplerYcbcrConversionFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures));
        deviceSamplerYcbcrConversionFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
        deviceSamplerYcbcrConversionFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceSamplerYcbcrConversionFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceSamplerYcbcrConversionFeatures[0] << TestLog::EndMessage;

    if (
        deviceSamplerYcbcrConversionFeatures[0].samplerYcbcrConversion != deviceSamplerYcbcrConversionFeatures[1].samplerYcbcrConversion)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceSamplerYcbcrConversionFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureProtectedMemoryFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceProtectedMemoryFeatures deviceProtectedMemoryFeatures[count];
    const bool                              isProtectedMemoryFeatures = context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isProtectedMemoryFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceProtectedMemoryFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceProtectedMemoryFeatures));
        deviceProtectedMemoryFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
        deviceProtectedMemoryFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceProtectedMemoryFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceProtectedMemoryFeatures[0] << TestLog::EndMessage;

    if (
        deviceProtectedMemoryFeatures[0].protectedMemory != deviceProtectedMemoryFeatures[1].protectedMemory)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceProtectedMemoryFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBlendOperationAdvancedFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT deviceBlendOperationAdvancedFeaturesEXT[count];
    const bool                                        isBlendOperationAdvancedFeaturesEXT = checkExtension(properties, "VK_EXT_blend_operation_advanced");

    if (!isBlendOperationAdvancedFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceBlendOperationAdvancedFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT));
        deviceBlendOperationAdvancedFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
        deviceBlendOperationAdvancedFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceBlendOperationAdvancedFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceBlendOperationAdvancedFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceBlendOperationAdvancedFeaturesEXT[0].advancedBlendCoherentOperations != deviceBlendOperationAdvancedFeaturesEXT[1].advancedBlendCoherentOperations)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderDrawParametersFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderDrawParametersFeatures deviceShaderDrawParametersFeatures[count];
    const bool                                   isShaderDrawParametersFeatures = context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isShaderDrawParametersFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderDrawParametersFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderDrawParametersFeatures));
        deviceShaderDrawParametersFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
        deviceShaderDrawParametersFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderDrawParametersFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderDrawParametersFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderDrawParametersFeatures[0].shaderDrawParameters != deviceShaderDrawParametersFeatures[1].shaderDrawParameters)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderDrawParametersFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderFloat16Int8Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderFloat16Int8Features deviceShaderFloat16Int8Features[count];
    const bool                                isShaderFloat16Int8Features = checkExtension(properties, "VK_KHR_shader_float16_int8") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isShaderFloat16Int8Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderFloat16Int8Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderFloat16Int8Features));
        deviceShaderFloat16Int8Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
        deviceShaderFloat16Int8Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderFloat16Int8Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderFloat16Int8Features[0] << TestLog::EndMessage;

    if (
        deviceShaderFloat16Int8Features[0].shaderFloat16 != deviceShaderFloat16Int8Features[1].shaderFloat16 ||
        deviceShaderFloat16Int8Features[0].shaderInt8 != deviceShaderFloat16Int8Features[1].shaderInt8)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderFloat16Int8Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureHostQueryResetFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceHostQueryResetFeatures deviceHostQueryResetFeatures[count];
    const bool                             isHostQueryResetFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isHostQueryResetFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceHostQueryResetFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceHostQueryResetFeatures));
        deviceHostQueryResetFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
        deviceHostQueryResetFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceHostQueryResetFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceHostQueryResetFeatures[0] << TestLog::EndMessage;

    if (
        deviceHostQueryResetFeatures[0].hostQueryReset != deviceHostQueryResetFeatures[1].hostQueryReset)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceHostQueryResetFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureGlobalPriorityQueryFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceGlobalPriorityQueryFeatures deviceGlobalPriorityQueryFeatures[count];
    const bool                                  isGlobalPriorityQueryFeatures = checkExtension(properties, "VK_KHR_global_priority") || context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isGlobalPriorityQueryFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceGlobalPriorityQueryFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceGlobalPriorityQueryFeatures));
        deviceGlobalPriorityQueryFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
        deviceGlobalPriorityQueryFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceGlobalPriorityQueryFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceGlobalPriorityQueryFeatures[0] << TestLog::EndMessage;

    if (
        deviceGlobalPriorityQueryFeatures[0].globalPriorityQuery != deviceGlobalPriorityQueryFeatures[1].globalPriorityQuery)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceGlobalPriorityQueryFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDescriptorIndexingFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceDescriptorIndexingFeatures deviceDescriptorIndexingFeatures[count];
    const bool                                 isDescriptorIndexingFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isDescriptorIndexingFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceDescriptorIndexingFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDescriptorIndexingFeatures));
        deviceDescriptorIndexingFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
        deviceDescriptorIndexingFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceDescriptorIndexingFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceDescriptorIndexingFeatures[0] << TestLog::EndMessage;

    if (
        deviceDescriptorIndexingFeatures[0].shaderInputAttachmentArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderInputAttachmentArrayDynamicIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderUniformTexelBufferArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformTexelBufferArrayDynamicIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderStorageTexelBufferArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageTexelBufferArrayDynamicIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderUniformBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformBufferArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderSampledImageArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderSampledImageArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderStorageBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageBufferArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderStorageImageArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageImageArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderInputAttachmentArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderInputAttachmentArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderUniformTexelBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformTexelBufferArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderStorageTexelBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageTexelBufferArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingUniformBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingUniformBufferUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingSampledImageUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingSampledImageUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingStorageImageUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageImageUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingStorageBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageBufferUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingUniformTexelBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingUniformTexelBufferUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingStorageTexelBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageTexelBufferUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingUpdateUnusedWhilePending != deviceDescriptorIndexingFeatures[1].descriptorBindingUpdateUnusedWhilePending ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingPartiallyBound != deviceDescriptorIndexingFeatures[1].descriptorBindingPartiallyBound ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingVariableDescriptorCount != deviceDescriptorIndexingFeatures[1].descriptorBindingVariableDescriptorCount ||
        deviceDescriptorIndexingFeatures[0].runtimeDescriptorArray != deviceDescriptorIndexingFeatures[1].runtimeDescriptorArray)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceDescriptorIndexingFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTimelineSemaphoreFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceTimelineSemaphoreFeatures deviceTimelineSemaphoreFeatures[count];
    const bool                                isTimelineSemaphoreFeatures = checkExtension(properties, "VK_KHR_timeline_semaphore") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isTimelineSemaphoreFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceTimelineSemaphoreFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures));
        deviceTimelineSemaphoreFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
        deviceTimelineSemaphoreFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceTimelineSemaphoreFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceTimelineSemaphoreFeatures[0] << TestLog::EndMessage;

    if (
        deviceTimelineSemaphoreFeatures[0].timelineSemaphore != deviceTimelineSemaphoreFeatures[1].timelineSemaphore)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceTimelineSemaphoreFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature8BitStorageFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevice8BitStorageFeatures device8BitStorageFeatures[count];
    const bool                          is8BitStorageFeatures = checkExtension(properties, "VK_KHR_8bit_storage") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!is8BitStorageFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&device8BitStorageFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice8BitStorageFeatures));
        device8BitStorageFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
        device8BitStorageFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &device8BitStorageFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << device8BitStorageFeatures[0] << TestLog::EndMessage;

    if (
        device8BitStorageFeatures[0].storageBuffer8BitAccess != device8BitStorageFeatures[1].storageBuffer8BitAccess ||
        device8BitStorageFeatures[0].uniformAndStorageBuffer8BitAccess != device8BitStorageFeatures[1].uniformAndStorageBuffer8BitAccess ||
        device8BitStorageFeatures[0].storagePushConstant8 != device8BitStorageFeatures[1].storagePushConstant8)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevice8BitStorageFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkanMemoryModelFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkanMemoryModelFeatures deviceVulkanMemoryModelFeatures[count];
    const bool                                isVulkanMemoryModelFeatures = checkExtension(properties, "VK_KHR_vulkan_memory_model") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isVulkanMemoryModelFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkanMemoryModelFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures));
        deviceVulkanMemoryModelFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
        deviceVulkanMemoryModelFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkanMemoryModelFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkanMemoryModelFeatures[0] << TestLog::EndMessage;

    if (
        deviceVulkanMemoryModelFeatures[0].vulkanMemoryModel != deviceVulkanMemoryModelFeatures[1].vulkanMemoryModel ||
        deviceVulkanMemoryModelFeatures[0].vulkanMemoryModelDeviceScope != deviceVulkanMemoryModelFeatures[1].vulkanMemoryModelDeviceScope ||
        deviceVulkanMemoryModelFeatures[0].vulkanMemoryModelAvailabilityVisibilityChains != deviceVulkanMemoryModelFeatures[1].vulkanMemoryModelAvailabilityVisibilityChains)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkanMemoryModelFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicInt64Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderAtomicInt64Features deviceShaderAtomicInt64Features[count];
    const bool                                isShaderAtomicInt64Features = checkExtension(properties, "VK_KHR_shader_atomic_int64") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isShaderAtomicInt64Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderAtomicInt64Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicInt64Features));
        deviceShaderAtomicInt64Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
        deviceShaderAtomicInt64Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderAtomicInt64Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderAtomicInt64Features[0] << TestLog::EndMessage;

    if (
        deviceShaderAtomicInt64Features[0].shaderBufferInt64Atomics != deviceShaderAtomicInt64Features[1].shaderBufferInt64Atomics ||
        deviceShaderAtomicInt64Features[0].shaderSharedInt64Atomics != deviceShaderAtomicInt64Features[1].shaderSharedInt64Atomics)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicInt64Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicFloatFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT deviceShaderAtomicFloatFeaturesEXT[count];
    const bool                                   isShaderAtomicFloatFeaturesEXT = checkExtension(properties, "VK_EXT_shader_atomic_float");

    if (!isShaderAtomicFloatFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderAtomicFloatFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT));
        deviceShaderAtomicFloatFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
        deviceShaderAtomicFloatFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderAtomicFloatFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderAtomicFloatFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat32Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat32AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat64Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat64Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat64AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat64AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat32Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat32AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat64Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat64Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat64AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat64AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderImageFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderImageFloat32Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderImageFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderImageFloat32AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].sparseImageFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].sparseImageFloat32Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].sparseImageFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].sparseImageFloat32AtomicAdd)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicFloatFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVertexAttributeDivisorFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVertexAttributeDivisorFeatures deviceVertexAttributeDivisorFeatures[count];
    const bool                                     isVertexAttributeDivisorFeatures = checkExtension(properties, "VK_KHR_vertex_attribute_divisor") || context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isVertexAttributeDivisorFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVertexAttributeDivisorFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVertexAttributeDivisorFeatures));
        deviceVertexAttributeDivisorFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
        deviceVertexAttributeDivisorFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVertexAttributeDivisorFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVertexAttributeDivisorFeatures[0] << TestLog::EndMessage;

    if (
        deviceVertexAttributeDivisorFeatures[0].vertexAttributeInstanceRateDivisor != deviceVertexAttributeDivisorFeatures[1].vertexAttributeInstanceRateDivisor ||
        deviceVertexAttributeDivisorFeatures[0].vertexAttributeInstanceRateZeroDivisor != deviceVertexAttributeDivisorFeatures[1].vertexAttributeInstanceRateZeroDivisor)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVertexAttributeDivisorFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureASTCDecodeFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceASTCDecodeFeaturesEXT deviceASTCDecodeFeaturesEXT[count];
    const bool                            isASTCDecodeFeaturesEXT = checkExtension(properties, "VK_EXT_astc_decode_mode");

    if (!isASTCDecodeFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceASTCDecodeFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT));
        deviceASTCDecodeFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
        deviceASTCDecodeFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceASTCDecodeFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceASTCDecodeFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceASTCDecodeFeaturesEXT[0].decodeModeSharedExponent != deviceASTCDecodeFeaturesEXT[1].decodeModeSharedExponent)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceASTCDecodeFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureScalarBlockLayoutFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceScalarBlockLayoutFeatures deviceScalarBlockLayoutFeatures[count];
    const bool                                isScalarBlockLayoutFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isScalarBlockLayoutFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceScalarBlockLayoutFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures));
        deviceScalarBlockLayoutFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
        deviceScalarBlockLayoutFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceScalarBlockLayoutFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceScalarBlockLayoutFeatures[0] << TestLog::EndMessage;

    if (
        deviceScalarBlockLayoutFeatures[0].scalarBlockLayout != deviceScalarBlockLayoutFeatures[1].scalarBlockLayout)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceScalarBlockLayoutFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureUniformBufferStandardLayoutFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceUniformBufferStandardLayoutFeatures deviceUniformBufferStandardLayoutFeatures[count];
    const bool                                          isUniformBufferStandardLayoutFeatures = checkExtension(properties, "VK_KHR_uniform_buffer_standard_layout") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isUniformBufferStandardLayoutFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceUniformBufferStandardLayoutFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures));
        deviceUniformBufferStandardLayoutFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
        deviceUniformBufferStandardLayoutFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceUniformBufferStandardLayoutFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceUniformBufferStandardLayoutFeatures[0] << TestLog::EndMessage;

    if (
        deviceUniformBufferStandardLayoutFeatures[0].uniformBufferStandardLayout != deviceUniformBufferStandardLayoutFeatures[1].uniformBufferStandardLayout)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceUniformBufferStandardLayoutFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDepthClipEnableFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceDepthClipEnableFeaturesEXT deviceDepthClipEnableFeaturesEXT[count];
    const bool                                 isDepthClipEnableFeaturesEXT = checkExtension(properties, "VK_EXT_depth_clip_enable");

    if (!isDepthClipEnableFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceDepthClipEnableFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT));
        deviceDepthClipEnableFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
        deviceDepthClipEnableFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceDepthClipEnableFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceDepthClipEnableFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceDepthClipEnableFeaturesEXT[0].depthClipEnable != deviceDepthClipEnableFeaturesEXT[1].depthClipEnable)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceDepthClipEnableFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBufferDeviceAddressFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceBufferDeviceAddressFeatures deviceBufferDeviceAddressFeatures[count];
    const bool                                  isBufferDeviceAddressFeatures = checkExtension(properties, "VK_KHR_buffer_device_address") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isBufferDeviceAddressFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceBufferDeviceAddressFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures));
        deviceBufferDeviceAddressFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
        deviceBufferDeviceAddressFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceBufferDeviceAddressFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceBufferDeviceAddressFeatures[0] << TestLog::EndMessage;

    if (
        deviceBufferDeviceAddressFeatures[0].bufferDeviceAddress != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddress ||
        deviceBufferDeviceAddressFeatures[0].bufferDeviceAddressCaptureReplay != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddressCaptureReplay ||
        deviceBufferDeviceAddressFeatures[0].bufferDeviceAddressMultiDevice != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddressMultiDevice)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceBufferDeviceAddressFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureImagelessFramebufferFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceImagelessFramebufferFeatures deviceImagelessFramebufferFeatures[count];
    const bool                                   isImagelessFramebufferFeatures = checkExtension(properties, "VK_KHR_imageless_framebuffer") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isImagelessFramebufferFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceImagelessFramebufferFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceImagelessFramebufferFeatures));
        deviceImagelessFramebufferFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
        deviceImagelessFramebufferFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceImagelessFramebufferFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceImagelessFramebufferFeatures[0] << TestLog::EndMessage;

    if (
        deviceImagelessFramebufferFeatures[0].imagelessFramebuffer != deviceImagelessFramebufferFeatures[1].imagelessFramebuffer)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceImagelessFramebufferFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTextureCompressionASTCHDRFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceTextureCompressionASTCHDRFeatures deviceTextureCompressionASTCHDRFeatures[count];
    const bool                                        isTextureCompressionASTCHDRFeatures = checkExtension(properties, "VK_EXT_texture_compression_astc_hdr") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isTextureCompressionASTCHDRFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceTextureCompressionASTCHDRFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures));
        deviceTextureCompressionASTCHDRFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
        deviceTextureCompressionASTCHDRFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceTextureCompressionASTCHDRFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceTextureCompressionASTCHDRFeatures[0] << TestLog::EndMessage;

    if (
        deviceTextureCompressionASTCHDRFeatures[0].textureCompressionASTC_HDR != deviceTextureCompressionASTCHDRFeatures[1].textureCompressionASTC_HDR)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceTextureCompressionASTCHDRFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureYcbcrImageArraysFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT deviceYcbcrImageArraysFeaturesEXT[count];
    const bool                                  isYcbcrImageArraysFeaturesEXT = checkExtension(properties, "VK_EXT_ycbcr_image_arrays");

    if (!isYcbcrImageArraysFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceYcbcrImageArraysFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT));
        deviceYcbcrImageArraysFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
        deviceYcbcrImageArraysFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceYcbcrImageArraysFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceYcbcrImageArraysFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceYcbcrImageArraysFeaturesEXT[0].ycbcrImageArrays != deviceYcbcrImageArraysFeaturesEXT[1].ycbcrImageArrays)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceYcbcrImageArraysFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePerformanceQueryFeaturesKHR (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevicePerformanceQueryFeaturesKHR devicePerformanceQueryFeaturesKHR[count];
    const bool                                  isPerformanceQueryFeaturesKHR = checkExtension(properties, "VK_KHR_performance_query");

    if (!isPerformanceQueryFeaturesKHR)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&devicePerformanceQueryFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR));
        devicePerformanceQueryFeaturesKHR[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
        devicePerformanceQueryFeaturesKHR[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &devicePerformanceQueryFeaturesKHR[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << devicePerformanceQueryFeaturesKHR[0] << TestLog::EndMessage;

    if (
        devicePerformanceQueryFeaturesKHR[0].performanceCounterQueryPools != devicePerformanceQueryFeaturesKHR[1].performanceCounterQueryPools ||
        devicePerformanceQueryFeaturesKHR[0].performanceCounterMultipleQueryPools != devicePerformanceQueryFeaturesKHR[1].performanceCounterMultipleQueryPools)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevicePerformanceQueryFeaturesKHR");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderClockFeaturesKHR (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderClockFeaturesKHR deviceShaderClockFeaturesKHR[count];
    const bool                             isShaderClockFeaturesKHR = checkExtension(properties, "VK_KHR_shader_clock");

    if (!isShaderClockFeaturesKHR)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderClockFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderClockFeaturesKHR));
        deviceShaderClockFeaturesKHR[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
        deviceShaderClockFeaturesKHR[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderClockFeaturesKHR[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderClockFeaturesKHR[0] << TestLog::EndMessage;

    if (
        deviceShaderClockFeaturesKHR[0].shaderSubgroupClock != deviceShaderClockFeaturesKHR[1].shaderSubgroupClock ||
        deviceShaderClockFeaturesKHR[0].shaderDeviceClock != deviceShaderClockFeaturesKHR[1].shaderDeviceClock)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderClockFeaturesKHR");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentShaderInterlockFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT deviceFragmentShaderInterlockFeaturesEXT[count];
    const bool                                         isFragmentShaderInterlockFeaturesEXT = checkExtension(properties, "VK_EXT_fragment_shader_interlock");

    if (!isFragmentShaderInterlockFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceFragmentShaderInterlockFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT));
        deviceFragmentShaderInterlockFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
        deviceFragmentShaderInterlockFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceFragmentShaderInterlockFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceFragmentShaderInterlockFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderSampleInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderSampleInterlock ||
        deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderPixelInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderPixelInterlock ||
        deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderShadingRateInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderShadingRateInterlock)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSeparateDepthStencilLayoutsFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures deviceSeparateDepthStencilLayoutsFeatures[count];
    const bool                                          isSeparateDepthStencilLayoutsFeatures = checkExtension(properties, "VK_KHR_separate_depth_stencil_layouts") || context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isSeparateDepthStencilLayoutsFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceSeparateDepthStencilLayoutsFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures));
        deviceSeparateDepthStencilLayoutsFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
        deviceSeparateDepthStencilLayoutsFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceSeparateDepthStencilLayoutsFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceSeparateDepthStencilLayoutsFeatures[0] << TestLog::EndMessage;

    if (
        deviceSeparateDepthStencilLayoutsFeatures[0].separateDepthStencilLayouts != deviceSeparateDepthStencilLayoutsFeatures[1].separateDepthStencilLayouts)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderDemoteToHelperInvocationFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures deviceShaderDemoteToHelperInvocationFeatures[count];
    const bool                                             isShaderDemoteToHelperInvocationFeatures = checkExtension(properties, "VK_EXT_shader_demote_to_helper_invocation") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isShaderDemoteToHelperInvocationFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderDemoteToHelperInvocationFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures));
        deviceShaderDemoteToHelperInvocationFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
        deviceShaderDemoteToHelperInvocationFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderDemoteToHelperInvocationFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderDemoteToHelperInvocationFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderDemoteToHelperInvocationFeatures[0].shaderDemoteToHelperInvocation != deviceShaderDemoteToHelperInvocationFeatures[1].shaderDemoteToHelperInvocation)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTexelBufferAlignmentFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT deviceTexelBufferAlignmentFeaturesEXT[count];
    const bool                                      isTexelBufferAlignmentFeaturesEXT = checkExtension(properties, "VK_EXT_texel_buffer_alignment");

    if (!isTexelBufferAlignmentFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceTexelBufferAlignmentFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT));
        deviceTexelBufferAlignmentFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
        deviceTexelBufferAlignmentFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceTexelBufferAlignmentFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceTexelBufferAlignmentFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceTexelBufferAlignmentFeaturesEXT[0].texelBufferAlignment != deviceTexelBufferAlignmentFeaturesEXT[1].texelBufferAlignment)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSubgroupSizeControlFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceSubgroupSizeControlFeatures deviceSubgroupSizeControlFeatures[count];
    const bool                                  isSubgroupSizeControlFeatures = checkExtension(properties, "VK_EXT_subgroup_size_control") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isSubgroupSizeControlFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceSubgroupSizeControlFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures));
        deviceSubgroupSizeControlFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
        deviceSubgroupSizeControlFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceSubgroupSizeControlFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceSubgroupSizeControlFeatures[0] << TestLog::EndMessage;

    if (
        deviceSubgroupSizeControlFeatures[0].subgroupSizeControl != deviceSubgroupSizeControlFeatures[1].subgroupSizeControl ||
        deviceSubgroupSizeControlFeatures[0].computeFullSubgroups != deviceSubgroupSizeControlFeatures[1].computeFullSubgroups)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceSubgroupSizeControlFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkan11Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkan11Features deviceVulkan11Features[count];
    const bool                       isVulkan11Features = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isVulkan11Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkan11Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkan11Features));
        deviceVulkan11Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
        deviceVulkan11Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkan11Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkan11Features[0] << TestLog::EndMessage;

    if (
        deviceVulkan11Features[0].storageBuffer16BitAccess != deviceVulkan11Features[1].storageBuffer16BitAccess ||
        deviceVulkan11Features[0].uniformAndStorageBuffer16BitAccess != deviceVulkan11Features[1].uniformAndStorageBuffer16BitAccess ||
        deviceVulkan11Features[0].storagePushConstant16 != deviceVulkan11Features[1].storagePushConstant16 ||
        deviceVulkan11Features[0].storageInputOutput16 != deviceVulkan11Features[1].storageInputOutput16 ||
        deviceVulkan11Features[0].multiview != deviceVulkan11Features[1].multiview ||
        deviceVulkan11Features[0].multiviewGeometryShader != deviceVulkan11Features[1].multiviewGeometryShader ||
        deviceVulkan11Features[0].multiviewTessellationShader != deviceVulkan11Features[1].multiviewTessellationShader ||
        deviceVulkan11Features[0].variablePointersStorageBuffer != deviceVulkan11Features[1].variablePointersStorageBuffer ||
        deviceVulkan11Features[0].variablePointers != deviceVulkan11Features[1].variablePointers ||
        deviceVulkan11Features[0].protectedMemory != deviceVulkan11Features[1].protectedMemory ||
        deviceVulkan11Features[0].samplerYcbcrConversion != deviceVulkan11Features[1].samplerYcbcrConversion ||
        deviceVulkan11Features[0].shaderDrawParameters != deviceVulkan11Features[1].shaderDrawParameters)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkan11Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkan12Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkan12Features deviceVulkan12Features[count];
    const bool                       isVulkan12Features = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isVulkan12Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkan12Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkan12Features));
        deviceVulkan12Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
        deviceVulkan12Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkan12Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkan12Features[0] << TestLog::EndMessage;

    if (
        deviceVulkan12Features[0].samplerMirrorClampToEdge != deviceVulkan12Features[1].samplerMirrorClampToEdge ||
        deviceVulkan12Features[0].drawIndirectCount != deviceVulkan12Features[1].drawIndirectCount ||
        deviceVulkan12Features[0].storageBuffer8BitAccess != deviceVulkan12Features[1].storageBuffer8BitAccess ||
        deviceVulkan12Features[0].uniformAndStorageBuffer8BitAccess != deviceVulkan12Features[1].uniformAndStorageBuffer8BitAccess ||
        deviceVulkan12Features[0].storagePushConstant8 != deviceVulkan12Features[1].storagePushConstant8 ||
        deviceVulkan12Features[0].shaderBufferInt64Atomics != deviceVulkan12Features[1].shaderBufferInt64Atomics ||
        deviceVulkan12Features[0].shaderSharedInt64Atomics != deviceVulkan12Features[1].shaderSharedInt64Atomics ||
        deviceVulkan12Features[0].shaderFloat16 != deviceVulkan12Features[1].shaderFloat16 ||
        deviceVulkan12Features[0].shaderInt8 != deviceVulkan12Features[1].shaderInt8 ||
        deviceVulkan12Features[0].descriptorIndexing != deviceVulkan12Features[1].descriptorIndexing ||
        deviceVulkan12Features[0].shaderInputAttachmentArrayDynamicIndexing != deviceVulkan12Features[1].shaderInputAttachmentArrayDynamicIndexing ||
        deviceVulkan12Features[0].shaderUniformTexelBufferArrayDynamicIndexing != deviceVulkan12Features[1].shaderUniformTexelBufferArrayDynamicIndexing ||
        deviceVulkan12Features[0].shaderStorageTexelBufferArrayDynamicIndexing != deviceVulkan12Features[1].shaderStorageTexelBufferArrayDynamicIndexing ||
        deviceVulkan12Features[0].shaderUniformBufferArrayNonUniformIndexing != deviceVulkan12Features[1].shaderUniformBufferArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderSampledImageArrayNonUniformIndexing != deviceVulkan12Features[1].shaderSampledImageArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderStorageBufferArrayNonUniformIndexing != deviceVulkan12Features[1].shaderStorageBufferArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderStorageImageArrayNonUniformIndexing != deviceVulkan12Features[1].shaderStorageImageArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderInputAttachmentArrayNonUniformIndexing != deviceVulkan12Features[1].shaderInputAttachmentArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderUniformTexelBufferArrayNonUniformIndexing != deviceVulkan12Features[1].shaderUniformTexelBufferArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderStorageTexelBufferArrayNonUniformIndexing != deviceVulkan12Features[1].shaderStorageTexelBufferArrayNonUniformIndexing ||
        deviceVulkan12Features[0].descriptorBindingUniformBufferUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingUniformBufferUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingSampledImageUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingSampledImageUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingStorageImageUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingStorageImageUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingStorageBufferUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingStorageBufferUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingUniformTexelBufferUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingUniformTexelBufferUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingStorageTexelBufferUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingStorageTexelBufferUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingUpdateUnusedWhilePending != deviceVulkan12Features[1].descriptorBindingUpdateUnusedWhilePending ||
        deviceVulkan12Features[0].descriptorBindingPartiallyBound != deviceVulkan12Features[1].descriptorBindingPartiallyBound ||
        deviceVulkan12Features[0].descriptorBindingVariableDescriptorCount != deviceVulkan12Features[1].descriptorBindingVariableDescriptorCount ||
        deviceVulkan12Features[0].runtimeDescriptorArray != deviceVulkan12Features[1].runtimeDescriptorArray ||
        deviceVulkan12Features[0].samplerFilterMinmax != deviceVulkan12Features[1].samplerFilterMinmax ||
        deviceVulkan12Features[0].scalarBlockLayout != deviceVulkan12Features[1].scalarBlockLayout ||
        deviceVulkan12Features[0].imagelessFramebuffer != deviceVulkan12Features[1].imagelessFramebuffer ||
        deviceVulkan12Features[0].uniformBufferStandardLayout != deviceVulkan12Features[1].uniformBufferStandardLayout ||
        deviceVulkan12Features[0].shaderSubgroupExtendedTypes != deviceVulkan12Features[1].shaderSubgroupExtendedTypes ||
        deviceVulkan12Features[0].separateDepthStencilLayouts != deviceVulkan12Features[1].separateDepthStencilLayouts ||
        deviceVulkan12Features[0].hostQueryReset != deviceVulkan12Features[1].hostQueryReset ||
        deviceVulkan12Features[0].timelineSemaphore != deviceVulkan12Features[1].timelineSemaphore ||
        deviceVulkan12Features[0].bufferDeviceAddress != deviceVulkan12Features[1].bufferDeviceAddress ||
        deviceVulkan12Features[0].bufferDeviceAddressCaptureReplay != deviceVulkan12Features[1].bufferDeviceAddressCaptureReplay ||
        deviceVulkan12Features[0].bufferDeviceAddressMultiDevice != deviceVulkan12Features[1].bufferDeviceAddressMultiDevice ||
        deviceVulkan12Features[0].vulkanMemoryModel != deviceVulkan12Features[1].vulkanMemoryModel ||
        deviceVulkan12Features[0].vulkanMemoryModelDeviceScope != deviceVulkan12Features[1].vulkanMemoryModelDeviceScope ||
        deviceVulkan12Features[0].vulkanMemoryModelAvailabilityVisibilityChains != deviceVulkan12Features[1].vulkanMemoryModelAvailabilityVisibilityChains ||
        deviceVulkan12Features[0].shaderOutputViewportIndex != deviceVulkan12Features[1].shaderOutputViewportIndex ||
        deviceVulkan12Features[0].shaderOutputLayer != deviceVulkan12Features[1].shaderOutputLayer ||
        deviceVulkan12Features[0].subgroupBroadcastDynamicId != deviceVulkan12Features[1].subgroupBroadcastDynamicId)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkan12Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureCustomBorderColorFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceCustomBorderColorFeaturesEXT deviceCustomBorderColorFeaturesEXT[count];
    const bool                                   isCustomBorderColorFeaturesEXT = checkExtension(properties, "VK_EXT_custom_border_color");

    if (!isCustomBorderColorFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceCustomBorderColorFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT));
        deviceCustomBorderColorFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
        deviceCustomBorderColorFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceCustomBorderColorFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceCustomBorderColorFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceCustomBorderColorFeaturesEXT[0].customBorderColors != deviceCustomBorderColorFeaturesEXT[1].customBorderColors ||
        deviceCustomBorderColorFeaturesEXT[0].customBorderColorWithoutFormat != deviceCustomBorderColorFeaturesEXT[1].customBorderColorWithoutFormat)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceCustomBorderColorFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureExtendedDynamicStateFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT deviceExtendedDynamicStateFeaturesEXT[count];
    const bool                                      isExtendedDynamicStateFeaturesEXT = checkExtension(properties, "VK_EXT_extended_dynamic_state");

    if (!isExtendedDynamicStateFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceExtendedDynamicStateFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT));
        deviceExtendedDynamicStateFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
        deviceExtendedDynamicStateFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceExtendedDynamicStateFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceExtendedDynamicStateFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceExtendedDynamicStateFeaturesEXT[0].extendedDynamicState != deviceExtendedDynamicStateFeaturesEXT[1].extendedDynamicState)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceExtendedDynamicStateFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureExtendedDynamicState2FeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT deviceExtendedDynamicState2FeaturesEXT[count];
    const bool                                       isExtendedDynamicState2FeaturesEXT = checkExtension(properties, "VK_EXT_extended_dynamic_state2");

    if (!isExtendedDynamicState2FeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceExtendedDynamicState2FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT));
        deviceExtendedDynamicState2FeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
        deviceExtendedDynamicState2FeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceExtendedDynamicState2FeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceExtendedDynamicState2FeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2 != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2 ||
        deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2LogicOp != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2LogicOp ||
        deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2PatchControlPoints != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2PatchControlPoints)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceExtendedDynamicState2FeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureRobustness2FeaturesKHR (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceRobustness2FeaturesKHR deviceRobustness2FeaturesKHR[count];
    const bool                             isRobustness2FeaturesKHR = checkExtension(properties, "VK_EXT_robustness2");

    if (!isRobustness2FeaturesKHR)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceRobustness2FeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceRobustness2FeaturesKHR));
        deviceRobustness2FeaturesKHR[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
        deviceRobustness2FeaturesKHR[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceRobustness2FeaturesKHR[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceRobustness2FeaturesKHR[0] << TestLog::EndMessage;

    if (
        deviceRobustness2FeaturesKHR[0].robustBufferAccess2 != deviceRobustness2FeaturesKHR[1].robustBufferAccess2 ||
        deviceRobustness2FeaturesKHR[0].robustImageAccess2 != deviceRobustness2FeaturesKHR[1].robustImageAccess2 ||
        deviceRobustness2FeaturesKHR[0].nullDescriptor != deviceRobustness2FeaturesKHR[1].nullDescriptor)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceRobustness2FeaturesKHR");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureImageRobustnessFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceImageRobustnessFeatures deviceImageRobustnessFeatures[count];
    const bool                              isImageRobustnessFeatures = checkExtension(properties, "VK_EXT_image_robustness") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isImageRobustnessFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceImageRobustnessFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceImageRobustnessFeatures));
        deviceImageRobustnessFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
        deviceImageRobustnessFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceImageRobustnessFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceImageRobustnessFeatures[0] << TestLog::EndMessage;

    if (
        deviceImageRobustnessFeatures[0].robustImageAccess != deviceImageRobustnessFeatures[1].robustImageAccess)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceImageRobustnessFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature4444FormatsFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevice4444FormatsFeaturesEXT device4444FormatsFeaturesEXT[count];
    const bool                             is4444FormatsFeaturesEXT = checkExtension(properties, "VK_EXT_4444_formats");

    if (!is4444FormatsFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&device4444FormatsFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice4444FormatsFeaturesEXT));
        device4444FormatsFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
        device4444FormatsFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &device4444FormatsFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << device4444FormatsFeaturesEXT[0] << TestLog::EndMessage;

    if (
        device4444FormatsFeaturesEXT[0].formatA4R4G4B4 != device4444FormatsFeaturesEXT[1].formatA4R4G4B4 ||
        device4444FormatsFeaturesEXT[0].formatA4B4G4R4 != device4444FormatsFeaturesEXT[1].formatA4B4G4R4)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevice4444FormatsFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderImageAtomicInt64FeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT deviceShaderImageAtomicInt64FeaturesEXT[count];
    const bool                                        isShaderImageAtomicInt64FeaturesEXT = checkExtension(properties, "VK_EXT_shader_image_atomic_int64");

    if (!isShaderImageAtomicInt64FeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderImageAtomicInt64FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT));
        deviceShaderImageAtomicInt64FeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
        deviceShaderImageAtomicInt64FeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderImageAtomicInt64FeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderImageAtomicInt64FeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceShaderImageAtomicInt64FeaturesEXT[0].shaderImageInt64Atomics != deviceShaderImageAtomicInt64FeaturesEXT[1].shaderImageInt64Atomics ||
        deviceShaderImageAtomicInt64FeaturesEXT[0].sparseImageInt64Atomics != deviceShaderImageAtomicInt64FeaturesEXT[1].sparseImageInt64Atomics)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentShadingRateFeaturesKHR (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceFragmentShadingRateFeaturesKHR deviceFragmentShadingRateFeaturesKHR[count];
    const bool                                     isFragmentShadingRateFeaturesKHR = checkExtension(properties, "VK_KHR_fragment_shading_rate");

    if (!isFragmentShadingRateFeaturesKHR)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceFragmentShadingRateFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR));
        deviceFragmentShadingRateFeaturesKHR[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
        deviceFragmentShadingRateFeaturesKHR[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceFragmentShadingRateFeaturesKHR[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceFragmentShadingRateFeaturesKHR[0] << TestLog::EndMessage;

    if (
        deviceFragmentShadingRateFeaturesKHR[0].pipelineFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].pipelineFragmentShadingRate ||
        deviceFragmentShadingRateFeaturesKHR[0].primitiveFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].primitiveFragmentShadingRate ||
        deviceFragmentShadingRateFeaturesKHR[0].attachmentFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].attachmentFragmentShadingRate)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentShadingRateFeaturesKHR");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderTerminateInvocationFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderTerminateInvocationFeatures deviceShaderTerminateInvocationFeatures[count];
    const bool                                        isShaderTerminateInvocationFeatures = checkExtension(properties, "VK_KHR_shader_terminate_invocation") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isShaderTerminateInvocationFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderTerminateInvocationFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures));
        deviceShaderTerminateInvocationFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
        deviceShaderTerminateInvocationFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderTerminateInvocationFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderTerminateInvocationFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderTerminateInvocationFeatures[0].shaderTerminateInvocation != deviceShaderTerminateInvocationFeatures[1].shaderTerminateInvocation)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderTerminateInvocationFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVertexInputDynamicStateFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT deviceVertexInputDynamicStateFeaturesEXT[count];
    const bool                                         isVertexInputDynamicStateFeaturesEXT = checkExtension(properties, "VK_EXT_vertex_input_dynamic_state");

    if (!isVertexInputDynamicStateFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVertexInputDynamicStateFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT));
        deviceVertexInputDynamicStateFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
        deviceVertexInputDynamicStateFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVertexInputDynamicStateFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVertexInputDynamicStateFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceVertexInputDynamicStateFeaturesEXT[0].vertexInputDynamicState != deviceVertexInputDynamicStateFeaturesEXT[1].vertexInputDynamicState)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureColorWriteEnableFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceColorWriteEnableFeaturesEXT deviceColorWriteEnableFeaturesEXT[count];
    const bool                                  isColorWriteEnableFeaturesEXT = checkExtension(properties, "VK_EXT_color_write_enable");

    if (!isColorWriteEnableFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceColorWriteEnableFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT));
        deviceColorWriteEnableFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
        deviceColorWriteEnableFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceColorWriteEnableFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceColorWriteEnableFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceColorWriteEnableFeaturesEXT[0].colorWriteEnable != deviceColorWriteEnableFeaturesEXT[1].colorWriteEnable)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceColorWriteEnableFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSynchronization2Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceSynchronization2Features deviceSynchronization2Features[count];
    const bool                               isSynchronization2Features = checkExtension(properties, "VK_KHR_synchronization2") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isSynchronization2Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceSynchronization2Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSynchronization2Features));
        deviceSynchronization2Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
        deviceSynchronization2Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceSynchronization2Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceSynchronization2Features[0] << TestLog::EndMessage;

    if (
        deviceSynchronization2Features[0].synchronization2 != deviceSynchronization2Features[1].synchronization2)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceSynchronization2Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkanSC10Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkanSC10Features deviceVulkanSC10Features[count];
    const bool                         isVulkanSC10Features = context.contextSupports(vk::ApiVersion(1, 1, 0, 0));

    if (!isVulkanSC10Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkanSC10Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkanSC10Features));
        deviceVulkanSC10Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES;
        deviceVulkanSC10Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkanSC10Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkanSC10Features[0] << TestLog::EndMessage;

    if (
        deviceVulkanSC10Features[0].shaderAtomicInstructions != deviceVulkanSC10Features[1].shaderAtomicInstructions)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkanSC10Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureYcbcr2Plane444FormatsFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT deviceYcbcr2Plane444FormatsFeaturesEXT[count];
    const bool                                       isYcbcr2Plane444FormatsFeaturesEXT = checkExtension(properties, "VK_EXT_ycbcr_2plane_444_formats");

    if (!isYcbcr2Plane444FormatsFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceYcbcr2Plane444FormatsFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT));
        deviceYcbcr2Plane444FormatsFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
        deviceYcbcr2Plane444FormatsFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceYcbcr2Plane444FormatsFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceYcbcr2Plane444FormatsFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceYcbcr2Plane444FormatsFeaturesEXT[0].ycbcr2plane444Formats != deviceYcbcr2Plane444FormatsFeaturesEXT[1].ycbcr2plane444Formats)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

void addSeparateFeatureTests (tcu::TestCaseGroup* testGroup)
{
	addFunctionCase(testGroup, "variable_pointers_features", testPhysicalDeviceFeatureVariablePointersFeatures);
	addFunctionCase(testGroup, "multiview_features", testPhysicalDeviceFeatureMultiviewFeatures);
	addFunctionCase(testGroup, "16_bit_storage_features", testPhysicalDeviceFeature16BitStorageFeatures);
	addFunctionCase(testGroup, "shader_subgroup_extended_types_features", testPhysicalDeviceFeatureShaderSubgroupExtendedTypesFeatures);
	addFunctionCase(testGroup, "sampler_ycbcr_conversion_features", testPhysicalDeviceFeatureSamplerYcbcrConversionFeatures);
	addFunctionCase(testGroup, "protected_memory_features", testPhysicalDeviceFeatureProtectedMemoryFeatures);
	addFunctionCase(testGroup, "blend_operation_advanced_features_ext", testPhysicalDeviceFeatureBlendOperationAdvancedFeaturesEXT);
	addFunctionCase(testGroup, "shader_draw_parameters_features", testPhysicalDeviceFeatureShaderDrawParametersFeatures);
	addFunctionCase(testGroup, "shader_float16_int8_features", testPhysicalDeviceFeatureShaderFloat16Int8Features);
	addFunctionCase(testGroup, "host_query_reset_features", testPhysicalDeviceFeatureHostQueryResetFeatures);
	addFunctionCase(testGroup, "global_priority_query_features", testPhysicalDeviceFeatureGlobalPriorityQueryFeatures);
	addFunctionCase(testGroup, "descriptor_indexing_features", testPhysicalDeviceFeatureDescriptorIndexingFeatures);
	addFunctionCase(testGroup, "timeline_semaphore_features", testPhysicalDeviceFeatureTimelineSemaphoreFeatures);
	addFunctionCase(testGroup, "8_bit_storage_features", testPhysicalDeviceFeature8BitStorageFeatures);
	addFunctionCase(testGroup, "vulkan_memory_model_features", testPhysicalDeviceFeatureVulkanMemoryModelFeatures);
	addFunctionCase(testGroup, "shader_atomic_int64_features", testPhysicalDeviceFeatureShaderAtomicInt64Features);
	addFunctionCase(testGroup, "shader_atomic_float_features_ext", testPhysicalDeviceFeatureShaderAtomicFloatFeaturesEXT);
	addFunctionCase(testGroup, "vertex_attribute_divisor_features", testPhysicalDeviceFeatureVertexAttributeDivisorFeatures);
	addFunctionCase(testGroup, "astc_decode_features_ext", testPhysicalDeviceFeatureASTCDecodeFeaturesEXT);
	addFunctionCase(testGroup, "scalar_block_layout_features", testPhysicalDeviceFeatureScalarBlockLayoutFeatures);
	addFunctionCase(testGroup, "uniform_buffer_standard_layout_features", testPhysicalDeviceFeatureUniformBufferStandardLayoutFeatures);
	addFunctionCase(testGroup, "depth_clip_enable_features_ext", testPhysicalDeviceFeatureDepthClipEnableFeaturesEXT);
	addFunctionCase(testGroup, "buffer_device_address_features", testPhysicalDeviceFeatureBufferDeviceAddressFeatures);
	addFunctionCase(testGroup, "imageless_framebuffer_features", testPhysicalDeviceFeatureImagelessFramebufferFeatures);
	addFunctionCase(testGroup, "texture_compression_astchdr_features", testPhysicalDeviceFeatureTextureCompressionASTCHDRFeatures);
	addFunctionCase(testGroup, "ycbcr_image_arrays_features_ext", testPhysicalDeviceFeatureYcbcrImageArraysFeaturesEXT);
	addFunctionCase(testGroup, "performance_query_features_khr", testPhysicalDeviceFeaturePerformanceQueryFeaturesKHR);
	addFunctionCase(testGroup, "shader_clock_features_khr", testPhysicalDeviceFeatureShaderClockFeaturesKHR);
	addFunctionCase(testGroup, "fragment_shader_interlock_features_ext", testPhysicalDeviceFeatureFragmentShaderInterlockFeaturesEXT);
	addFunctionCase(testGroup, "separate_depth_stencil_layouts_features", testPhysicalDeviceFeatureSeparateDepthStencilLayoutsFeatures);
	addFunctionCase(testGroup, "shader_demote_to_helper_invocation_features", testPhysicalDeviceFeatureShaderDemoteToHelperInvocationFeatures);
	addFunctionCase(testGroup, "texel_buffer_alignment_features_ext", testPhysicalDeviceFeatureTexelBufferAlignmentFeaturesEXT);
	addFunctionCase(testGroup, "subgroup_size_control_features", testPhysicalDeviceFeatureSubgroupSizeControlFeatures);
	addFunctionCase(testGroup, "vulkan11_features", testPhysicalDeviceFeatureVulkan11Features);
	addFunctionCase(testGroup, "vulkan12_features", testPhysicalDeviceFeatureVulkan12Features);
	addFunctionCase(testGroup, "custom_border_color_features_ext", testPhysicalDeviceFeatureCustomBorderColorFeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state_features_ext", testPhysicalDeviceFeatureExtendedDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state2_features_ext", testPhysicalDeviceFeatureExtendedDynamicState2FeaturesEXT);
	addFunctionCase(testGroup, "robustness2_features_khr", testPhysicalDeviceFeatureRobustness2FeaturesKHR);
	addFunctionCase(testGroup, "image_robustness_features", testPhysicalDeviceFeatureImageRobustnessFeatures);
	addFunctionCase(testGroup, "4444_formats_features_ext", testPhysicalDeviceFeature4444FormatsFeaturesEXT);
	addFunctionCase(testGroup, "shader_image_atomic_int64_features_ext", testPhysicalDeviceFeatureShaderImageAtomicInt64FeaturesEXT);
	addFunctionCase(testGroup, "fragment_shading_rate_features_khr", testPhysicalDeviceFeatureFragmentShadingRateFeaturesKHR);
	addFunctionCase(testGroup, "shader_terminate_invocation_features", testPhysicalDeviceFeatureShaderTerminateInvocationFeatures);
	addFunctionCase(testGroup, "vertex_input_dynamic_state_features_ext", testPhysicalDeviceFeatureVertexInputDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "color_write_enable_features_ext", testPhysicalDeviceFeatureColorWriteEnableFeaturesEXT);
	addFunctionCase(testGroup, "synchronization2_features", testPhysicalDeviceFeatureSynchronization2Features);
	addFunctionCase(testGroup, "vulkan_sc10_features", testPhysicalDeviceFeatureVulkanSC10Features);
	addFunctionCase(testGroup, "ycbcr2_plane444_formats_features_ext", testPhysicalDeviceFeatureYcbcr2Plane444FormatsFeaturesEXT);
}

