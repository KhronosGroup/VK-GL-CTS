/* WARNING: This is auto-generated file. Do not modify, since changes will
 * be lost! Modify the generating script instead.
 * This file was generated by /scripts/gen_framework.py
 */

tcu::TestStatus testPhysicalDeviceFeature16BitStorageFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevice16BitStorageFeatures device16BitStorageFeatures[count];
    const bool                           is16BitStorageFeatures = context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!is16BitStorageFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&device16BitStorageFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice16BitStorageFeatures));
        device16BitStorageFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_16BIT_STORAGE_FEATURES;
        device16BitStorageFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &device16BitStorageFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << device16BitStorageFeatures[0] << TestLog::EndMessage;

    if (
        device16BitStorageFeatures[0].storageBuffer16BitAccess != device16BitStorageFeatures[1].storageBuffer16BitAccess ||
        device16BitStorageFeatures[0].uniformAndStorageBuffer16BitAccess != device16BitStorageFeatures[1].uniformAndStorageBuffer16BitAccess ||
        device16BitStorageFeatures[0].storagePushConstant16 != device16BitStorageFeatures[1].storagePushConstant16 ||
        device16BitStorageFeatures[0].storageInputOutput16 != device16BitStorageFeatures[1].storageInputOutput16)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevice16BitStorageFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature4444FormatsFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevice4444FormatsFeaturesEXT device4444FormatsFeaturesEXT[count];
    const bool                             is4444FormatsFeaturesEXT = checkExtension(properties, "VK_EXT_4444_formats");

    if (!is4444FormatsFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&device4444FormatsFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice4444FormatsFeaturesEXT));
        device4444FormatsFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_4444_FORMATS_FEATURES_EXT;
        device4444FormatsFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &device4444FormatsFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << device4444FormatsFeaturesEXT[0] << TestLog::EndMessage;

    if (
        device4444FormatsFeaturesEXT[0].formatA4R4G4B4 != device4444FormatsFeaturesEXT[1].formatA4R4G4B4 ||
        device4444FormatsFeaturesEXT[0].formatA4B4G4R4 != device4444FormatsFeaturesEXT[1].formatA4B4G4R4)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevice4444FormatsFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeature8BitStorageFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevice8BitStorageFeatures device8BitStorageFeatures[count];
    const bool                          is8BitStorageFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!is8BitStorageFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&device8BitStorageFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevice8BitStorageFeatures));
        device8BitStorageFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_8BIT_STORAGE_FEATURES;
        device8BitStorageFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &device8BitStorageFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << device8BitStorageFeatures[0] << TestLog::EndMessage;

    if (
        device8BitStorageFeatures[0].storageBuffer8BitAccess != device8BitStorageFeatures[1].storageBuffer8BitAccess ||
        device8BitStorageFeatures[0].uniformAndStorageBuffer8BitAccess != device8BitStorageFeatures[1].uniformAndStorageBuffer8BitAccess ||
        device8BitStorageFeatures[0].storagePushConstant8 != device8BitStorageFeatures[1].storagePushConstant8)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevice8BitStorageFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureASTCDecodeFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceASTCDecodeFeaturesEXT deviceASTCDecodeFeaturesEXT[count];
    const bool                            isASTCDecodeFeaturesEXT = checkExtension(properties, "VK_EXT_astc_decode_mode");

    if (!isASTCDecodeFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceASTCDecodeFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceASTCDecodeFeaturesEXT));
        deviceASTCDecodeFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ASTC_DECODE_FEATURES_EXT;
        deviceASTCDecodeFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceASTCDecodeFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceASTCDecodeFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceASTCDecodeFeaturesEXT[0].decodeModeSharedExponent != deviceASTCDecodeFeaturesEXT[1].decodeModeSharedExponent)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceASTCDecodeFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBlendOperationAdvancedFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT deviceBlendOperationAdvancedFeaturesEXT[count];
    const bool                                        isBlendOperationAdvancedFeaturesEXT = checkExtension(properties, "VK_EXT_blend_operation_advanced");

    if (!isBlendOperationAdvancedFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceBlendOperationAdvancedFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT));
        deviceBlendOperationAdvancedFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BLEND_OPERATION_ADVANCED_FEATURES_EXT;
        deviceBlendOperationAdvancedFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceBlendOperationAdvancedFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceBlendOperationAdvancedFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceBlendOperationAdvancedFeaturesEXT[0].advancedBlendCoherentOperations != deviceBlendOperationAdvancedFeaturesEXT[1].advancedBlendCoherentOperations)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureBufferDeviceAddressFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceBufferDeviceAddressFeatures deviceBufferDeviceAddressFeatures[count];
    const bool                                  isBufferDeviceAddressFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isBufferDeviceAddressFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceBufferDeviceAddressFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceBufferDeviceAddressFeatures));
        deviceBufferDeviceAddressFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_BUFFER_DEVICE_ADDRESS_FEATURES;
        deviceBufferDeviceAddressFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceBufferDeviceAddressFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceBufferDeviceAddressFeatures[0] << TestLog::EndMessage;

    if (
        deviceBufferDeviceAddressFeatures[0].bufferDeviceAddress != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddress ||
        deviceBufferDeviceAddressFeatures[0].bufferDeviceAddressCaptureReplay != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddressCaptureReplay ||
        deviceBufferDeviceAddressFeatures[0].bufferDeviceAddressMultiDevice != deviceBufferDeviceAddressFeatures[1].bufferDeviceAddressMultiDevice)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceBufferDeviceAddressFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureColorWriteEnableFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceColorWriteEnableFeaturesEXT deviceColorWriteEnableFeaturesEXT[count];
    const bool                                  isColorWriteEnableFeaturesEXT = checkExtension(properties, "VK_EXT_color_write_enable");

    if (!isColorWriteEnableFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceColorWriteEnableFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceColorWriteEnableFeaturesEXT));
        deviceColorWriteEnableFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_COLOR_WRITE_ENABLE_FEATURES_EXT;
        deviceColorWriteEnableFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceColorWriteEnableFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceColorWriteEnableFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceColorWriteEnableFeaturesEXT[0].colorWriteEnable != deviceColorWriteEnableFeaturesEXT[1].colorWriteEnable)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceColorWriteEnableFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureCustomBorderColorFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceCustomBorderColorFeaturesEXT deviceCustomBorderColorFeaturesEXT[count];
    const bool                                   isCustomBorderColorFeaturesEXT = checkExtension(properties, "VK_EXT_custom_border_color");

    if (!isCustomBorderColorFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceCustomBorderColorFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceCustomBorderColorFeaturesEXT));
        deviceCustomBorderColorFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_CUSTOM_BORDER_COLOR_FEATURES_EXT;
        deviceCustomBorderColorFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceCustomBorderColorFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceCustomBorderColorFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceCustomBorderColorFeaturesEXT[0].customBorderColors != deviceCustomBorderColorFeaturesEXT[1].customBorderColors ||
        deviceCustomBorderColorFeaturesEXT[0].customBorderColorWithoutFormat != deviceCustomBorderColorFeaturesEXT[1].customBorderColorWithoutFormat)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceCustomBorderColorFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDepthClipEnableFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceDepthClipEnableFeaturesEXT deviceDepthClipEnableFeaturesEXT[count];
    const bool                                 isDepthClipEnableFeaturesEXT = checkExtension(properties, "VK_EXT_depth_clip_enable");

    if (!isDepthClipEnableFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceDepthClipEnableFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDepthClipEnableFeaturesEXT));
        deviceDepthClipEnableFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DEPTH_CLIP_ENABLE_FEATURES_EXT;
        deviceDepthClipEnableFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceDepthClipEnableFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceDepthClipEnableFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceDepthClipEnableFeaturesEXT[0].depthClipEnable != deviceDepthClipEnableFeaturesEXT[1].depthClipEnable)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceDepthClipEnableFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDescriptorIndexingFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceDescriptorIndexingFeatures deviceDescriptorIndexingFeatures[count];
    const bool                                 isDescriptorIndexingFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isDescriptorIndexingFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceDescriptorIndexingFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDescriptorIndexingFeatures));
        deviceDescriptorIndexingFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DESCRIPTOR_INDEXING_FEATURES;
        deviceDescriptorIndexingFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceDescriptorIndexingFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceDescriptorIndexingFeatures[0] << TestLog::EndMessage;

    if (
        deviceDescriptorIndexingFeatures[0].shaderInputAttachmentArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderInputAttachmentArrayDynamicIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderUniformTexelBufferArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformTexelBufferArrayDynamicIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderStorageTexelBufferArrayDynamicIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageTexelBufferArrayDynamicIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderUniformBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformBufferArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderSampledImageArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderSampledImageArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderStorageBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageBufferArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderStorageImageArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageImageArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderInputAttachmentArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderInputAttachmentArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderUniformTexelBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderUniformTexelBufferArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].shaderStorageTexelBufferArrayNonUniformIndexing != deviceDescriptorIndexingFeatures[1].shaderStorageTexelBufferArrayNonUniformIndexing ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingUniformBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingUniformBufferUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingSampledImageUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingSampledImageUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingStorageImageUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageImageUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingStorageBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageBufferUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingUniformTexelBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingUniformTexelBufferUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingStorageTexelBufferUpdateAfterBind != deviceDescriptorIndexingFeatures[1].descriptorBindingStorageTexelBufferUpdateAfterBind ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingUpdateUnusedWhilePending != deviceDescriptorIndexingFeatures[1].descriptorBindingUpdateUnusedWhilePending ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingPartiallyBound != deviceDescriptorIndexingFeatures[1].descriptorBindingPartiallyBound ||
        deviceDescriptorIndexingFeatures[0].descriptorBindingVariableDescriptorCount != deviceDescriptorIndexingFeatures[1].descriptorBindingVariableDescriptorCount ||
        deviceDescriptorIndexingFeatures[0].runtimeDescriptorArray != deviceDescriptorIndexingFeatures[1].runtimeDescriptorArray)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceDescriptorIndexingFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDynamicRenderingFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceDynamicRenderingFeatures deviceDynamicRenderingFeatures[count];
    const bool                               isDynamicRenderingFeatures = context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isDynamicRenderingFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceDynamicRenderingFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDynamicRenderingFeatures));
        deviceDynamicRenderingFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_FEATURES;
        deviceDynamicRenderingFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceDynamicRenderingFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceDynamicRenderingFeatures[0] << TestLog::EndMessage;

    if (
        deviceDynamicRenderingFeatures[0].dynamicRendering != deviceDynamicRenderingFeatures[1].dynamicRendering)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceDynamicRenderingFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureDynamicRenderingLocalReadFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceDynamicRenderingLocalReadFeatures deviceDynamicRenderingLocalReadFeatures[count];
    const bool                                        isDynamicRenderingLocalReadFeatures = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isDynamicRenderingLocalReadFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceDynamicRenderingLocalReadFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceDynamicRenderingLocalReadFeatures));
        deviceDynamicRenderingLocalReadFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_DYNAMIC_RENDERING_LOCAL_READ_FEATURES;
        deviceDynamicRenderingLocalReadFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceDynamicRenderingLocalReadFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceDynamicRenderingLocalReadFeatures[0] << TestLog::EndMessage;

    if (
        deviceDynamicRenderingLocalReadFeatures[0].dynamicRenderingLocalRead != deviceDynamicRenderingLocalReadFeatures[1].dynamicRenderingLocalRead)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceDynamicRenderingLocalReadFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureExtendedDynamicState2FeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceExtendedDynamicState2FeaturesEXT deviceExtendedDynamicState2FeaturesEXT[count];
    const bool                                       isExtendedDynamicState2FeaturesEXT = checkExtension(properties, "VK_EXT_extended_dynamic_state2");

    if (!isExtendedDynamicState2FeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceExtendedDynamicState2FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceExtendedDynamicState2FeaturesEXT));
        deviceExtendedDynamicState2FeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_2_FEATURES_EXT;
        deviceExtendedDynamicState2FeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceExtendedDynamicState2FeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceExtendedDynamicState2FeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2 != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2 ||
        deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2LogicOp != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2LogicOp ||
        deviceExtendedDynamicState2FeaturesEXT[0].extendedDynamicState2PatchControlPoints != deviceExtendedDynamicState2FeaturesEXT[1].extendedDynamicState2PatchControlPoints)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceExtendedDynamicState2FeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureExtendedDynamicStateFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceExtendedDynamicStateFeaturesEXT deviceExtendedDynamicStateFeaturesEXT[count];
    const bool                                      isExtendedDynamicStateFeaturesEXT = checkExtension(properties, "VK_EXT_extended_dynamic_state");

    if (!isExtendedDynamicStateFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceExtendedDynamicStateFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceExtendedDynamicStateFeaturesEXT));
        deviceExtendedDynamicStateFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_EXTENDED_DYNAMIC_STATE_FEATURES_EXT;
        deviceExtendedDynamicStateFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceExtendedDynamicStateFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceExtendedDynamicStateFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceExtendedDynamicStateFeaturesEXT[0].extendedDynamicState != deviceExtendedDynamicStateFeaturesEXT[1].extendedDynamicState)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceExtendedDynamicStateFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentShaderInterlockFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT deviceFragmentShaderInterlockFeaturesEXT[count];
    const bool                                         isFragmentShaderInterlockFeaturesEXT = checkExtension(properties, "VK_EXT_fragment_shader_interlock");

    if (!isFragmentShaderInterlockFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceFragmentShaderInterlockFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT));
        deviceFragmentShaderInterlockFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADER_INTERLOCK_FEATURES_EXT;
        deviceFragmentShaderInterlockFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceFragmentShaderInterlockFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceFragmentShaderInterlockFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderSampleInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderSampleInterlock ||
        deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderPixelInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderPixelInterlock ||
        deviceFragmentShaderInterlockFeaturesEXT[0].fragmentShaderShadingRateInterlock != deviceFragmentShaderInterlockFeaturesEXT[1].fragmentShaderShadingRateInterlock)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureFragmentShadingRateFeaturesKHR (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceFragmentShadingRateFeaturesKHR deviceFragmentShadingRateFeaturesKHR[count];
    const bool                                     isFragmentShadingRateFeaturesKHR = checkExtension(properties, "VK_KHR_fragment_shading_rate");

    if (!isFragmentShadingRateFeaturesKHR)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceFragmentShadingRateFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceFragmentShadingRateFeaturesKHR));
        deviceFragmentShadingRateFeaturesKHR[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FRAGMENT_SHADING_RATE_FEATURES_KHR;
        deviceFragmentShadingRateFeaturesKHR[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceFragmentShadingRateFeaturesKHR[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceFragmentShadingRateFeaturesKHR[0] << TestLog::EndMessage;

    if (
        deviceFragmentShadingRateFeaturesKHR[0].pipelineFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].pipelineFragmentShadingRate ||
        deviceFragmentShadingRateFeaturesKHR[0].primitiveFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].primitiveFragmentShadingRate ||
        deviceFragmentShadingRateFeaturesKHR[0].attachmentFragmentShadingRate != deviceFragmentShadingRateFeaturesKHR[1].attachmentFragmentShadingRate)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceFragmentShadingRateFeaturesKHR");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureGlobalPriorityQueryFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceGlobalPriorityQueryFeatures deviceGlobalPriorityQueryFeatures[count];
    const bool                                  isGlobalPriorityQueryFeatures = checkExtension(properties, "VK_KHR_global_priority") || context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isGlobalPriorityQueryFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceGlobalPriorityQueryFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceGlobalPriorityQueryFeatures));
        deviceGlobalPriorityQueryFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_GLOBAL_PRIORITY_QUERY_FEATURES;
        deviceGlobalPriorityQueryFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceGlobalPriorityQueryFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceGlobalPriorityQueryFeatures[0] << TestLog::EndMessage;

    if (
        deviceGlobalPriorityQueryFeatures[0].globalPriorityQuery != deviceGlobalPriorityQueryFeatures[1].globalPriorityQuery)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceGlobalPriorityQueryFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureHostImageCopyFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceHostImageCopyFeatures deviceHostImageCopyFeatures[count];
    const bool                            isHostImageCopyFeatures = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isHostImageCopyFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceHostImageCopyFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceHostImageCopyFeatures));
        deviceHostImageCopyFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_IMAGE_COPY_FEATURES;
        deviceHostImageCopyFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceHostImageCopyFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceHostImageCopyFeatures[0] << TestLog::EndMessage;

    if (
        deviceHostImageCopyFeatures[0].hostImageCopy != deviceHostImageCopyFeatures[1].hostImageCopy)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceHostImageCopyFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureHostQueryResetFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceHostQueryResetFeatures deviceHostQueryResetFeatures[count];
    const bool                             isHostQueryResetFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isHostQueryResetFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceHostQueryResetFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceHostQueryResetFeatures));
        deviceHostQueryResetFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_HOST_QUERY_RESET_FEATURES;
        deviceHostQueryResetFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceHostQueryResetFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceHostQueryResetFeatures[0] << TestLog::EndMessage;

    if (
        deviceHostQueryResetFeatures[0].hostQueryReset != deviceHostQueryResetFeatures[1].hostQueryReset)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceHostQueryResetFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureImageRobustnessFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceImageRobustnessFeatures deviceImageRobustnessFeatures[count];
    const bool                              isImageRobustnessFeatures = checkExtension(properties, "VK_EXT_image_robustness") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isImageRobustnessFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceImageRobustnessFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceImageRobustnessFeatures));
        deviceImageRobustnessFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGE_ROBUSTNESS_FEATURES;
        deviceImageRobustnessFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceImageRobustnessFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceImageRobustnessFeatures[0] << TestLog::EndMessage;

    if (
        deviceImageRobustnessFeatures[0].robustImageAccess != deviceImageRobustnessFeatures[1].robustImageAccess)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceImageRobustnessFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureImagelessFramebufferFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceImagelessFramebufferFeatures deviceImagelessFramebufferFeatures[count];
    const bool                                   isImagelessFramebufferFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isImagelessFramebufferFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceImagelessFramebufferFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceImagelessFramebufferFeatures));
        deviceImagelessFramebufferFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_IMAGELESS_FRAMEBUFFER_FEATURES;
        deviceImagelessFramebufferFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceImagelessFramebufferFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceImagelessFramebufferFeatures[0] << TestLog::EndMessage;

    if (
        deviceImagelessFramebufferFeatures[0].imagelessFramebuffer != deviceImagelessFramebufferFeatures[1].imagelessFramebuffer)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceImagelessFramebufferFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureIndexTypeUint8Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceIndexTypeUint8Features deviceIndexTypeUint8Features[count];
    const bool                             isIndexTypeUint8Features = checkExtension(properties, "VK_KHR_index_type_uint8") || checkExtension(properties, "VK_EXT_index_type_uint8") || context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isIndexTypeUint8Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceIndexTypeUint8Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceIndexTypeUint8Features));
        deviceIndexTypeUint8Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INDEX_TYPE_UINT8_FEATURES;
        deviceIndexTypeUint8Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceIndexTypeUint8Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceIndexTypeUint8Features[0] << TestLog::EndMessage;

    if (
        deviceIndexTypeUint8Features[0].indexTypeUint8 != deviceIndexTypeUint8Features[1].indexTypeUint8)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceIndexTypeUint8Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureInlineUniformBlockFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceInlineUniformBlockFeatures deviceInlineUniformBlockFeatures[count];
    const bool                                 isInlineUniformBlockFeatures = context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isInlineUniformBlockFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceInlineUniformBlockFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceInlineUniformBlockFeatures));
        deviceInlineUniformBlockFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_INLINE_UNIFORM_BLOCK_FEATURES;
        deviceInlineUniformBlockFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceInlineUniformBlockFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceInlineUniformBlockFeatures[0] << TestLog::EndMessage;

    if (
        deviceInlineUniformBlockFeatures[0].inlineUniformBlock != deviceInlineUniformBlockFeatures[1].inlineUniformBlock ||
        deviceInlineUniformBlockFeatures[0].descriptorBindingInlineUniformBlockUpdateAfterBind != deviceInlineUniformBlockFeatures[1].descriptorBindingInlineUniformBlockUpdateAfterBind)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceInlineUniformBlockFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureLineRasterizationFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceLineRasterizationFeatures deviceLineRasterizationFeatures[count];
    const bool                                isLineRasterizationFeatures = checkExtension(properties, "VK_KHR_line_rasterization") || checkExtension(properties, "VK_EXT_line_rasterization") || context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isLineRasterizationFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceLineRasterizationFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceLineRasterizationFeatures));
        deviceLineRasterizationFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_LINE_RASTERIZATION_FEATURES;
        deviceLineRasterizationFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceLineRasterizationFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceLineRasterizationFeatures[0] << TestLog::EndMessage;

    if (
        deviceLineRasterizationFeatures[0].rectangularLines != deviceLineRasterizationFeatures[1].rectangularLines ||
        deviceLineRasterizationFeatures[0].bresenhamLines != deviceLineRasterizationFeatures[1].bresenhamLines ||
        deviceLineRasterizationFeatures[0].smoothLines != deviceLineRasterizationFeatures[1].smoothLines ||
        deviceLineRasterizationFeatures[0].stippledRectangularLines != deviceLineRasterizationFeatures[1].stippledRectangularLines ||
        deviceLineRasterizationFeatures[0].stippledBresenhamLines != deviceLineRasterizationFeatures[1].stippledBresenhamLines ||
        deviceLineRasterizationFeatures[0].stippledSmoothLines != deviceLineRasterizationFeatures[1].stippledSmoothLines)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceLineRasterizationFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMaintenance4Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceMaintenance4Features deviceMaintenance4Features[count];
    const bool                           isMaintenance4Features = context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isMaintenance4Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceMaintenance4Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMaintenance4Features));
        deviceMaintenance4Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_4_FEATURES;
        deviceMaintenance4Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceMaintenance4Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceMaintenance4Features[0] << TestLog::EndMessage;

    if (
        deviceMaintenance4Features[0].maintenance4 != deviceMaintenance4Features[1].maintenance4)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceMaintenance4Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMaintenance5Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceMaintenance5Features deviceMaintenance5Features[count];
    const bool                           isMaintenance5Features = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isMaintenance5Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceMaintenance5Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMaintenance5Features));
        deviceMaintenance5Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_5_FEATURES;
        deviceMaintenance5Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceMaintenance5Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceMaintenance5Features[0] << TestLog::EndMessage;

    if (
        deviceMaintenance5Features[0].maintenance5 != deviceMaintenance5Features[1].maintenance5)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceMaintenance5Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMaintenance6Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceMaintenance6Features deviceMaintenance6Features[count];
    const bool                           isMaintenance6Features = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isMaintenance6Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceMaintenance6Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMaintenance6Features));
        deviceMaintenance6Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MAINTENANCE_6_FEATURES;
        deviceMaintenance6Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceMaintenance6Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceMaintenance6Features[0] << TestLog::EndMessage;

    if (
        deviceMaintenance6Features[0].maintenance6 != deviceMaintenance6Features[1].maintenance6)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceMaintenance6Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureMultiviewFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceMultiviewFeatures deviceMultiviewFeatures[count];
    const bool                        isMultiviewFeatures = context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isMultiviewFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceMultiviewFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceMultiviewFeatures));
        deviceMultiviewFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_MULTIVIEW_FEATURES;
        deviceMultiviewFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceMultiviewFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceMultiviewFeatures[0] << TestLog::EndMessage;

    if (
        deviceMultiviewFeatures[0].multiview != deviceMultiviewFeatures[1].multiview ||
        deviceMultiviewFeatures[0].multiviewGeometryShader != deviceMultiviewFeatures[1].multiviewGeometryShader ||
        deviceMultiviewFeatures[0].multiviewTessellationShader != deviceMultiviewFeatures[1].multiviewTessellationShader)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceMultiviewFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePerformanceQueryFeaturesKHR (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevicePerformanceQueryFeaturesKHR devicePerformanceQueryFeaturesKHR[count];
    const bool                                  isPerformanceQueryFeaturesKHR = checkExtension(properties, "VK_KHR_performance_query");

    if (!isPerformanceQueryFeaturesKHR)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&devicePerformanceQueryFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePerformanceQueryFeaturesKHR));
        devicePerformanceQueryFeaturesKHR[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PERFORMANCE_QUERY_FEATURES_KHR;
        devicePerformanceQueryFeaturesKHR[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &devicePerformanceQueryFeaturesKHR[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << devicePerformanceQueryFeaturesKHR[0] << TestLog::EndMessage;

    if (
        devicePerformanceQueryFeaturesKHR[0].performanceCounterQueryPools != devicePerformanceQueryFeaturesKHR[1].performanceCounterQueryPools ||
        devicePerformanceQueryFeaturesKHR[0].performanceCounterMultipleQueryPools != devicePerformanceQueryFeaturesKHR[1].performanceCounterMultipleQueryPools)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevicePerformanceQueryFeaturesKHR");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePipelineCreationCacheControlFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevicePipelineCreationCacheControlFeatures devicePipelineCreationCacheControlFeatures[count];
    const bool                                           isPipelineCreationCacheControlFeatures = context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isPipelineCreationCacheControlFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&devicePipelineCreationCacheControlFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePipelineCreationCacheControlFeatures));
        devicePipelineCreationCacheControlFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_CREATION_CACHE_CONTROL_FEATURES;
        devicePipelineCreationCacheControlFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &devicePipelineCreationCacheControlFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << devicePipelineCreationCacheControlFeatures[0] << TestLog::EndMessage;

    if (
        devicePipelineCreationCacheControlFeatures[0].pipelineCreationCacheControl != devicePipelineCreationCacheControlFeatures[1].pipelineCreationCacheControl)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevicePipelineCreationCacheControlFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePipelineProtectedAccessFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevicePipelineProtectedAccessFeatures devicePipelineProtectedAccessFeatures[count];
    const bool                                      isPipelineProtectedAccessFeatures = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isPipelineProtectedAccessFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&devicePipelineProtectedAccessFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePipelineProtectedAccessFeatures));
        devicePipelineProtectedAccessFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_PROTECTED_ACCESS_FEATURES;
        devicePipelineProtectedAccessFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &devicePipelineProtectedAccessFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << devicePipelineProtectedAccessFeatures[0] << TestLog::EndMessage;

    if (
        devicePipelineProtectedAccessFeatures[0].pipelineProtectedAccess != devicePipelineProtectedAccessFeatures[1].pipelineProtectedAccess)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevicePipelineProtectedAccessFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePipelineRobustnessFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevicePipelineRobustnessFeatures devicePipelineRobustnessFeatures[count];
    const bool                                 isPipelineRobustnessFeatures = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isPipelineRobustnessFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&devicePipelineRobustnessFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePipelineRobustnessFeatures));
        devicePipelineRobustnessFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PIPELINE_ROBUSTNESS_FEATURES;
        devicePipelineRobustnessFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &devicePipelineRobustnessFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << devicePipelineRobustnessFeatures[0] << TestLog::EndMessage;

    if (
        devicePipelineRobustnessFeatures[0].pipelineRobustness != devicePipelineRobustnessFeatures[1].pipelineRobustness)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevicePipelineRobustnessFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeaturePrivateDataFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDevicePrivateDataFeatures devicePrivateDataFeatures[count];
    const bool                          isPrivateDataFeatures = context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isPrivateDataFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&devicePrivateDataFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDevicePrivateDataFeatures));
        devicePrivateDataFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PRIVATE_DATA_FEATURES;
        devicePrivateDataFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &devicePrivateDataFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << devicePrivateDataFeatures[0] << TestLog::EndMessage;

    if (
        devicePrivateDataFeatures[0].privateData != devicePrivateDataFeatures[1].privateData)
    {
        TCU_FAIL("Mismatch between VkPhysicalDevicePrivateDataFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureProtectedMemoryFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceProtectedMemoryFeatures deviceProtectedMemoryFeatures[count];
    const bool                              isProtectedMemoryFeatures = context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isProtectedMemoryFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceProtectedMemoryFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceProtectedMemoryFeatures));
        deviceProtectedMemoryFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_PROTECTED_MEMORY_FEATURES;
        deviceProtectedMemoryFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceProtectedMemoryFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceProtectedMemoryFeatures[0] << TestLog::EndMessage;

    if (
        deviceProtectedMemoryFeatures[0].protectedMemory != deviceProtectedMemoryFeatures[1].protectedMemory)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceProtectedMemoryFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureRobustness2FeaturesKHR (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceRobustness2FeaturesKHR deviceRobustness2FeaturesKHR[count];
    const bool                             isRobustness2FeaturesKHR = checkExtension(properties, "VK_EXT_robustness2");

    if (!isRobustness2FeaturesKHR)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceRobustness2FeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceRobustness2FeaturesKHR));
        deviceRobustness2FeaturesKHR[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ROBUSTNESS_2_FEATURES_KHR;
        deviceRobustness2FeaturesKHR[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceRobustness2FeaturesKHR[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceRobustness2FeaturesKHR[0] << TestLog::EndMessage;

    if (
        deviceRobustness2FeaturesKHR[0].robustBufferAccess2 != deviceRobustness2FeaturesKHR[1].robustBufferAccess2 ||
        deviceRobustness2FeaturesKHR[0].robustImageAccess2 != deviceRobustness2FeaturesKHR[1].robustImageAccess2 ||
        deviceRobustness2FeaturesKHR[0].nullDescriptor != deviceRobustness2FeaturesKHR[1].nullDescriptor)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceRobustness2FeaturesKHR");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSamplerYcbcrConversionFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceSamplerYcbcrConversionFeatures deviceSamplerYcbcrConversionFeatures[count];
    const bool                                     isSamplerYcbcrConversionFeatures = context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isSamplerYcbcrConversionFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceSamplerYcbcrConversionFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSamplerYcbcrConversionFeatures));
        deviceSamplerYcbcrConversionFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SAMPLER_YCBCR_CONVERSION_FEATURES;
        deviceSamplerYcbcrConversionFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceSamplerYcbcrConversionFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceSamplerYcbcrConversionFeatures[0] << TestLog::EndMessage;

    if (
        deviceSamplerYcbcrConversionFeatures[0].samplerYcbcrConversion != deviceSamplerYcbcrConversionFeatures[1].samplerYcbcrConversion)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceSamplerYcbcrConversionFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureScalarBlockLayoutFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceScalarBlockLayoutFeatures deviceScalarBlockLayoutFeatures[count];
    const bool                                isScalarBlockLayoutFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isScalarBlockLayoutFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceScalarBlockLayoutFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceScalarBlockLayoutFeatures));
        deviceScalarBlockLayoutFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SCALAR_BLOCK_LAYOUT_FEATURES;
        deviceScalarBlockLayoutFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceScalarBlockLayoutFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceScalarBlockLayoutFeatures[0] << TestLog::EndMessage;

    if (
        deviceScalarBlockLayoutFeatures[0].scalarBlockLayout != deviceScalarBlockLayoutFeatures[1].scalarBlockLayout)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceScalarBlockLayoutFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSeparateDepthStencilLayoutsFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures deviceSeparateDepthStencilLayoutsFeatures[count];
    const bool                                          isSeparateDepthStencilLayoutsFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isSeparateDepthStencilLayoutsFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceSeparateDepthStencilLayoutsFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures));
        deviceSeparateDepthStencilLayoutsFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SEPARATE_DEPTH_STENCIL_LAYOUTS_FEATURES;
        deviceSeparateDepthStencilLayoutsFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceSeparateDepthStencilLayoutsFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceSeparateDepthStencilLayoutsFeatures[0] << TestLog::EndMessage;

    if (
        deviceSeparateDepthStencilLayoutsFeatures[0].separateDepthStencilLayouts != deviceSeparateDepthStencilLayoutsFeatures[1].separateDepthStencilLayouts)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicFloatFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderAtomicFloatFeaturesEXT deviceShaderAtomicFloatFeaturesEXT[count];
    const bool                                   isShaderAtomicFloatFeaturesEXT = checkExtension(properties, "VK_EXT_shader_atomic_float");

    if (!isShaderAtomicFloatFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderAtomicFloatFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicFloatFeaturesEXT));
        deviceShaderAtomicFloatFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_FLOAT_FEATURES_EXT;
        deviceShaderAtomicFloatFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderAtomicFloatFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderAtomicFloatFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat32Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat32AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat64Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat64Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderBufferFloat64AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderBufferFloat64AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat32Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat32AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat64Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat64Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderSharedFloat64AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderSharedFloat64AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderImageFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].shaderImageFloat32Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].shaderImageFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].shaderImageFloat32AtomicAdd ||
        deviceShaderAtomicFloatFeaturesEXT[0].sparseImageFloat32Atomics != deviceShaderAtomicFloatFeaturesEXT[1].sparseImageFloat32Atomics ||
        deviceShaderAtomicFloatFeaturesEXT[0].sparseImageFloat32AtomicAdd != deviceShaderAtomicFloatFeaturesEXT[1].sparseImageFloat32AtomicAdd)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicFloatFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderAtomicInt64Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderAtomicInt64Features deviceShaderAtomicInt64Features[count];
    const bool                                isShaderAtomicInt64Features = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isShaderAtomicInt64Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderAtomicInt64Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderAtomicInt64Features));
        deviceShaderAtomicInt64Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_ATOMIC_INT64_FEATURES;
        deviceShaderAtomicInt64Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderAtomicInt64Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderAtomicInt64Features[0] << TestLog::EndMessage;

    if (
        deviceShaderAtomicInt64Features[0].shaderBufferInt64Atomics != deviceShaderAtomicInt64Features[1].shaderBufferInt64Atomics ||
        deviceShaderAtomicInt64Features[0].shaderSharedInt64Atomics != deviceShaderAtomicInt64Features[1].shaderSharedInt64Atomics)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderAtomicInt64Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderClockFeaturesKHR (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderClockFeaturesKHR deviceShaderClockFeaturesKHR[count];
    const bool                             isShaderClockFeaturesKHR = checkExtension(properties, "VK_KHR_shader_clock");

    if (!isShaderClockFeaturesKHR)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderClockFeaturesKHR[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderClockFeaturesKHR));
        deviceShaderClockFeaturesKHR[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_CLOCK_FEATURES_KHR;
        deviceShaderClockFeaturesKHR[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderClockFeaturesKHR[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderClockFeaturesKHR[0] << TestLog::EndMessage;

    if (
        deviceShaderClockFeaturesKHR[0].shaderSubgroupClock != deviceShaderClockFeaturesKHR[1].shaderSubgroupClock ||
        deviceShaderClockFeaturesKHR[0].shaderDeviceClock != deviceShaderClockFeaturesKHR[1].shaderDeviceClock)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderClockFeaturesKHR");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderDemoteToHelperInvocationFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures deviceShaderDemoteToHelperInvocationFeatures[count];
    const bool                                             isShaderDemoteToHelperInvocationFeatures = checkExtension(properties, "VK_EXT_shader_demote_to_helper_invocation") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isShaderDemoteToHelperInvocationFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderDemoteToHelperInvocationFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures));
        deviceShaderDemoteToHelperInvocationFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DEMOTE_TO_HELPER_INVOCATION_FEATURES;
        deviceShaderDemoteToHelperInvocationFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderDemoteToHelperInvocationFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderDemoteToHelperInvocationFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderDemoteToHelperInvocationFeatures[0].shaderDemoteToHelperInvocation != deviceShaderDemoteToHelperInvocationFeatures[1].shaderDemoteToHelperInvocation)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderDrawParametersFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderDrawParametersFeatures deviceShaderDrawParametersFeatures[count];
    const bool                                   isShaderDrawParametersFeatures = context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isShaderDrawParametersFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderDrawParametersFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderDrawParametersFeatures));
        deviceShaderDrawParametersFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_DRAW_PARAMETERS_FEATURES;
        deviceShaderDrawParametersFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderDrawParametersFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderDrawParametersFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderDrawParametersFeatures[0].shaderDrawParameters != deviceShaderDrawParametersFeatures[1].shaderDrawParameters)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderDrawParametersFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderExpectAssumeFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderExpectAssumeFeatures deviceShaderExpectAssumeFeatures[count];
    const bool                                 isShaderExpectAssumeFeatures = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isShaderExpectAssumeFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderExpectAssumeFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderExpectAssumeFeatures));
        deviceShaderExpectAssumeFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_EXPECT_ASSUME_FEATURES;
        deviceShaderExpectAssumeFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderExpectAssumeFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderExpectAssumeFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderExpectAssumeFeatures[0].shaderExpectAssume != deviceShaderExpectAssumeFeatures[1].shaderExpectAssume)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderExpectAssumeFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderFloat16Int8Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderFloat16Int8Features deviceShaderFloat16Int8Features[count];
    const bool                                isShaderFloat16Int8Features = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isShaderFloat16Int8Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderFloat16Int8Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderFloat16Int8Features));
        deviceShaderFloat16Int8Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT16_INT8_FEATURES;
        deviceShaderFloat16Int8Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderFloat16Int8Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderFloat16Int8Features[0] << TestLog::EndMessage;

    if (
        deviceShaderFloat16Int8Features[0].shaderFloat16 != deviceShaderFloat16Int8Features[1].shaderFloat16 ||
        deviceShaderFloat16Int8Features[0].shaderInt8 != deviceShaderFloat16Int8Features[1].shaderInt8)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderFloat16Int8Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderFloatControls2Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderFloatControls2Features deviceShaderFloatControls2Features[count];
    const bool                                   isShaderFloatControls2Features = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isShaderFloatControls2Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderFloatControls2Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderFloatControls2Features));
        deviceShaderFloatControls2Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_FLOAT_CONTROLS_2_FEATURES;
        deviceShaderFloatControls2Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderFloatControls2Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderFloatControls2Features[0] << TestLog::EndMessage;

    if (
        deviceShaderFloatControls2Features[0].shaderFloatControls2 != deviceShaderFloatControls2Features[1].shaderFloatControls2)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderFloatControls2Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderImageAtomicInt64FeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT deviceShaderImageAtomicInt64FeaturesEXT[count];
    const bool                                        isShaderImageAtomicInt64FeaturesEXT = checkExtension(properties, "VK_EXT_shader_image_atomic_int64");

    if (!isShaderImageAtomicInt64FeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderImageAtomicInt64FeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT));
        deviceShaderImageAtomicInt64FeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_IMAGE_ATOMIC_INT64_FEATURES_EXT;
        deviceShaderImageAtomicInt64FeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderImageAtomicInt64FeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderImageAtomicInt64FeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceShaderImageAtomicInt64FeaturesEXT[0].shaderImageInt64Atomics != deviceShaderImageAtomicInt64FeaturesEXT[1].shaderImageInt64Atomics ||
        deviceShaderImageAtomicInt64FeaturesEXT[0].sparseImageInt64Atomics != deviceShaderImageAtomicInt64FeaturesEXT[1].sparseImageInt64Atomics)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderIntegerDotProductFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderIntegerDotProductFeatures deviceShaderIntegerDotProductFeatures[count];
    const bool                                      isShaderIntegerDotProductFeatures = context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isShaderIntegerDotProductFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderIntegerDotProductFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderIntegerDotProductFeatures));
        deviceShaderIntegerDotProductFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_INTEGER_DOT_PRODUCT_FEATURES;
        deviceShaderIntegerDotProductFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderIntegerDotProductFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderIntegerDotProductFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderIntegerDotProductFeatures[0].shaderIntegerDotProduct != deviceShaderIntegerDotProductFeatures[1].shaderIntegerDotProduct)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderIntegerDotProductFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderSubgroupExtendedTypesFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures deviceShaderSubgroupExtendedTypesFeatures[count];
    const bool                                          isShaderSubgroupExtendedTypesFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isShaderSubgroupExtendedTypesFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderSubgroupExtendedTypesFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures));
        deviceShaderSubgroupExtendedTypesFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_EXTENDED_TYPES_FEATURES;
        deviceShaderSubgroupExtendedTypesFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderSubgroupExtendedTypesFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderSubgroupExtendedTypesFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderSubgroupExtendedTypesFeatures[0].shaderSubgroupExtendedTypes != deviceShaderSubgroupExtendedTypesFeatures[1].shaderSubgroupExtendedTypes)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderSubgroupRotateFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderSubgroupRotateFeatures deviceShaderSubgroupRotateFeatures[count];
    const bool                                   isShaderSubgroupRotateFeatures = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isShaderSubgroupRotateFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderSubgroupRotateFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderSubgroupRotateFeatures));
        deviceShaderSubgroupRotateFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_SUBGROUP_ROTATE_FEATURES;
        deviceShaderSubgroupRotateFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderSubgroupRotateFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderSubgroupRotateFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderSubgroupRotateFeatures[0].shaderSubgroupRotate != deviceShaderSubgroupRotateFeatures[1].shaderSubgroupRotate ||
        deviceShaderSubgroupRotateFeatures[0].shaderSubgroupRotateClustered != deviceShaderSubgroupRotateFeatures[1].shaderSubgroupRotateClustered)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderSubgroupRotateFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureShaderTerminateInvocationFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceShaderTerminateInvocationFeatures deviceShaderTerminateInvocationFeatures[count];
    const bool                                        isShaderTerminateInvocationFeatures = checkExtension(properties, "VK_KHR_shader_terminate_invocation") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isShaderTerminateInvocationFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceShaderTerminateInvocationFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceShaderTerminateInvocationFeatures));
        deviceShaderTerminateInvocationFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SHADER_TERMINATE_INVOCATION_FEATURES;
        deviceShaderTerminateInvocationFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceShaderTerminateInvocationFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceShaderTerminateInvocationFeatures[0] << TestLog::EndMessage;

    if (
        deviceShaderTerminateInvocationFeatures[0].shaderTerminateInvocation != deviceShaderTerminateInvocationFeatures[1].shaderTerminateInvocation)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceShaderTerminateInvocationFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSubgroupSizeControlFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceSubgroupSizeControlFeatures deviceSubgroupSizeControlFeatures[count];
    const bool                                  isSubgroupSizeControlFeatures = checkExtension(properties, "VK_EXT_subgroup_size_control") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isSubgroupSizeControlFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceSubgroupSizeControlFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSubgroupSizeControlFeatures));
        deviceSubgroupSizeControlFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SUBGROUP_SIZE_CONTROL_FEATURES;
        deviceSubgroupSizeControlFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceSubgroupSizeControlFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceSubgroupSizeControlFeatures[0] << TestLog::EndMessage;

    if (
        deviceSubgroupSizeControlFeatures[0].subgroupSizeControl != deviceSubgroupSizeControlFeatures[1].subgroupSizeControl ||
        deviceSubgroupSizeControlFeatures[0].computeFullSubgroups != deviceSubgroupSizeControlFeatures[1].computeFullSubgroups)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceSubgroupSizeControlFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureSynchronization2Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceSynchronization2Features deviceSynchronization2Features[count];
    const bool                               isSynchronization2Features = checkExtension(properties, "VK_KHR_synchronization2") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isSynchronization2Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceSynchronization2Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceSynchronization2Features));
        deviceSynchronization2Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_SYNCHRONIZATION_2_FEATURES;
        deviceSynchronization2Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceSynchronization2Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceSynchronization2Features[0] << TestLog::EndMessage;

    if (
        deviceSynchronization2Features[0].synchronization2 != deviceSynchronization2Features[1].synchronization2)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceSynchronization2Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTexelBufferAlignmentFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT deviceTexelBufferAlignmentFeaturesEXT[count];
    const bool                                      isTexelBufferAlignmentFeaturesEXT = checkExtension(properties, "VK_EXT_texel_buffer_alignment");

    if (!isTexelBufferAlignmentFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceTexelBufferAlignmentFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT));
        deviceTexelBufferAlignmentFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXEL_BUFFER_ALIGNMENT_FEATURES_EXT;
        deviceTexelBufferAlignmentFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceTexelBufferAlignmentFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceTexelBufferAlignmentFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceTexelBufferAlignmentFeaturesEXT[0].texelBufferAlignment != deviceTexelBufferAlignmentFeaturesEXT[1].texelBufferAlignment)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTextureCompressionASTCHDRFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceTextureCompressionASTCHDRFeatures deviceTextureCompressionASTCHDRFeatures[count];
    const bool                                        isTextureCompressionASTCHDRFeatures = checkExtension(properties, "VK_EXT_texture_compression_astc_hdr") || context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isTextureCompressionASTCHDRFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceTextureCompressionASTCHDRFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTextureCompressionASTCHDRFeatures));
        deviceTextureCompressionASTCHDRFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TEXTURE_COMPRESSION_ASTC_HDR_FEATURES;
        deviceTextureCompressionASTCHDRFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceTextureCompressionASTCHDRFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceTextureCompressionASTCHDRFeatures[0] << TestLog::EndMessage;

    if (
        deviceTextureCompressionASTCHDRFeatures[0].textureCompressionASTC_HDR != deviceTextureCompressionASTCHDRFeatures[1].textureCompressionASTC_HDR)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceTextureCompressionASTCHDRFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureTimelineSemaphoreFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceTimelineSemaphoreFeatures deviceTimelineSemaphoreFeatures[count];
    const bool                                isTimelineSemaphoreFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isTimelineSemaphoreFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceTimelineSemaphoreFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceTimelineSemaphoreFeatures));
        deviceTimelineSemaphoreFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_TIMELINE_SEMAPHORE_FEATURES;
        deviceTimelineSemaphoreFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceTimelineSemaphoreFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceTimelineSemaphoreFeatures[0] << TestLog::EndMessage;

    if (
        deviceTimelineSemaphoreFeatures[0].timelineSemaphore != deviceTimelineSemaphoreFeatures[1].timelineSemaphore)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceTimelineSemaphoreFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureUniformBufferStandardLayoutFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceUniformBufferStandardLayoutFeatures deviceUniformBufferStandardLayoutFeatures[count];
    const bool                                          isUniformBufferStandardLayoutFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isUniformBufferStandardLayoutFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceUniformBufferStandardLayoutFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceUniformBufferStandardLayoutFeatures));
        deviceUniformBufferStandardLayoutFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_UNIFORM_BUFFER_STANDARD_LAYOUT_FEATURES;
        deviceUniformBufferStandardLayoutFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceUniformBufferStandardLayoutFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceUniformBufferStandardLayoutFeatures[0] << TestLog::EndMessage;

    if (
        deviceUniformBufferStandardLayoutFeatures[0].uniformBufferStandardLayout != deviceUniformBufferStandardLayoutFeatures[1].uniformBufferStandardLayout)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceUniformBufferStandardLayoutFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVariablePointersFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVariablePointersFeatures deviceVariablePointersFeatures[count];
    const bool                               isVariablePointersFeatures = context.contextSupports(vk::ApiVersion(1, 1, 1, 0));

    if (!isVariablePointersFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVariablePointersFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVariablePointersFeatures));
        deviceVariablePointersFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VARIABLE_POINTERS_FEATURES;
        deviceVariablePointersFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVariablePointersFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVariablePointersFeatures[0] << TestLog::EndMessage;

    if (
        deviceVariablePointersFeatures[0].variablePointersStorageBuffer != deviceVariablePointersFeatures[1].variablePointersStorageBuffer ||
        deviceVariablePointersFeatures[0].variablePointers != deviceVariablePointersFeatures[1].variablePointers)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVariablePointersFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVertexAttributeDivisorFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVertexAttributeDivisorFeatures deviceVertexAttributeDivisorFeatures[count];
    const bool                                     isVertexAttributeDivisorFeatures = checkExtension(properties, "VK_KHR_vertex_attribute_divisor") || context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isVertexAttributeDivisorFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVertexAttributeDivisorFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVertexAttributeDivisorFeatures));
        deviceVertexAttributeDivisorFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_ATTRIBUTE_DIVISOR_FEATURES;
        deviceVertexAttributeDivisorFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVertexAttributeDivisorFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVertexAttributeDivisorFeatures[0] << TestLog::EndMessage;

    if (
        deviceVertexAttributeDivisorFeatures[0].vertexAttributeInstanceRateDivisor != deviceVertexAttributeDivisorFeatures[1].vertexAttributeInstanceRateDivisor ||
        deviceVertexAttributeDivisorFeatures[0].vertexAttributeInstanceRateZeroDivisor != deviceVertexAttributeDivisorFeatures[1].vertexAttributeInstanceRateZeroDivisor)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVertexAttributeDivisorFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVertexInputDynamicStateFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT deviceVertexInputDynamicStateFeaturesEXT[count];
    const bool                                         isVertexInputDynamicStateFeaturesEXT = checkExtension(properties, "VK_EXT_vertex_input_dynamic_state");

    if (!isVertexInputDynamicStateFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVertexInputDynamicStateFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT));
        deviceVertexInputDynamicStateFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VERTEX_INPUT_DYNAMIC_STATE_FEATURES_EXT;
        deviceVertexInputDynamicStateFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVertexInputDynamicStateFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVertexInputDynamicStateFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceVertexInputDynamicStateFeaturesEXT[0].vertexInputDynamicState != deviceVertexInputDynamicStateFeaturesEXT[1].vertexInputDynamicState)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkan11Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkan11Features deviceVulkan11Features[count];
    const bool                       isVulkan11Features = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isVulkan11Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkan11Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkan11Features));
        deviceVulkan11Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_1_FEATURES;
        deviceVulkan11Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkan11Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkan11Features[0] << TestLog::EndMessage;

    if (
        deviceVulkan11Features[0].storageBuffer16BitAccess != deviceVulkan11Features[1].storageBuffer16BitAccess ||
        deviceVulkan11Features[0].uniformAndStorageBuffer16BitAccess != deviceVulkan11Features[1].uniformAndStorageBuffer16BitAccess ||
        deviceVulkan11Features[0].storagePushConstant16 != deviceVulkan11Features[1].storagePushConstant16 ||
        deviceVulkan11Features[0].storageInputOutput16 != deviceVulkan11Features[1].storageInputOutput16 ||
        deviceVulkan11Features[0].multiview != deviceVulkan11Features[1].multiview ||
        deviceVulkan11Features[0].multiviewGeometryShader != deviceVulkan11Features[1].multiviewGeometryShader ||
        deviceVulkan11Features[0].multiviewTessellationShader != deviceVulkan11Features[1].multiviewTessellationShader ||
        deviceVulkan11Features[0].variablePointersStorageBuffer != deviceVulkan11Features[1].variablePointersStorageBuffer ||
        deviceVulkan11Features[0].variablePointers != deviceVulkan11Features[1].variablePointers ||
        deviceVulkan11Features[0].protectedMemory != deviceVulkan11Features[1].protectedMemory ||
        deviceVulkan11Features[0].samplerYcbcrConversion != deviceVulkan11Features[1].samplerYcbcrConversion ||
        deviceVulkan11Features[0].shaderDrawParameters != deviceVulkan11Features[1].shaderDrawParameters)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkan11Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkan12Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkan12Features deviceVulkan12Features[count];
    const bool                       isVulkan12Features = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isVulkan12Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkan12Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkan12Features));
        deviceVulkan12Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_2_FEATURES;
        deviceVulkan12Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkan12Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkan12Features[0] << TestLog::EndMessage;

    if (
        deviceVulkan12Features[0].samplerMirrorClampToEdge != deviceVulkan12Features[1].samplerMirrorClampToEdge ||
        deviceVulkan12Features[0].drawIndirectCount != deviceVulkan12Features[1].drawIndirectCount ||
        deviceVulkan12Features[0].storageBuffer8BitAccess != deviceVulkan12Features[1].storageBuffer8BitAccess ||
        deviceVulkan12Features[0].uniformAndStorageBuffer8BitAccess != deviceVulkan12Features[1].uniformAndStorageBuffer8BitAccess ||
        deviceVulkan12Features[0].storagePushConstant8 != deviceVulkan12Features[1].storagePushConstant8 ||
        deviceVulkan12Features[0].shaderBufferInt64Atomics != deviceVulkan12Features[1].shaderBufferInt64Atomics ||
        deviceVulkan12Features[0].shaderSharedInt64Atomics != deviceVulkan12Features[1].shaderSharedInt64Atomics ||
        deviceVulkan12Features[0].shaderFloat16 != deviceVulkan12Features[1].shaderFloat16 ||
        deviceVulkan12Features[0].shaderInt8 != deviceVulkan12Features[1].shaderInt8 ||
        deviceVulkan12Features[0].descriptorIndexing != deviceVulkan12Features[1].descriptorIndexing ||
        deviceVulkan12Features[0].shaderInputAttachmentArrayDynamicIndexing != deviceVulkan12Features[1].shaderInputAttachmentArrayDynamicIndexing ||
        deviceVulkan12Features[0].shaderUniformTexelBufferArrayDynamicIndexing != deviceVulkan12Features[1].shaderUniformTexelBufferArrayDynamicIndexing ||
        deviceVulkan12Features[0].shaderStorageTexelBufferArrayDynamicIndexing != deviceVulkan12Features[1].shaderStorageTexelBufferArrayDynamicIndexing ||
        deviceVulkan12Features[0].shaderUniformBufferArrayNonUniformIndexing != deviceVulkan12Features[1].shaderUniformBufferArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderSampledImageArrayNonUniformIndexing != deviceVulkan12Features[1].shaderSampledImageArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderStorageBufferArrayNonUniformIndexing != deviceVulkan12Features[1].shaderStorageBufferArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderStorageImageArrayNonUniformIndexing != deviceVulkan12Features[1].shaderStorageImageArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderInputAttachmentArrayNonUniformIndexing != deviceVulkan12Features[1].shaderInputAttachmentArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderUniformTexelBufferArrayNonUniformIndexing != deviceVulkan12Features[1].shaderUniformTexelBufferArrayNonUniformIndexing ||
        deviceVulkan12Features[0].shaderStorageTexelBufferArrayNonUniformIndexing != deviceVulkan12Features[1].shaderStorageTexelBufferArrayNonUniformIndexing ||
        deviceVulkan12Features[0].descriptorBindingUniformBufferUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingUniformBufferUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingSampledImageUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingSampledImageUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingStorageImageUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingStorageImageUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingStorageBufferUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingStorageBufferUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingUniformTexelBufferUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingUniformTexelBufferUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingStorageTexelBufferUpdateAfterBind != deviceVulkan12Features[1].descriptorBindingStorageTexelBufferUpdateAfterBind ||
        deviceVulkan12Features[0].descriptorBindingUpdateUnusedWhilePending != deviceVulkan12Features[1].descriptorBindingUpdateUnusedWhilePending ||
        deviceVulkan12Features[0].descriptorBindingPartiallyBound != deviceVulkan12Features[1].descriptorBindingPartiallyBound ||
        deviceVulkan12Features[0].descriptorBindingVariableDescriptorCount != deviceVulkan12Features[1].descriptorBindingVariableDescriptorCount ||
        deviceVulkan12Features[0].runtimeDescriptorArray != deviceVulkan12Features[1].runtimeDescriptorArray ||
        deviceVulkan12Features[0].samplerFilterMinmax != deviceVulkan12Features[1].samplerFilterMinmax ||
        deviceVulkan12Features[0].scalarBlockLayout != deviceVulkan12Features[1].scalarBlockLayout ||
        deviceVulkan12Features[0].imagelessFramebuffer != deviceVulkan12Features[1].imagelessFramebuffer ||
        deviceVulkan12Features[0].uniformBufferStandardLayout != deviceVulkan12Features[1].uniformBufferStandardLayout ||
        deviceVulkan12Features[0].shaderSubgroupExtendedTypes != deviceVulkan12Features[1].shaderSubgroupExtendedTypes ||
        deviceVulkan12Features[0].separateDepthStencilLayouts != deviceVulkan12Features[1].separateDepthStencilLayouts ||
        deviceVulkan12Features[0].hostQueryReset != deviceVulkan12Features[1].hostQueryReset ||
        deviceVulkan12Features[0].timelineSemaphore != deviceVulkan12Features[1].timelineSemaphore ||
        deviceVulkan12Features[0].bufferDeviceAddress != deviceVulkan12Features[1].bufferDeviceAddress ||
        deviceVulkan12Features[0].bufferDeviceAddressCaptureReplay != deviceVulkan12Features[1].bufferDeviceAddressCaptureReplay ||
        deviceVulkan12Features[0].bufferDeviceAddressMultiDevice != deviceVulkan12Features[1].bufferDeviceAddressMultiDevice ||
        deviceVulkan12Features[0].vulkanMemoryModel != deviceVulkan12Features[1].vulkanMemoryModel ||
        deviceVulkan12Features[0].vulkanMemoryModelDeviceScope != deviceVulkan12Features[1].vulkanMemoryModelDeviceScope ||
        deviceVulkan12Features[0].vulkanMemoryModelAvailabilityVisibilityChains != deviceVulkan12Features[1].vulkanMemoryModelAvailabilityVisibilityChains ||
        deviceVulkan12Features[0].shaderOutputViewportIndex != deviceVulkan12Features[1].shaderOutputViewportIndex ||
        deviceVulkan12Features[0].shaderOutputLayer != deviceVulkan12Features[1].shaderOutputLayer ||
        deviceVulkan12Features[0].subgroupBroadcastDynamicId != deviceVulkan12Features[1].subgroupBroadcastDynamicId)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkan12Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkan13Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkan13Features deviceVulkan13Features[count];
    const bool                       isVulkan13Features = context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isVulkan13Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkan13Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkan13Features));
        deviceVulkan13Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_3_FEATURES;
        deviceVulkan13Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkan13Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkan13Features[0] << TestLog::EndMessage;

    if (
        deviceVulkan13Features[0].robustImageAccess != deviceVulkan13Features[1].robustImageAccess ||
        deviceVulkan13Features[0].inlineUniformBlock != deviceVulkan13Features[1].inlineUniformBlock ||
        deviceVulkan13Features[0].descriptorBindingInlineUniformBlockUpdateAfterBind != deviceVulkan13Features[1].descriptorBindingInlineUniformBlockUpdateAfterBind ||
        deviceVulkan13Features[0].pipelineCreationCacheControl != deviceVulkan13Features[1].pipelineCreationCacheControl ||
        deviceVulkan13Features[0].privateData != deviceVulkan13Features[1].privateData ||
        deviceVulkan13Features[0].shaderDemoteToHelperInvocation != deviceVulkan13Features[1].shaderDemoteToHelperInvocation ||
        deviceVulkan13Features[0].shaderTerminateInvocation != deviceVulkan13Features[1].shaderTerminateInvocation ||
        deviceVulkan13Features[0].subgroupSizeControl != deviceVulkan13Features[1].subgroupSizeControl ||
        deviceVulkan13Features[0].computeFullSubgroups != deviceVulkan13Features[1].computeFullSubgroups ||
        deviceVulkan13Features[0].synchronization2 != deviceVulkan13Features[1].synchronization2 ||
        deviceVulkan13Features[0].textureCompressionASTC_HDR != deviceVulkan13Features[1].textureCompressionASTC_HDR ||
        deviceVulkan13Features[0].shaderZeroInitializeWorkgroupMemory != deviceVulkan13Features[1].shaderZeroInitializeWorkgroupMemory ||
        deviceVulkan13Features[0].dynamicRendering != deviceVulkan13Features[1].dynamicRendering ||
        deviceVulkan13Features[0].shaderIntegerDotProduct != deviceVulkan13Features[1].shaderIntegerDotProduct ||
        deviceVulkan13Features[0].maintenance4 != deviceVulkan13Features[1].maintenance4)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkan13Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkan14Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkan14Features deviceVulkan14Features[count];
    const bool                       isVulkan14Features = context.contextSupports(vk::ApiVersion(1, 1, 4, 0));

    if (!isVulkan14Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkan14Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkan14Features));
        deviceVulkan14Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_1_4_FEATURES;
        deviceVulkan14Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkan14Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkan14Features[0] << TestLog::EndMessage;

    if (
        deviceVulkan14Features[0].globalPriorityQuery != deviceVulkan14Features[1].globalPriorityQuery ||
        deviceVulkan14Features[0].shaderSubgroupRotate != deviceVulkan14Features[1].shaderSubgroupRotate ||
        deviceVulkan14Features[0].shaderSubgroupRotateClustered != deviceVulkan14Features[1].shaderSubgroupRotateClustered ||
        deviceVulkan14Features[0].shaderFloatControls2 != deviceVulkan14Features[1].shaderFloatControls2 ||
        deviceVulkan14Features[0].shaderExpectAssume != deviceVulkan14Features[1].shaderExpectAssume ||
        deviceVulkan14Features[0].rectangularLines != deviceVulkan14Features[1].rectangularLines ||
        deviceVulkan14Features[0].bresenhamLines != deviceVulkan14Features[1].bresenhamLines ||
        deviceVulkan14Features[0].smoothLines != deviceVulkan14Features[1].smoothLines ||
        deviceVulkan14Features[0].stippledRectangularLines != deviceVulkan14Features[1].stippledRectangularLines ||
        deviceVulkan14Features[0].stippledBresenhamLines != deviceVulkan14Features[1].stippledBresenhamLines ||
        deviceVulkan14Features[0].stippledSmoothLines != deviceVulkan14Features[1].stippledSmoothLines ||
        deviceVulkan14Features[0].vertexAttributeInstanceRateDivisor != deviceVulkan14Features[1].vertexAttributeInstanceRateDivisor ||
        deviceVulkan14Features[0].vertexAttributeInstanceRateZeroDivisor != deviceVulkan14Features[1].vertexAttributeInstanceRateZeroDivisor ||
        deviceVulkan14Features[0].indexTypeUint8 != deviceVulkan14Features[1].indexTypeUint8 ||
        deviceVulkan14Features[0].dynamicRenderingLocalRead != deviceVulkan14Features[1].dynamicRenderingLocalRead ||
        deviceVulkan14Features[0].maintenance5 != deviceVulkan14Features[1].maintenance5 ||
        deviceVulkan14Features[0].maintenance6 != deviceVulkan14Features[1].maintenance6 ||
        deviceVulkan14Features[0].pipelineProtectedAccess != deviceVulkan14Features[1].pipelineProtectedAccess ||
        deviceVulkan14Features[0].pipelineRobustness != deviceVulkan14Features[1].pipelineRobustness ||
        deviceVulkan14Features[0].hostImageCopy != deviceVulkan14Features[1].hostImageCopy ||
        deviceVulkan14Features[0].pushDescriptor != deviceVulkan14Features[1].pushDescriptor)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkan14Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkanMemoryModelFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkanMemoryModelFeatures deviceVulkanMemoryModelFeatures[count];
    const bool                                isVulkanMemoryModelFeatures = context.contextSupports(vk::ApiVersion(1, 1, 2, 0));

    if (!isVulkanMemoryModelFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkanMemoryModelFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkanMemoryModelFeatures));
        deviceVulkanMemoryModelFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_MEMORY_MODEL_FEATURES;
        deviceVulkanMemoryModelFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkanMemoryModelFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkanMemoryModelFeatures[0] << TestLog::EndMessage;

    if (
        deviceVulkanMemoryModelFeatures[0].vulkanMemoryModel != deviceVulkanMemoryModelFeatures[1].vulkanMemoryModel ||
        deviceVulkanMemoryModelFeatures[0].vulkanMemoryModelDeviceScope != deviceVulkanMemoryModelFeatures[1].vulkanMemoryModelDeviceScope ||
        deviceVulkanMemoryModelFeatures[0].vulkanMemoryModelAvailabilityVisibilityChains != deviceVulkanMemoryModelFeatures[1].vulkanMemoryModelAvailabilityVisibilityChains)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkanMemoryModelFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureVulkanSC10Features (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceVulkanSC10Features deviceVulkanSC10Features[count];
    const bool                         isVulkanSC10Features = true;

    if (!isVulkanSC10Features)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceVulkanSC10Features[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceVulkanSC10Features));
        deviceVulkanSC10Features[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_VULKAN_SC_1_0_FEATURES;
        deviceVulkanSC10Features[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceVulkanSC10Features[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceVulkanSC10Features[0] << TestLog::EndMessage;

    if (
        deviceVulkanSC10Features[0].shaderAtomicInstructions != deviceVulkanSC10Features[1].shaderAtomicInstructions)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceVulkanSC10Features");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureYcbcr2Plane444FormatsFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT deviceYcbcr2Plane444FormatsFeaturesEXT[count];
    const bool                                       isYcbcr2Plane444FormatsFeaturesEXT = checkExtension(properties, "VK_EXT_ycbcr_2plane_444_formats");

    if (!isYcbcr2Plane444FormatsFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceYcbcr2Plane444FormatsFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT));
        deviceYcbcr2Plane444FormatsFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_2_PLANE_444_FORMATS_FEATURES_EXT;
        deviceYcbcr2Plane444FormatsFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceYcbcr2Plane444FormatsFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceYcbcr2Plane444FormatsFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceYcbcr2Plane444FormatsFeaturesEXT[0].ycbcr2plane444Formats != deviceYcbcr2Plane444FormatsFeaturesEXT[1].ycbcr2plane444Formats)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureYcbcrImageArraysFeaturesEXT (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceYcbcrImageArraysFeaturesEXT deviceYcbcrImageArraysFeaturesEXT[count];
    const bool                                  isYcbcrImageArraysFeaturesEXT = checkExtension(properties, "VK_EXT_ycbcr_image_arrays");

    if (!isYcbcrImageArraysFeaturesEXT)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceYcbcrImageArraysFeaturesEXT[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceYcbcrImageArraysFeaturesEXT));
        deviceYcbcrImageArraysFeaturesEXT[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_YCBCR_IMAGE_ARRAYS_FEATURES_EXT;
        deviceYcbcrImageArraysFeaturesEXT[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceYcbcrImageArraysFeaturesEXT[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceYcbcrImageArraysFeaturesEXT[0] << TestLog::EndMessage;

    if (
        deviceYcbcrImageArraysFeaturesEXT[0].ycbcrImageArrays != deviceYcbcrImageArraysFeaturesEXT[1].ycbcrImageArrays)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceYcbcrImageArraysFeaturesEXT");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus testPhysicalDeviceFeatureZeroInitializeWorkgroupMemoryFeatures (Context& context)
{
    const VkPhysicalDevice        physicalDevice = context.getPhysicalDevice();
    const CustomInstance          instance(createCustomInstanceWithExtension(context, "VK_KHR_get_physical_device_properties2"));
    const InstanceDriver&         vki(instance.getDriver());
    const int                     count = 2u;
    TestLog&                      log = context.getTestContext().getLog();
    VkPhysicalDeviceFeatures2     extFeatures;
    vector<VkExtensionProperties> properties = enumerateDeviceExtensionProperties(vki, physicalDevice, nullptr);

    VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures deviceZeroInitializeWorkgroupMemoryFeatures[count];
    const bool                                            isZeroInitializeWorkgroupMemoryFeatures = context.contextSupports(vk::ApiVersion(1, 1, 3, 0));

    if (!isZeroInitializeWorkgroupMemoryFeatures)
        return tcu::TestStatus::pass("Querying not supported");

    for (int ndx = 0; ndx < count; ++ndx)
    {
        deMemset(&deviceZeroInitializeWorkgroupMemoryFeatures[ndx], 0xFF * ndx, sizeof(VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures));
        deviceZeroInitializeWorkgroupMemoryFeatures[ndx].sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_ZERO_INITIALIZE_WORKGROUP_MEMORY_FEATURES;
        deviceZeroInitializeWorkgroupMemoryFeatures[ndx].pNext = nullptr;

        deMemset(&extFeatures.features, 0xcd, sizeof(extFeatures.features));
        extFeatures.sType = VK_STRUCTURE_TYPE_PHYSICAL_DEVICE_FEATURES_2;
        extFeatures.pNext = &deviceZeroInitializeWorkgroupMemoryFeatures[ndx];

        vki.getPhysicalDeviceFeatures2(physicalDevice, &extFeatures);
    }

    log << TestLog::Message << deviceZeroInitializeWorkgroupMemoryFeatures[0] << TestLog::EndMessage;

    if (
        deviceZeroInitializeWorkgroupMemoryFeatures[0].shaderZeroInitializeWorkgroupMemory != deviceZeroInitializeWorkgroupMemoryFeatures[1].shaderZeroInitializeWorkgroupMemory)
    {
        TCU_FAIL("Mismatch between VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures");
    }
    return tcu::TestStatus::pass("Querying succeeded");
}

tcu::TestStatus createDeviceWithPromoted11Structures (Context& context)
{
    if (!context.contextSupports(vk::ApiVersion(1, 1, 1, 0)))
        TCU_THROW(NotSupportedError, "Vulkan 1.1 is not supported");

    const PlatformInterface&        platformInterface = context.getPlatformInterface();
    const CustomInstance            instance            (createCustomInstanceFromContext(context));
    const InstanceDriver&            instanceDriver        (instance.getDriver());
    const VkPhysicalDevice            physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                    queueFamilyIndex = 0;
    const uint32_t                    queueCount = 1;
    const uint32_t                    queueIndex = 0;
    const float                        queuePriority = 1.0f;

    const vector<VkQueueFamilyProperties> queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(instanceDriver, physicalDevice);

    const VkDeviceQueueCreateInfo    deviceQueueCreateInfo =
    {
        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        nullptr,
        (VkDeviceQueueCreateFlags)0u,
        queueFamilyIndex, //queueFamilyIndex;
        queueCount, //queueCount;
        &queuePriority, //pQueuePriorities;
    };

	VkPhysicalDevice16BitStorageFeatures device16BitStorageFeatures = initVulkanStructure();
	VkPhysicalDeviceMultiviewFeatures deviceMultiviewFeatures = initVulkanStructure(&device16BitStorageFeatures);
	VkPhysicalDeviceProtectedMemoryFeatures deviceProtectedMemoryFeatures = initVulkanStructure(&deviceMultiviewFeatures);
	VkPhysicalDeviceSamplerYcbcrConversionFeatures deviceSamplerYcbcrConversionFeatures = initVulkanStructure(&deviceProtectedMemoryFeatures);
	VkPhysicalDeviceShaderDrawParametersFeatures deviceShaderDrawParametersFeatures = initVulkanStructure(&deviceSamplerYcbcrConversionFeatures);
	VkPhysicalDeviceVariablePointersFeatures deviceVariablePointersFeatures = initVulkanStructure(&deviceShaderDrawParametersFeatures);
	VkPhysicalDeviceFeatures2 extFeatures = initVulkanStructure(&deviceVariablePointersFeatures);

    instanceDriver.getPhysicalDeviceFeatures2 (physicalDevice, &extFeatures);

    const VkDeviceCreateInfo        deviceCreateInfo =
    {
        VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, //sType;
        &extFeatures, //pNext;
        (VkDeviceCreateFlags)0u,
        1, //queueRecordCount;
        &deviceQueueCreateInfo, //pRequestedQueues;
        0, //layerCount;
        nullptr, //ppEnabledLayerNames;
        0, //extensionCount;
        nullptr, //ppEnabledExtensionNames;
        nullptr, //pEnabledFeatures;
    };

    const Unique<VkDevice>            device            (createCustomDevice(context.getTestContext().getCommandLine().isValidationEnabled(), platformInterface, instance, instanceDriver, physicalDevice, &deviceCreateInfo));
    const DeviceDriver                deviceDriver    (platformInterface, instance, device.get(), context.getUsedApiVersion(), context.getTestContext().getCommandLine());
    const VkQueue                    queue = getDeviceQueue(deviceDriver, *device, queueFamilyIndex, queueIndex);

    VK_CHECK(deviceDriver.queueWaitIdle(queue));

    return tcu::TestStatus::pass("Pass");
}

tcu::TestStatus createDeviceWithPromoted12Structures (Context& context)
{
    if (!context.contextSupports(vk::ApiVersion(1, 1, 2, 0)))
        TCU_THROW(NotSupportedError, "Vulkan 1.2 is not supported");

    const PlatformInterface&        platformInterface = context.getPlatformInterface();
    const CustomInstance            instance            (createCustomInstanceFromContext(context));
    const InstanceDriver&            instanceDriver        (instance.getDriver());
    const VkPhysicalDevice            physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                    queueFamilyIndex = 0;
    const uint32_t                    queueCount = 1;
    const uint32_t                    queueIndex = 0;
    const float                        queuePriority = 1.0f;

    const vector<VkQueueFamilyProperties> queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(instanceDriver, physicalDevice);

    const VkDeviceQueueCreateInfo    deviceQueueCreateInfo =
    {
        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        nullptr,
        (VkDeviceQueueCreateFlags)0u,
        queueFamilyIndex, //queueFamilyIndex;
        queueCount, //queueCount;
        &queuePriority, //pQueuePriorities;
    };

	VkPhysicalDevice8BitStorageFeatures device8BitStorageFeatures = initVulkanStructure();
	VkPhysicalDeviceBufferDeviceAddressFeatures deviceBufferDeviceAddressFeatures = initVulkanStructure(&device8BitStorageFeatures);
	VkPhysicalDeviceDescriptorIndexingFeatures deviceDescriptorIndexingFeatures = initVulkanStructure(&deviceBufferDeviceAddressFeatures);
	VkPhysicalDeviceHostQueryResetFeatures deviceHostQueryResetFeatures = initVulkanStructure(&deviceDescriptorIndexingFeatures);
	VkPhysicalDeviceImagelessFramebufferFeatures deviceImagelessFramebufferFeatures = initVulkanStructure(&deviceHostQueryResetFeatures);
	VkPhysicalDeviceScalarBlockLayoutFeatures deviceScalarBlockLayoutFeatures = initVulkanStructure(&deviceImagelessFramebufferFeatures);
	VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures deviceSeparateDepthStencilLayoutsFeatures = initVulkanStructure(&deviceScalarBlockLayoutFeatures);
	VkPhysicalDeviceShaderAtomicInt64Features deviceShaderAtomicInt64Features = initVulkanStructure(&deviceSeparateDepthStencilLayoutsFeatures);
	VkPhysicalDeviceShaderFloat16Int8Features deviceShaderFloat16Int8Features = initVulkanStructure(&deviceShaderAtomicInt64Features);
	VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures deviceShaderSubgroupExtendedTypesFeatures = initVulkanStructure(&deviceShaderFloat16Int8Features);
	VkPhysicalDeviceTimelineSemaphoreFeatures deviceTimelineSemaphoreFeatures = initVulkanStructure(&deviceShaderSubgroupExtendedTypesFeatures);
	VkPhysicalDeviceUniformBufferStandardLayoutFeatures deviceUniformBufferStandardLayoutFeatures = initVulkanStructure(&deviceTimelineSemaphoreFeatures);
	VkPhysicalDeviceVulkanMemoryModelFeatures deviceVulkanMemoryModelFeatures = initVulkanStructure(&deviceUniformBufferStandardLayoutFeatures);
	VkPhysicalDeviceFeatures2 extFeatures = initVulkanStructure(&deviceVulkanMemoryModelFeatures);

    instanceDriver.getPhysicalDeviceFeatures2 (physicalDevice, &extFeatures);

    const VkDeviceCreateInfo        deviceCreateInfo =
    {
        VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, //sType;
        &extFeatures, //pNext;
        (VkDeviceCreateFlags)0u,
        1, //queueRecordCount;
        &deviceQueueCreateInfo, //pRequestedQueues;
        0, //layerCount;
        nullptr, //ppEnabledLayerNames;
        0, //extensionCount;
        nullptr, //ppEnabledExtensionNames;
        nullptr, //pEnabledFeatures;
    };

    const Unique<VkDevice>            device            (createCustomDevice(context.getTestContext().getCommandLine().isValidationEnabled(), platformInterface, instance, instanceDriver, physicalDevice, &deviceCreateInfo));
    const DeviceDriver                deviceDriver    (platformInterface, instance, device.get(), context.getUsedApiVersion(), context.getTestContext().getCommandLine());
    const VkQueue                    queue = getDeviceQueue(deviceDriver, *device, queueFamilyIndex, queueIndex);

    VK_CHECK(deviceDriver.queueWaitIdle(queue));

    return tcu::TestStatus::pass("Pass");
}

tcu::TestStatus createDeviceWithPromoted13Structures (Context& context)
{
    if (!context.contextSupports(vk::ApiVersion(1, 1, 3, 0)))
        TCU_THROW(NotSupportedError, "Vulkan 1.3 is not supported");

    const PlatformInterface&        platformInterface = context.getPlatformInterface();
    const CustomInstance            instance            (createCustomInstanceFromContext(context));
    const InstanceDriver&            instanceDriver        (instance.getDriver());
    const VkPhysicalDevice            physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                    queueFamilyIndex = 0;
    const uint32_t                    queueCount = 1;
    const uint32_t                    queueIndex = 0;
    const float                        queuePriority = 1.0f;

    const vector<VkQueueFamilyProperties> queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(instanceDriver, physicalDevice);

    const VkDeviceQueueCreateInfo    deviceQueueCreateInfo =
    {
        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        nullptr,
        (VkDeviceQueueCreateFlags)0u,
        queueFamilyIndex, //queueFamilyIndex;
        queueCount, //queueCount;
        &queuePriority, //pQueuePriorities;
    };

	VkPhysicalDeviceDynamicRenderingFeatures deviceDynamicRenderingFeatures = initVulkanStructure();
	VkPhysicalDeviceImageRobustnessFeatures deviceImageRobustnessFeatures = initVulkanStructure(&deviceDynamicRenderingFeatures);
	VkPhysicalDeviceInlineUniformBlockFeatures deviceInlineUniformBlockFeatures = initVulkanStructure(&deviceImageRobustnessFeatures);
	VkPhysicalDeviceMaintenance4Features deviceMaintenance4Features = initVulkanStructure(&deviceInlineUniformBlockFeatures);
	VkPhysicalDevicePipelineCreationCacheControlFeatures devicePipelineCreationCacheControlFeatures = initVulkanStructure(&deviceMaintenance4Features);
	VkPhysicalDevicePrivateDataFeatures devicePrivateDataFeatures = initVulkanStructure(&devicePipelineCreationCacheControlFeatures);
	VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures deviceShaderDemoteToHelperInvocationFeatures = initVulkanStructure(&devicePrivateDataFeatures);
	VkPhysicalDeviceShaderIntegerDotProductFeatures deviceShaderIntegerDotProductFeatures = initVulkanStructure(&deviceShaderDemoteToHelperInvocationFeatures);
	VkPhysicalDeviceShaderTerminateInvocationFeatures deviceShaderTerminateInvocationFeatures = initVulkanStructure(&deviceShaderIntegerDotProductFeatures);
	VkPhysicalDeviceSubgroupSizeControlFeatures deviceSubgroupSizeControlFeatures = initVulkanStructure(&deviceShaderTerminateInvocationFeatures);
	VkPhysicalDeviceSynchronization2Features deviceSynchronization2Features = initVulkanStructure(&deviceSubgroupSizeControlFeatures);
	VkPhysicalDeviceTextureCompressionASTCHDRFeatures deviceTextureCompressionASTCHDRFeatures = initVulkanStructure(&deviceSynchronization2Features);
	VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures deviceZeroInitializeWorkgroupMemoryFeatures = initVulkanStructure(&deviceTextureCompressionASTCHDRFeatures);
	VkPhysicalDeviceFeatures2 extFeatures = initVulkanStructure(&deviceZeroInitializeWorkgroupMemoryFeatures);

    instanceDriver.getPhysicalDeviceFeatures2 (physicalDevice, &extFeatures);

    const VkDeviceCreateInfo        deviceCreateInfo =
    {
        VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, //sType;
        &extFeatures, //pNext;
        (VkDeviceCreateFlags)0u,
        1, //queueRecordCount;
        &deviceQueueCreateInfo, //pRequestedQueues;
        0, //layerCount;
        nullptr, //ppEnabledLayerNames;
        0, //extensionCount;
        nullptr, //ppEnabledExtensionNames;
        nullptr, //pEnabledFeatures;
    };

    const Unique<VkDevice>            device            (createCustomDevice(context.getTestContext().getCommandLine().isValidationEnabled(), platformInterface, instance, instanceDriver, physicalDevice, &deviceCreateInfo));
    const DeviceDriver                deviceDriver    (platformInterface, instance, device.get(), context.getUsedApiVersion(), context.getTestContext().getCommandLine());
    const VkQueue                    queue = getDeviceQueue(deviceDriver, *device, queueFamilyIndex, queueIndex);

    VK_CHECK(deviceDriver.queueWaitIdle(queue));

    return tcu::TestStatus::pass("Pass");
}

tcu::TestStatus createDeviceWithPromoted14Structures (Context& context)
{
    if (!context.contextSupports(vk::ApiVersion(1, 1, 4, 0)))
        TCU_THROW(NotSupportedError, "Vulkan 1.4 is not supported");

    const PlatformInterface&        platformInterface = context.getPlatformInterface();
    const CustomInstance            instance            (createCustomInstanceFromContext(context));
    const InstanceDriver&            instanceDriver        (instance.getDriver());
    const VkPhysicalDevice            physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                    queueFamilyIndex = 0;
    const uint32_t                    queueCount = 1;
    const uint32_t                    queueIndex = 0;
    const float                        queuePriority = 1.0f;

    const vector<VkQueueFamilyProperties> queueFamilyProperties = getPhysicalDeviceQueueFamilyProperties(instanceDriver, physicalDevice);

    const VkDeviceQueueCreateInfo    deviceQueueCreateInfo =
    {
        VK_STRUCTURE_TYPE_DEVICE_QUEUE_CREATE_INFO,
        nullptr,
        (VkDeviceQueueCreateFlags)0u,
        queueFamilyIndex, //queueFamilyIndex;
        queueCount, //queueCount;
        &queuePriority, //pQueuePriorities;
    };

	VkPhysicalDeviceDynamicRenderingLocalReadFeatures deviceDynamicRenderingLocalReadFeatures = initVulkanStructure();
	VkPhysicalDeviceGlobalPriorityQueryFeatures deviceGlobalPriorityQueryFeatures = initVulkanStructure(&deviceDynamicRenderingLocalReadFeatures);
	VkPhysicalDeviceHostImageCopyFeatures deviceHostImageCopyFeatures = initVulkanStructure(&deviceGlobalPriorityQueryFeatures);
	VkPhysicalDeviceIndexTypeUint8Features deviceIndexTypeUint8Features = initVulkanStructure(&deviceHostImageCopyFeatures);
	VkPhysicalDeviceLineRasterizationFeatures deviceLineRasterizationFeatures = initVulkanStructure(&deviceIndexTypeUint8Features);
	VkPhysicalDeviceMaintenance5Features deviceMaintenance5Features = initVulkanStructure(&deviceLineRasterizationFeatures);
	VkPhysicalDeviceMaintenance6Features deviceMaintenance6Features = initVulkanStructure(&deviceMaintenance5Features);
	VkPhysicalDevicePipelineProtectedAccessFeatures devicePipelineProtectedAccessFeatures = initVulkanStructure(&deviceMaintenance6Features);
	VkPhysicalDevicePipelineRobustnessFeatures devicePipelineRobustnessFeatures = initVulkanStructure(&devicePipelineProtectedAccessFeatures);
	VkPhysicalDeviceShaderExpectAssumeFeatures deviceShaderExpectAssumeFeatures = initVulkanStructure(&devicePipelineRobustnessFeatures);
	VkPhysicalDeviceShaderFloatControls2Features deviceShaderFloatControls2Features = initVulkanStructure(&deviceShaderExpectAssumeFeatures);
	VkPhysicalDeviceShaderSubgroupRotateFeatures deviceShaderSubgroupRotateFeatures = initVulkanStructure(&deviceShaderFloatControls2Features);
	VkPhysicalDeviceVertexAttributeDivisorFeatures deviceVertexAttributeDivisorFeatures = initVulkanStructure(&deviceShaderSubgroupRotateFeatures);
	VkPhysicalDeviceFeatures2 extFeatures = initVulkanStructure(&deviceVertexAttributeDivisorFeatures);

    instanceDriver.getPhysicalDeviceFeatures2 (physicalDevice, &extFeatures);

    const VkDeviceCreateInfo        deviceCreateInfo =
    {
        VK_STRUCTURE_TYPE_DEVICE_CREATE_INFO, //sType;
        &extFeatures, //pNext;
        (VkDeviceCreateFlags)0u,
        1, //queueRecordCount;
        &deviceQueueCreateInfo, //pRequestedQueues;
        0, //layerCount;
        nullptr, //ppEnabledLayerNames;
        0, //extensionCount;
        nullptr, //ppEnabledExtensionNames;
        nullptr, //pEnabledFeatures;
    };

    const Unique<VkDevice>            device            (createCustomDevice(context.getTestContext().getCommandLine().isValidationEnabled(), platformInterface, instance, instanceDriver, physicalDevice, &deviceCreateInfo));
    const DeviceDriver                deviceDriver    (platformInterface, instance, device.get(), context.getUsedApiVersion(), context.getTestContext().getCommandLine());
    const VkQueue                    queue = getDeviceQueue(deviceDriver, *device, queueFamilyIndex, queueIndex);

    VK_CHECK(deviceDriver.queueWaitIdle(queue));

    return tcu::TestStatus::pass("Pass");
}

void addSeparateFeatureTests (tcu::TestCaseGroup* testGroup)
{
	addFunctionCase(testGroup, "16_bit_storage_features", testPhysicalDeviceFeature16BitStorageFeatures);
	addFunctionCase(testGroup, "4444_formats_features_ext", testPhysicalDeviceFeature4444FormatsFeaturesEXT);
	addFunctionCase(testGroup, "8_bit_storage_features", testPhysicalDeviceFeature8BitStorageFeatures);
	addFunctionCase(testGroup, "astc_decode_features_ext", testPhysicalDeviceFeatureASTCDecodeFeaturesEXT);
	addFunctionCase(testGroup, "blend_operation_advanced_features_ext", testPhysicalDeviceFeatureBlendOperationAdvancedFeaturesEXT);
	addFunctionCase(testGroup, "buffer_device_address_features", testPhysicalDeviceFeatureBufferDeviceAddressFeatures);
	addFunctionCase(testGroup, "color_write_enable_features_ext", testPhysicalDeviceFeatureColorWriteEnableFeaturesEXT);
	addFunctionCase(testGroup, "custom_border_color_features_ext", testPhysicalDeviceFeatureCustomBorderColorFeaturesEXT);
	addFunctionCase(testGroup, "depth_clip_enable_features_ext", testPhysicalDeviceFeatureDepthClipEnableFeaturesEXT);
	addFunctionCase(testGroup, "descriptor_indexing_features", testPhysicalDeviceFeatureDescriptorIndexingFeatures);
	addFunctionCase(testGroup, "dynamic_rendering_features", testPhysicalDeviceFeatureDynamicRenderingFeatures);
	addFunctionCase(testGroup, "dynamic_rendering_local_read_features", testPhysicalDeviceFeatureDynamicRenderingLocalReadFeatures);
	addFunctionCase(testGroup, "extended_dynamic_state2_features_ext", testPhysicalDeviceFeatureExtendedDynamicState2FeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state_features_ext", testPhysicalDeviceFeatureExtendedDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "fragment_shader_interlock_features_ext", testPhysicalDeviceFeatureFragmentShaderInterlockFeaturesEXT);
	addFunctionCase(testGroup, "fragment_shading_rate_features_khr", testPhysicalDeviceFeatureFragmentShadingRateFeaturesKHR);
	addFunctionCase(testGroup, "global_priority_query_features", testPhysicalDeviceFeatureGlobalPriorityQueryFeatures);
	addFunctionCase(testGroup, "host_image_copy_features", testPhysicalDeviceFeatureHostImageCopyFeatures);
	addFunctionCase(testGroup, "host_query_reset_features", testPhysicalDeviceFeatureHostQueryResetFeatures);
	addFunctionCase(testGroup, "image_robustness_features", testPhysicalDeviceFeatureImageRobustnessFeatures);
	addFunctionCase(testGroup, "imageless_framebuffer_features", testPhysicalDeviceFeatureImagelessFramebufferFeatures);
	addFunctionCase(testGroup, "index_type_uint8_features", testPhysicalDeviceFeatureIndexTypeUint8Features);
	addFunctionCase(testGroup, "inline_uniform_block_features", testPhysicalDeviceFeatureInlineUniformBlockFeatures);
	addFunctionCase(testGroup, "line_rasterization_features", testPhysicalDeviceFeatureLineRasterizationFeatures);
	addFunctionCase(testGroup, "maintenance4_features", testPhysicalDeviceFeatureMaintenance4Features);
	addFunctionCase(testGroup, "maintenance5_features", testPhysicalDeviceFeatureMaintenance5Features);
	addFunctionCase(testGroup, "maintenance6_features", testPhysicalDeviceFeatureMaintenance6Features);
	addFunctionCase(testGroup, "multiview_features", testPhysicalDeviceFeatureMultiviewFeatures);
	addFunctionCase(testGroup, "performance_query_features_khr", testPhysicalDeviceFeaturePerformanceQueryFeaturesKHR);
	addFunctionCase(testGroup, "pipeline_creation_cache_control_features", testPhysicalDeviceFeaturePipelineCreationCacheControlFeatures);
	addFunctionCase(testGroup, "pipeline_protected_access_features", testPhysicalDeviceFeaturePipelineProtectedAccessFeatures);
	addFunctionCase(testGroup, "pipeline_robustness_features", testPhysicalDeviceFeaturePipelineRobustnessFeatures);
	addFunctionCase(testGroup, "private_data_features", testPhysicalDeviceFeaturePrivateDataFeatures);
	addFunctionCase(testGroup, "protected_memory_features", testPhysicalDeviceFeatureProtectedMemoryFeatures);
	addFunctionCase(testGroup, "robustness2_features_khr", testPhysicalDeviceFeatureRobustness2FeaturesKHR);
	addFunctionCase(testGroup, "sampler_ycbcr_conversion_features", testPhysicalDeviceFeatureSamplerYcbcrConversionFeatures);
	addFunctionCase(testGroup, "scalar_block_layout_features", testPhysicalDeviceFeatureScalarBlockLayoutFeatures);
	addFunctionCase(testGroup, "separate_depth_stencil_layouts_features", testPhysicalDeviceFeatureSeparateDepthStencilLayoutsFeatures);
	addFunctionCase(testGroup, "shader_atomic_float_features_ext", testPhysicalDeviceFeatureShaderAtomicFloatFeaturesEXT);
	addFunctionCase(testGroup, "shader_atomic_int64_features", testPhysicalDeviceFeatureShaderAtomicInt64Features);
	addFunctionCase(testGroup, "shader_clock_features_khr", testPhysicalDeviceFeatureShaderClockFeaturesKHR);
	addFunctionCase(testGroup, "shader_demote_to_helper_invocation_features", testPhysicalDeviceFeatureShaderDemoteToHelperInvocationFeatures);
	addFunctionCase(testGroup, "shader_draw_parameters_features", testPhysicalDeviceFeatureShaderDrawParametersFeatures);
	addFunctionCase(testGroup, "shader_expect_assume_features", testPhysicalDeviceFeatureShaderExpectAssumeFeatures);
	addFunctionCase(testGroup, "shader_float16_int8_features", testPhysicalDeviceFeatureShaderFloat16Int8Features);
	addFunctionCase(testGroup, "shader_float_controls2_features", testPhysicalDeviceFeatureShaderFloatControls2Features);
	addFunctionCase(testGroup, "shader_image_atomic_int64_features_ext", testPhysicalDeviceFeatureShaderImageAtomicInt64FeaturesEXT);
	addFunctionCase(testGroup, "shader_integer_dot_product_features", testPhysicalDeviceFeatureShaderIntegerDotProductFeatures);
	addFunctionCase(testGroup, "shader_subgroup_extended_types_features", testPhysicalDeviceFeatureShaderSubgroupExtendedTypesFeatures);
	addFunctionCase(testGroup, "shader_subgroup_rotate_features", testPhysicalDeviceFeatureShaderSubgroupRotateFeatures);
	addFunctionCase(testGroup, "shader_terminate_invocation_features", testPhysicalDeviceFeatureShaderTerminateInvocationFeatures);
	addFunctionCase(testGroup, "subgroup_size_control_features", testPhysicalDeviceFeatureSubgroupSizeControlFeatures);
	addFunctionCase(testGroup, "synchronization2_features", testPhysicalDeviceFeatureSynchronization2Features);
	addFunctionCase(testGroup, "texel_buffer_alignment_features_ext", testPhysicalDeviceFeatureTexelBufferAlignmentFeaturesEXT);
	addFunctionCase(testGroup, "texture_compression_astchdr_features", testPhysicalDeviceFeatureTextureCompressionASTCHDRFeatures);
	addFunctionCase(testGroup, "timeline_semaphore_features", testPhysicalDeviceFeatureTimelineSemaphoreFeatures);
	addFunctionCase(testGroup, "uniform_buffer_standard_layout_features", testPhysicalDeviceFeatureUniformBufferStandardLayoutFeatures);
	addFunctionCase(testGroup, "variable_pointers_features", testPhysicalDeviceFeatureVariablePointersFeatures);
	addFunctionCase(testGroup, "vertex_attribute_divisor_features", testPhysicalDeviceFeatureVertexAttributeDivisorFeatures);
	addFunctionCase(testGroup, "vertex_input_dynamic_state_features_ext", testPhysicalDeviceFeatureVertexInputDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "vulkan11_features", testPhysicalDeviceFeatureVulkan11Features);
	addFunctionCase(testGroup, "vulkan12_features", testPhysicalDeviceFeatureVulkan12Features);
	addFunctionCase(testGroup, "vulkan13_features", testPhysicalDeviceFeatureVulkan13Features);
	addFunctionCase(testGroup, "vulkan14_features", testPhysicalDeviceFeatureVulkan14Features);
	addFunctionCase(testGroup, "vulkan_memory_model_features", testPhysicalDeviceFeatureVulkanMemoryModelFeatures);
	addFunctionCase(testGroup, "vulkan_sc10_features", testPhysicalDeviceFeatureVulkanSC10Features);
	addFunctionCase(testGroup, "ycbcr2_plane444_formats_features_ext", testPhysicalDeviceFeatureYcbcr2Plane444FormatsFeaturesEXT);
	addFunctionCase(testGroup, "ycbcr_image_arrays_features_ext", testPhysicalDeviceFeatureYcbcrImageArraysFeaturesEXT);
	addFunctionCase(testGroup, "zero_initialize_workgroup_memory_features", testPhysicalDeviceFeatureZeroInitializeWorkgroupMemoryFeatures);
	addFunctionCase(testGroup, "create_device_with_promoted11_structures", createDeviceWithPromoted11Structures);
	addFunctionCase(testGroup, "create_device_with_promoted12_structures", createDeviceWithPromoted12Structures);
	addFunctionCase(testGroup, "create_device_with_promoted13_structures", createDeviceWithPromoted13Structures);
	addFunctionCase(testGroup, "create_device_with_promoted14_structures", createDeviceWithPromoted14Structures);
}

