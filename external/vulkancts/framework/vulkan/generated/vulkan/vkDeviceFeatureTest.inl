/* WARNING: This is auto-generated file. Do not modify, since changes will
 * be lost! Modify the generating script instead.
 * This file was generated by /scripts/gen_framework.py
 */



tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDeviceGeneratedCommandsFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV, deviceGeneratedCommands),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDeviceGeneratedCommandsComputeFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, deviceGeneratedCompute),
        FEATURE_ITEM (VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, deviceGeneratedComputePipelines),
        FEATURE_ITEM (VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV, deviceGeneratedComputeCaptureReplay),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsComputeFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPrivateDataFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePrivateDataFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePrivateDataFeatures, privateData),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePrivateDataFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestVariablePointersFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceVariablePointersFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceVariablePointersFeatures, variablePointersStorageBuffer),
        FEATURE_ITEM (VkPhysicalDeviceVariablePointersFeatures, variablePointers),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceVariablePointersFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMultiviewFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMultiviewFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMultiviewFeatures, multiview),
        FEATURE_ITEM (VkPhysicalDeviceMultiviewFeatures, multiviewGeometryShader),
        FEATURE_ITEM (VkPhysicalDeviceMultiviewFeatures, multiviewTessellationShader),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMultiviewFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPresentIdFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePresentIdFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePresentIdFeaturesKHR, presentId),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePresentIdFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPresentWaitFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePresentWaitFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePresentWaitFeaturesKHR, presentWait),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePresentWaitFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTest16BitStorageFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevice16BitStorageFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevice16BitStorageFeatures, storageBuffer16BitAccess),
        FEATURE_ITEM (VkPhysicalDevice16BitStorageFeatures, uniformAndStorageBuffer16BitAccess),
        FEATURE_ITEM (VkPhysicalDevice16BitStorageFeatures, storagePushConstant16),
        FEATURE_ITEM (VkPhysicalDevice16BitStorageFeatures, storageInputOutput16),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevice16BitStorageFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 4, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderSubgroupExtendedTypesFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures, shaderSubgroupExtendedTypes),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderSubgroupExtendedTypesFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestSamplerYcbcrConversionFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceSamplerYcbcrConversionFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceSamplerYcbcrConversionFeatures, samplerYcbcrConversion),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceSamplerYcbcrConversionFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestProtectedMemoryFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceProtectedMemoryFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceProtectedMemoryFeatures, protectedMemory),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceProtectedMemoryFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestBlendOperationAdvancedFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT, advancedBlendCoherentOperations),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceBlendOperationAdvancedFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMultiDrawFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMultiDrawFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMultiDrawFeaturesEXT, multiDraw),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMultiDrawFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestInlineUniformBlockFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceInlineUniformBlockFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceInlineUniformBlockFeatures, inlineUniformBlock),
        FEATURE_ITEM (VkPhysicalDeviceInlineUniformBlockFeatures, descriptorBindingInlineUniformBlockUpdateAfterBind),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceInlineUniformBlockFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMaintenance4Features (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMaintenance4Features>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMaintenance4Features, maintenance4),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMaintenance4Features*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMaintenance5FeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMaintenance5FeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMaintenance5FeaturesKHR, maintenance5),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMaintenance5FeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMaintenance6FeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMaintenance6FeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMaintenance6FeaturesKHR, maintenance6),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMaintenance6FeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMaintenance7FeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMaintenance7FeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMaintenance7FeaturesKHR, maintenance7),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMaintenance7FeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderDrawParametersFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderDrawParametersFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderDrawParametersFeatures, shaderDrawParameters),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderDrawParametersFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderFloat16Int8Features (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderFloat16Int8Features>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderFloat16Int8Features, shaderFloat16),
        FEATURE_ITEM (VkPhysicalDeviceShaderFloat16Int8Features, shaderInt8),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderFloat16Int8Features*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestHostQueryResetFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceHostQueryResetFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceHostQueryResetFeatures, hostQueryReset),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceHostQueryResetFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestGlobalPriorityQueryFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR, globalPriorityQuery),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceGlobalPriorityQueryFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDeviceMemoryReportFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDeviceMemoryReportFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDeviceMemoryReportFeaturesEXT, deviceMemoryReport),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDeviceMemoryReportFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDescriptorIndexingFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDescriptorIndexingFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderInputAttachmentArrayDynamicIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderUniformTexelBufferArrayDynamicIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderStorageTexelBufferArrayDynamicIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderUniformBufferArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderSampledImageArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderStorageBufferArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderStorageImageArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderInputAttachmentArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderUniformTexelBufferArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, shaderStorageTexelBufferArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingUniformBufferUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingSampledImageUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingStorageImageUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingStorageBufferUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingUniformTexelBufferUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingStorageTexelBufferUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingUpdateUnusedWhilePending),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingPartiallyBound),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, descriptorBindingVariableDescriptorCount),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorIndexingFeatures, runtimeDescriptorArray),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDescriptorIndexingFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 20, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestTimelineSemaphoreFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceTimelineSemaphoreFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceTimelineSemaphoreFeatures, timelineSemaphore),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceTimelineSemaphoreFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTest8BitStorageFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevice8BitStorageFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevice8BitStorageFeatures, storageBuffer8BitAccess),
        FEATURE_ITEM (VkPhysicalDevice8BitStorageFeatures, uniformAndStorageBuffer8BitAccess),
        FEATURE_ITEM (VkPhysicalDevice8BitStorageFeatures, storagePushConstant8),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevice8BitStorageFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestConditionalRenderingFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceConditionalRenderingFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceConditionalRenderingFeaturesEXT, conditionalRendering),
        FEATURE_ITEM (VkPhysicalDeviceConditionalRenderingFeaturesEXT, inheritedConditionalRendering),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceConditionalRenderingFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestVulkanMemoryModelFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceVulkanMemoryModelFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceVulkanMemoryModelFeatures, vulkanMemoryModel),
        FEATURE_ITEM (VkPhysicalDeviceVulkanMemoryModelFeatures, vulkanMemoryModelDeviceScope),
        FEATURE_ITEM (VkPhysicalDeviceVulkanMemoryModelFeatures, vulkanMemoryModelAvailabilityVisibilityChains),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceVulkanMemoryModelFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderAtomicInt64Features (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderAtomicInt64Features>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicInt64Features, shaderBufferInt64Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicInt64Features, shaderSharedInt64Atomics),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderAtomicInt64Features*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderAtomicFloatFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderAtomicFloatFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderBufferFloat32Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderBufferFloat32AtomicAdd),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderBufferFloat64Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderBufferFloat64AtomicAdd),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderSharedFloat32Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderSharedFloat32AtomicAdd),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderSharedFloat64Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderSharedFloat64AtomicAdd),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderImageFloat32Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, shaderImageFloat32AtomicAdd),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, sparseImageFloat32Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloatFeaturesEXT, sparseImageFloat32AtomicAdd),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloatFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 12, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderAtomicFloat2FeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat16Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat16AtomicAdd),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat16AtomicMinMax),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat32AtomicMinMax),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderBufferFloat64AtomicMinMax),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat16Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat16AtomicAdd),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat16AtomicMinMax),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat32AtomicMinMax),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderSharedFloat64AtomicMinMax),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, shaderImageFloat32AtomicMinMax),
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT, sparseImageFloat32AtomicMinMax),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloat2FeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 12, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestVertexAttributeDivisorFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR, vertexAttributeInstanceRateDivisor),
        FEATURE_ITEM (VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR, vertexAttributeInstanceRateZeroDivisor),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceVertexAttributeDivisorFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestASTCDecodeFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceASTCDecodeFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceASTCDecodeFeaturesEXT, decodeModeSharedExponent),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceASTCDecodeFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestTransformFeedbackFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceTransformFeedbackFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceTransformFeedbackFeaturesEXT, transformFeedback),
        FEATURE_ITEM (VkPhysicalDeviceTransformFeedbackFeaturesEXT, geometryStreams),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceTransformFeedbackFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRepresentativeFragmentTestFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV, representativeFragmentTest),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRepresentativeFragmentTestFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestExclusiveScissorFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceExclusiveScissorFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceExclusiveScissorFeaturesNV, exclusiveScissor),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceExclusiveScissorFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCornerSampledImageFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCornerSampledImageFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCornerSampledImageFeaturesNV, cornerSampledImage),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCornerSampledImageFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestComputeShaderDerivativesFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, computeDerivativeGroupQuads),
        FEATURE_ITEM (VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR, computeDerivativeGroupLinear),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceComputeShaderDerivativesFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderImageFootprintFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderImageFootprintFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderImageFootprintFeaturesNV, imageFootprint),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderImageFootprintFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDedicatedAllocationImageAliasingFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV, dedicatedAllocationImageAliasing),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDedicatedAllocationImageAliasingFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCopyMemoryIndirectFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCopyMemoryIndirectFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCopyMemoryIndirectFeaturesNV, indirectCopy),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCopyMemoryIndirectFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMemoryDecompressionFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMemoryDecompressionFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMemoryDecompressionFeaturesNV, memoryDecompression),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMemoryDecompressionFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShadingRateImageFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShadingRateImageFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShadingRateImageFeaturesNV, shadingRateImage),
        FEATURE_ITEM (VkPhysicalDeviceShadingRateImageFeaturesNV, shadingRateCoarseSampleOrder),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShadingRateImageFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestInvocationMaskFeaturesHUAWEI (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceInvocationMaskFeaturesHUAWEI>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceInvocationMaskFeaturesHUAWEI, invocationMask),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceInvocationMaskFeaturesHUAWEI*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMeshShaderFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMeshShaderFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMeshShaderFeaturesNV, taskShader),
        FEATURE_ITEM (VkPhysicalDeviceMeshShaderFeaturesNV, meshShader),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMeshShaderFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMeshShaderFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMeshShaderFeaturesEXT, taskShader),
        FEATURE_ITEM (VkPhysicalDeviceMeshShaderFeaturesEXT, meshShader),
        FEATURE_ITEM (VkPhysicalDeviceMeshShaderFeaturesEXT, multiviewMeshShader),
        FEATURE_ITEM (VkPhysicalDeviceMeshShaderFeaturesEXT, primitiveFragmentShadingRateMeshShader),
        FEATURE_ITEM (VkPhysicalDeviceMeshShaderFeaturesEXT, meshShaderQueries),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMeshShaderFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 5, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestAccelerationStructureFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceAccelerationStructureFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceAccelerationStructureFeaturesKHR, accelerationStructure),
        FEATURE_ITEM (VkPhysicalDeviceAccelerationStructureFeaturesKHR, accelerationStructureCaptureReplay),
        FEATURE_ITEM (VkPhysicalDeviceAccelerationStructureFeaturesKHR, accelerationStructureIndirectBuild),
        FEATURE_ITEM (VkPhysicalDeviceAccelerationStructureFeaturesKHR, accelerationStructureHostCommands),
        FEATURE_ITEM (VkPhysicalDeviceAccelerationStructureFeaturesKHR, descriptorBindingAccelerationStructureUpdateAfterBind),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceAccelerationStructureFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 5, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRayTracingPipelineFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRayTracingPipelineFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTracingPipeline),
        FEATURE_ITEM (VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTracingPipelineShaderGroupHandleCaptureReplay),
        FEATURE_ITEM (VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTracingPipelineShaderGroupHandleCaptureReplayMixed),
        FEATURE_ITEM (VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTracingPipelineTraceRaysIndirect),
        FEATURE_ITEM (VkPhysicalDeviceRayTracingPipelineFeaturesKHR, rayTraversalPrimitiveCulling),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRayTracingPipelineFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 5, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRayQueryFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRayQueryFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRayQueryFeaturesKHR, rayQuery),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRayQueryFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRayTracingMaintenance1FeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, rayTracingMaintenance1),
        FEATURE_ITEM (VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR, rayTracingPipelineTraceRaysIndirect2),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRayTracingMaintenance1FeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFragmentDensityMapFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFragmentDensityMapFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFragmentDensityMapFeaturesEXT, fragmentDensityMap),
        FEATURE_ITEM (VkPhysicalDeviceFragmentDensityMapFeaturesEXT, fragmentDensityMapDynamic),
        FEATURE_ITEM (VkPhysicalDeviceFragmentDensityMapFeaturesEXT, fragmentDensityMapNonSubsampledImages),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFragmentDensityMap2FeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFragmentDensityMap2FeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFragmentDensityMap2FeaturesEXT, fragmentDensityMapDeferred),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFragmentDensityMap2FeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFragmentDensityMapOffsetFeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM, fragmentDensityMapOffset),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFragmentDensityMapOffsetFeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestScalarBlockLayoutFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceScalarBlockLayoutFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceScalarBlockLayoutFeatures, scalarBlockLayout),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceScalarBlockLayoutFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestUniformBufferStandardLayoutFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceUniformBufferStandardLayoutFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceUniformBufferStandardLayoutFeatures, uniformBufferStandardLayout),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceUniformBufferStandardLayoutFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDepthClipEnableFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDepthClipEnableFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDepthClipEnableFeaturesEXT, depthClipEnable),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDepthClipEnableFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMemoryPriorityFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMemoryPriorityFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMemoryPriorityFeaturesEXT, memoryPriority),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMemoryPriorityFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPageableDeviceLocalMemoryFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT, pageableDeviceLocalMemory),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePageableDeviceLocalMemoryFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestBufferDeviceAddressFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceBufferDeviceAddressFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceBufferDeviceAddressFeatures, bufferDeviceAddress),
        FEATURE_ITEM (VkPhysicalDeviceBufferDeviceAddressFeatures, bufferDeviceAddressCaptureReplay),
        FEATURE_ITEM (VkPhysicalDeviceBufferDeviceAddressFeatures, bufferDeviceAddressMultiDevice),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestBufferDeviceAddressFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceBufferDeviceAddressFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, bufferDeviceAddress),
        FEATURE_ITEM (VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, bufferDeviceAddressCaptureReplay),
        FEATURE_ITEM (VkPhysicalDeviceBufferDeviceAddressFeaturesEXT, bufferDeviceAddressMultiDevice),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceBufferDeviceAddressFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImagelessFramebufferFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImagelessFramebufferFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImagelessFramebufferFeatures, imagelessFramebuffer),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImagelessFramebufferFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestTextureCompressionASTCHDRFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceTextureCompressionASTCHDRFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceTextureCompressionASTCHDRFeatures, textureCompressionASTC_HDR),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceTextureCompressionASTCHDRFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCooperativeMatrixFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCooperativeMatrixFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCooperativeMatrixFeaturesNV, cooperativeMatrix),
        FEATURE_ITEM (VkPhysicalDeviceCooperativeMatrixFeaturesNV, cooperativeMatrixRobustBufferAccess),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestYcbcrImageArraysFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceYcbcrImageArraysFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceYcbcrImageArraysFeaturesEXT, ycbcrImageArrays),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceYcbcrImageArraysFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPresentBarrierFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePresentBarrierFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePresentBarrierFeaturesNV, presentBarrier),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePresentBarrierFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPerformanceQueryFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePerformanceQueryFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePerformanceQueryFeaturesKHR, performanceCounterQueryPools),
        FEATURE_ITEM (VkPhysicalDevicePerformanceQueryFeaturesKHR, performanceCounterMultipleQueryPools),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePerformanceQueryFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCoverageReductionModeFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCoverageReductionModeFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCoverageReductionModeFeaturesNV, coverageReductionMode),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCoverageReductionModeFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderIntegerFunctions2FeaturesINTEL (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL, shaderIntegerFunctions2),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderIntegerFunctions2FeaturesINTEL*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderClockFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderClockFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderClockFeaturesKHR, shaderSubgroupClock),
        FEATURE_ITEM (VkPhysicalDeviceShaderClockFeaturesKHR, shaderDeviceClock),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderClockFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestIndexTypeUint8FeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceIndexTypeUint8FeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceIndexTypeUint8FeaturesKHR, indexTypeUint8),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceIndexTypeUint8FeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderSMBuiltinsFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderSMBuiltinsFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderSMBuiltinsFeaturesNV, shaderSMBuiltins),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderSMBuiltinsFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFragmentShaderInterlockFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, fragmentShaderSampleInterlock),
        FEATURE_ITEM (VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, fragmentShaderPixelInterlock),
        FEATURE_ITEM (VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT, fragmentShaderShadingRateInterlock),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFragmentShaderInterlockFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestSeparateDepthStencilLayoutsFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures, separateDepthStencilLayouts),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceSeparateDepthStencilLayoutsFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPrimitiveTopologyListRestartFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, primitiveTopologyListRestart),
        FEATURE_ITEM (VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT, primitiveTopologyPatchListRestart),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePrimitiveTopologyListRestartFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPipelineExecutablePropertiesFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR, pipelineExecutableInfo),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePipelineExecutablePropertiesFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderDemoteToHelperInvocationFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures, shaderDemoteToHelperInvocation),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderDemoteToHelperInvocationFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestTexelBufferAlignmentFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT, texelBufferAlignment),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceTexelBufferAlignmentFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestSubgroupSizeControlFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceSubgroupSizeControlFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceSubgroupSizeControlFeatures, subgroupSizeControl),
        FEATURE_ITEM (VkPhysicalDeviceSubgroupSizeControlFeatures, computeFullSubgroups),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceSubgroupSizeControlFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestLineRasterizationFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceLineRasterizationFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceLineRasterizationFeaturesKHR, rectangularLines),
        FEATURE_ITEM (VkPhysicalDeviceLineRasterizationFeaturesKHR, bresenhamLines),
        FEATURE_ITEM (VkPhysicalDeviceLineRasterizationFeaturesKHR, smoothLines),
        FEATURE_ITEM (VkPhysicalDeviceLineRasterizationFeaturesKHR, stippledRectangularLines),
        FEATURE_ITEM (VkPhysicalDeviceLineRasterizationFeaturesKHR, stippledBresenhamLines),
        FEATURE_ITEM (VkPhysicalDeviceLineRasterizationFeaturesKHR, stippledSmoothLines),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceLineRasterizationFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 6, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPipelineCreationCacheControlFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePipelineCreationCacheControlFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePipelineCreationCacheControlFeatures, pipelineCreationCacheControl),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePipelineCreationCacheControlFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestVulkan11Features (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceVulkan11Features>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, storageBuffer16BitAccess),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, uniformAndStorageBuffer16BitAccess),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, storagePushConstant16),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, storageInputOutput16),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, multiview),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, multiviewGeometryShader),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, multiviewTessellationShader),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, variablePointersStorageBuffer),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, variablePointers),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, protectedMemory),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, samplerYcbcrConversion),
        FEATURE_ITEM (VkPhysicalDeviceVulkan11Features, shaderDrawParameters),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceVulkan11Features*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 12, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, nullptr, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestVulkan12Features (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceVulkan12Features>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, samplerMirrorClampToEdge),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, drawIndirectCount),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, storageBuffer8BitAccess),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, uniformAndStorageBuffer8BitAccess),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, storagePushConstant8),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderBufferInt64Atomics),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderSharedInt64Atomics),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderFloat16),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderInt8),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderInputAttachmentArrayDynamicIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderUniformTexelBufferArrayDynamicIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderStorageTexelBufferArrayDynamicIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderUniformBufferArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderSampledImageArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderStorageBufferArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderStorageImageArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderInputAttachmentArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderUniformTexelBufferArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderStorageTexelBufferArrayNonUniformIndexing),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingUniformBufferUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingSampledImageUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingStorageImageUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingStorageBufferUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingUniformTexelBufferUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingStorageTexelBufferUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingUpdateUnusedWhilePending),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingPartiallyBound),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, descriptorBindingVariableDescriptorCount),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, runtimeDescriptorArray),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, samplerFilterMinmax),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, scalarBlockLayout),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, imagelessFramebuffer),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, uniformBufferStandardLayout),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderSubgroupExtendedTypes),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, separateDepthStencilLayouts),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, hostQueryReset),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, timelineSemaphore),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, bufferDeviceAddress),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, bufferDeviceAddressCaptureReplay),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, bufferDeviceAddressMultiDevice),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, vulkanMemoryModel),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, vulkanMemoryModelDeviceScope),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, vulkanMemoryModelAvailabilityVisibilityChains),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderOutputViewportIndex),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, shaderOutputLayer),
        FEATURE_ITEM (VkPhysicalDeviceVulkan12Features, subgroupBroadcastDynamicId),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceVulkan12Features*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 47, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, nullptr, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestVulkan13Features (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceVulkan13Features>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, robustImageAccess),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, inlineUniformBlock),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, descriptorBindingInlineUniformBlockUpdateAfterBind),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, pipelineCreationCacheControl),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, privateData),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, shaderDemoteToHelperInvocation),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, shaderTerminateInvocation),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, subgroupSizeControl),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, computeFullSubgroups),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, synchronization2),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, textureCompressionASTC_HDR),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, shaderZeroInitializeWorkgroupMemory),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, dynamicRendering),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, shaderIntegerDotProduct),
        FEATURE_ITEM (VkPhysicalDeviceVulkan13Features, maintenance4),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceVulkan13Features*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 15, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, nullptr, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCoherentMemoryFeaturesAMD (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCoherentMemoryFeaturesAMD>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCoherentMemoryFeaturesAMD, deviceCoherentMemory),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCoherentMemoryFeaturesAMD*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCustomBorderColorFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCustomBorderColorFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCustomBorderColorFeaturesEXT, customBorderColors),
        FEATURE_ITEM (VkPhysicalDeviceCustomBorderColorFeaturesEXT, customBorderColorWithoutFormat),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCustomBorderColorFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestBorderColorSwizzleFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceBorderColorSwizzleFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, borderColorSwizzle),
        FEATURE_ITEM (VkPhysicalDeviceBorderColorSwizzleFeaturesEXT, borderColorSwizzleFromImage),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceBorderColorSwizzleFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestExtendedDynamicStateFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceExtendedDynamicStateFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicStateFeaturesEXT, extendedDynamicState),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceExtendedDynamicStateFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestExtendedDynamicState2FeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceExtendedDynamicState2FeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, extendedDynamicState2),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, extendedDynamicState2LogicOp),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState2FeaturesEXT, extendedDynamicState2PatchControlPoints),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceExtendedDynamicState2FeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestExtendedDynamicState3FeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceExtendedDynamicState3FeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3TessellationDomainOrigin),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3DepthClampEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3PolygonMode),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3RasterizationSamples),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3SampleMask),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3AlphaToCoverageEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3AlphaToOneEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3LogicOpEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ColorBlendEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ColorBlendEquation),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ColorWriteMask),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3RasterizationStream),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ConservativeRasterizationMode),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ExtraPrimitiveOverestimationSize),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3DepthClipEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3SampleLocationsEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ColorBlendAdvanced),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ProvokingVertexMode),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3LineRasterizationMode),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3LineStippleEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3DepthClipNegativeOneToOne),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ViewportWScalingEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ViewportSwizzle),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageToColorEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageToColorLocation),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageModulationMode),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageModulationTableEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageModulationTable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3CoverageReductionMode),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3RepresentativeFragmentTestEnable),
        FEATURE_ITEM (VkPhysicalDeviceExtendedDynamicState3FeaturesEXT, extendedDynamicState3ShadingRateImageEnable),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceExtendedDynamicState3FeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 31, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDiagnosticsConfigFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDiagnosticsConfigFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDiagnosticsConfigFeaturesNV, diagnosticsConfig),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDiagnosticsConfigFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestZeroInitializeWorkgroupMemoryFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures, shaderZeroInitializeWorkgroupMemory),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceZeroInitializeWorkgroupMemoryFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderSubgroupUniformControlFlowFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR, shaderSubgroupUniformControlFlow),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderSubgroupUniformControlFlowFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRobustness2FeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRobustness2FeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRobustness2FeaturesEXT, robustBufferAccess2),
        FEATURE_ITEM (VkPhysicalDeviceRobustness2FeaturesEXT, robustImageAccess2),
        FEATURE_ITEM (VkPhysicalDeviceRobustness2FeaturesEXT, nullDescriptor),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRobustness2FeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImageRobustnessFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImageRobustnessFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImageRobustnessFeatures, robustImageAccess),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImageRobustnessFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestWorkgroupMemoryExplicitLayoutFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, workgroupMemoryExplicitLayout),
        FEATURE_ITEM (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, workgroupMemoryExplicitLayoutScalarBlockLayout),
        FEATURE_ITEM (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, workgroupMemoryExplicitLayout8BitAccess),
        FEATURE_ITEM (VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR, workgroupMemoryExplicitLayout16BitAccess),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceWorkgroupMemoryExplicitLayoutFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 4, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPortabilitySubsetFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePortabilitySubsetFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, constantAlphaColorBlendFactors),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, events),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, imageViewFormatReinterpretation),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, imageViewFormatSwizzle),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, imageView2DOn3DImage),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, multisampleArrayImage),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, mutableComparisonSamplers),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, pointPolygons),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, samplerMipLodBias),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, separateStencilMaskRef),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, shaderSampleRateInterpolationFunctions),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, tessellationIsolines),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, tessellationPointMode),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, triangleFans),
        FEATURE_ITEM (VkPhysicalDevicePortabilitySubsetFeaturesKHR, vertexAttributeAccessBeyondStride),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePortabilitySubsetFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 15, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTest4444FormatsFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevice4444FormatsFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevice4444FormatsFeaturesEXT, formatA4R4G4B4),
        FEATURE_ITEM (VkPhysicalDevice4444FormatsFeaturesEXT, formatA4B4G4R4),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevice4444FormatsFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestSubpassShadingFeaturesHUAWEI (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceSubpassShadingFeaturesHUAWEI>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceSubpassShadingFeaturesHUAWEI, subpassShading),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceSubpassShadingFeaturesHUAWEI*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestClusterCullingShaderFeaturesHUAWEI (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, clustercullingShader),
        FEATURE_ITEM (VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI, multiviewClusterCullingShader),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceClusterCullingShaderFeaturesHUAWEI*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestClusterCullingShaderVrsFeaturesHUAWEI (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI, clusterShadingRate),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceClusterCullingShaderVrsFeaturesHUAWEI*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderImageAtomicInt64FeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, shaderImageInt64Atomics),
        FEATURE_ITEM (VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT, sparseImageInt64Atomics),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderImageAtomicInt64FeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFragmentShadingRateFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFragmentShadingRateFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFragmentShadingRateFeaturesKHR, pipelineFragmentShadingRate),
        FEATURE_ITEM (VkPhysicalDeviceFragmentShadingRateFeaturesKHR, primitiveFragmentShadingRate),
        FEATURE_ITEM (VkPhysicalDeviceFragmentShadingRateFeaturesKHR, attachmentFragmentShadingRate),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderTerminateInvocationFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderTerminateInvocationFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderTerminateInvocationFeatures, shaderTerminateInvocation),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderTerminateInvocationFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFragmentShadingRateEnumsFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, fragmentShadingRateEnums),
        FEATURE_ITEM (VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, supersampleFragmentShadingRates),
        FEATURE_ITEM (VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV, noInvocationFragmentShadingRates),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFragmentShadingRateEnumsFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImage2DViewOf3DFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImage2DViewOf3DFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, image2DViewOf3D),
        FEATURE_ITEM (VkPhysicalDeviceImage2DViewOf3DFeaturesEXT, sampler2DViewOf3D),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImage2DViewOf3DFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImageSlicedViewOf3DFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT, imageSlicedViewOf3D),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImageSlicedViewOf3DFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestAttachmentFeedbackLoopDynamicStateFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT, attachmentFeedbackLoopDynamicState),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceAttachmentFeedbackLoopDynamicStateFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestLegacyVertexAttributesFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT, legacyVertexAttributes),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceLegacyVertexAttributesFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMutableDescriptorTypeFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT, mutableDescriptorType),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMutableDescriptorTypeFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDepthClipControlFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDepthClipControlFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDepthClipControlFeaturesEXT, depthClipControl),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDepthClipControlFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDeviceGeneratedCommandsFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, deviceGeneratedCommands),
        FEATURE_ITEM (VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT, dynamicGeneratedPipelineLayout),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDeviceGeneratedCommandsFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDepthClampControlFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDepthClampControlFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDepthClampControlFeaturesEXT, depthClampControl),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDepthClampControlFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestVertexInputDynamicStateFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT, vertexInputDynamicState),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceVertexInputDynamicStateFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestExternalMemoryRDMAFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceExternalMemoryRDMAFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceExternalMemoryRDMAFeaturesNV, externalMemoryRDMA),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceExternalMemoryRDMAFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderRelaxedExtendedInstructionFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR, shaderRelaxedExtendedInstruction),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderRelaxedExtendedInstructionFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestColorWriteEnableFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceColorWriteEnableFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceColorWriteEnableFeaturesEXT, colorWriteEnable),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceColorWriteEnableFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestSynchronization2Features (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceSynchronization2Features>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceSynchronization2Features, synchronization2),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceSynchronization2Features*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestHostImageCopyFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceHostImageCopyFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceHostImageCopyFeaturesEXT, hostImageCopy),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceHostImageCopyFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPrimitivesGeneratedQueryFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, primitivesGeneratedQuery),
        FEATURE_ITEM (VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, primitivesGeneratedQueryWithRasterizerDiscard),
        FEATURE_ITEM (VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT, primitivesGeneratedQueryWithNonZeroStreams),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePrimitivesGeneratedQueryFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestLegacyDitheringFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceLegacyDitheringFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceLegacyDitheringFeaturesEXT, legacyDithering),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceLegacyDitheringFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMultisampledRenderToSingleSampledFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT, multisampledRenderToSingleSampled),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMultisampledRenderToSingleSampledFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPipelineProtectedAccessFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePipelineProtectedAccessFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePipelineProtectedAccessFeaturesEXT, pipelineProtectedAccess),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePipelineProtectedAccessFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestVideoMaintenance1FeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceVideoMaintenance1FeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceVideoMaintenance1FeaturesKHR, videoMaintenance1),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceVideoMaintenance1FeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestInheritedViewportScissorFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceInheritedViewportScissorFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceInheritedViewportScissorFeaturesNV, inheritedViewportScissor2D),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceInheritedViewportScissorFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestYcbcr2Plane444FormatsFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT, ycbcr2plane444Formats),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceYcbcr2Plane444FormatsFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestProvokingVertexFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceProvokingVertexFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceProvokingVertexFeaturesEXT, provokingVertexLast),
        FEATURE_ITEM (VkPhysicalDeviceProvokingVertexFeaturesEXT, transformFeedbackPreservesProvokingVertex),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceProvokingVertexFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDescriptorBufferFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDescriptorBufferFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDescriptorBufferFeaturesEXT, descriptorBuffer),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorBufferFeaturesEXT, descriptorBufferCaptureReplay),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorBufferFeaturesEXT, descriptorBufferImageLayoutIgnored),
        FEATURE_ITEM (VkPhysicalDeviceDescriptorBufferFeaturesEXT, descriptorBufferPushDescriptors),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDescriptorBufferFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 4, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderIntegerDotProductFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderIntegerDotProductFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderIntegerDotProductFeatures, shaderIntegerDotProduct),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderIntegerDotProductFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFragmentShaderBarycentricFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR, fragmentShaderBarycentric),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFragmentShaderBarycentricFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRayTracingMotionBlurFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRayTracingMotionBlurFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, rayTracingMotionBlur),
        FEATURE_ITEM (VkPhysicalDeviceRayTracingMotionBlurFeaturesNV, rayTracingMotionBlurPipelineTraceRaysIndirect),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRayTracingMotionBlurFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRayTracingValidationFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRayTracingValidationFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRayTracingValidationFeaturesNV, rayTracingValidation),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRayTracingValidationFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRGBA10X6FormatsFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT, formatRgba10x6WithoutYCbCrSampler),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRGBA10X6FormatsFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDynamicRenderingFeatures (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDynamicRenderingFeatures>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDynamicRenderingFeatures, dynamicRendering),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDynamicRenderingFeatures*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImageViewMinLodFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImageViewMinLodFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImageViewMinLodFeaturesEXT, minLod),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImageViewMinLodFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRasterizationOrderAttachmentAccessFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, rasterizationOrderColorAttachmentAccess),
        FEATURE_ITEM (VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, rasterizationOrderDepthAttachmentAccess),
        FEATURE_ITEM (VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT, rasterizationOrderStencilAttachmentAccess),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRasterizationOrderAttachmentAccessFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestLinearColorAttachmentFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceLinearColorAttachmentFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceLinearColorAttachmentFeaturesNV, linearColorAttachment),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceLinearColorAttachmentFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestGraphicsPipelineLibraryFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT, graphicsPipelineLibrary),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceGraphicsPipelineLibraryFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPipelineBinaryFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePipelineBinaryFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePipelineBinaryFeaturesKHR, pipelineBinaries),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePipelineBinaryFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDescriptorSetHostMappingFeaturesVALVE (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE, descriptorSetHostMapping),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDescriptorSetHostMappingFeaturesVALVE*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestNestedCommandBufferFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceNestedCommandBufferFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceNestedCommandBufferFeaturesEXT, nestedCommandBuffer),
        FEATURE_ITEM (VkPhysicalDeviceNestedCommandBufferFeaturesEXT, nestedCommandBufferRendering),
        FEATURE_ITEM (VkPhysicalDeviceNestedCommandBufferFeaturesEXT, nestedCommandBufferSimultaneousUse),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceNestedCommandBufferFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderModuleIdentifierFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT, shaderModuleIdentifier),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderModuleIdentifierFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImageCompressionControlFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImageCompressionControlFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImageCompressionControlFeaturesEXT, imageCompressionControl),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImageCompressionControlFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImageCompressionControlSwapchainFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT, imageCompressionControlSwapchain),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImageCompressionControlSwapchainFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestSubpassMergeFeedbackFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT, subpassMergeFeedback),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceSubpassMergeFeedbackFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestOpacityMicromapFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceOpacityMicromapFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceOpacityMicromapFeaturesEXT, micromap),
        FEATURE_ITEM (VkPhysicalDeviceOpacityMicromapFeaturesEXT, micromapCaptureReplay),
        FEATURE_ITEM (VkPhysicalDeviceOpacityMicromapFeaturesEXT, micromapHostCommands),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceOpacityMicromapFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDisplacementMicromapFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDisplacementMicromapFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDisplacementMicromapFeaturesNV, displacementMicromap),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDisplacementMicromapFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPipelinePropertiesFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePipelinePropertiesFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePipelinePropertiesFeaturesEXT, pipelinePropertiesIdentifier),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePipelinePropertiesFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderEarlyAndLateFragmentTestsFeaturesAMD (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD, shaderEarlyAndLateFragmentTests),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderEarlyAndLateFragmentTestsFeaturesAMD*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestNonSeamlessCubeMapFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT, nonSeamlessCubeMap),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceNonSeamlessCubeMapFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPipelineRobustnessFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePipelineRobustnessFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePipelineRobustnessFeaturesEXT, pipelineRobustness),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePipelineRobustnessFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImageProcessingFeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImageProcessingFeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImageProcessingFeaturesQCOM, textureSampleWeighted),
        FEATURE_ITEM (VkPhysicalDeviceImageProcessingFeaturesQCOM, textureBoxFilter),
        FEATURE_ITEM (VkPhysicalDeviceImageProcessingFeaturesQCOM, textureBlockMatch),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImageProcessingFeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestTilePropertiesFeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceTilePropertiesFeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceTilePropertiesFeaturesQCOM, tileProperties),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceTilePropertiesFeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestAmigoProfilingFeaturesSEC (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceAmigoProfilingFeaturesSEC>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceAmigoProfilingFeaturesSEC, amigoProfiling),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceAmigoProfilingFeaturesSEC*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestAttachmentFeedbackLoopLayoutFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT, attachmentFeedbackLoopLayout),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceAttachmentFeedbackLoopLayoutFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDepthClampZeroOneFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDepthClampZeroOneFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDepthClampZeroOneFeaturesEXT, depthClampZeroOne),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDepthClampZeroOneFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestAddressBindingReportFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceAddressBindingReportFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceAddressBindingReportFeaturesEXT, reportAddressBinding),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceAddressBindingReportFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestOpticalFlowFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceOpticalFlowFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceOpticalFlowFeaturesNV, opticalFlow),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceOpticalFlowFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFaultFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFaultFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFaultFeaturesEXT, deviceFault),
        FEATURE_ITEM (VkPhysicalDeviceFaultFeaturesEXT, deviceFaultVendorBinary),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFaultFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPipelineLibraryGroupHandlesFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT, pipelineLibraryGroupHandles),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePipelineLibraryGroupHandlesFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderCoreBuiltinsFeaturesARM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM, shaderCoreBuiltins),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderCoreBuiltinsFeaturesARM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestFrameBoundaryFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceFrameBoundaryFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceFrameBoundaryFeaturesEXT, frameBoundary),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceFrameBoundaryFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDynamicRenderingUnusedAttachmentsFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT, dynamicRenderingUnusedAttachments),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDynamicRenderingUnusedAttachmentsFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestSwapchainMaintenance1FeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT, swapchainMaintenance1),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceSwapchainMaintenance1FeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDepthBiasControlFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDepthBiasControlFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDepthBiasControlFeaturesEXT, depthBiasControl),
        FEATURE_ITEM (VkPhysicalDeviceDepthBiasControlFeaturesEXT, leastRepresentableValueForceUnormRepresentation),
        FEATURE_ITEM (VkPhysicalDeviceDepthBiasControlFeaturesEXT, floatRepresentation),
        FEATURE_ITEM (VkPhysicalDeviceDepthBiasControlFeaturesEXT, depthBiasExact),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDepthBiasControlFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 4, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRayTracingInvocationReorderFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV, rayTracingInvocationReorder),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRayTracingInvocationReorderFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestExtendedSparseAddressSpaceFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV, extendedSparseAddressSpace),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceExtendedSparseAddressSpaceFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMultiviewPerViewViewportsFeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM, multiviewPerViewViewports),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewViewportsFeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRayTracingPositionFetchFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR, rayTracingPositionFetch),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRayTracingPositionFetchFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMultiviewPerViewRenderAreasFeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM, multiviewPerViewRenderAreas),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMultiviewPerViewRenderAreasFeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderObjectFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderObjectFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderObjectFeaturesEXT, shaderObject),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderObjectFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderTileImageFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderTileImageFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderTileImageFeaturesEXT, shaderTileImageColorReadAccess),
        FEATURE_ITEM (VkPhysicalDeviceShaderTileImageFeaturesEXT, shaderTileImageDepthReadAccess),
        FEATURE_ITEM (VkPhysicalDeviceShaderTileImageFeaturesEXT, shaderTileImageStencilReadAccess),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderTileImageFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestExternalMemoryScreenBufferFeaturesQNX (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX, screenBufferImport),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceExternalMemoryScreenBufferFeaturesQNX*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCooperativeMatrixFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCooperativeMatrixFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCooperativeMatrixFeaturesKHR, cooperativeMatrix),
        FEATURE_ITEM (VkPhysicalDeviceCooperativeMatrixFeaturesKHR, cooperativeMatrixRobustBufferAccess),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCooperativeMatrixFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderEnqueueFeaturesAMDX (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderEnqueueFeaturesAMDX>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderEnqueueFeaturesAMDX, shaderEnqueue),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderEnqueueFeaturesAMDX*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestAntiLagFeaturesAMD (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceAntiLagFeaturesAMD>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceAntiLagFeaturesAMD, antiLag),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceAntiLagFeaturesAMD*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCubicClampFeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCubicClampFeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCubicClampFeaturesQCOM, cubicRangeClamp),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCubicClampFeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestYcbcrDegammaFeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceYcbcrDegammaFeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceYcbcrDegammaFeaturesQCOM, ycbcrDegamma),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceYcbcrDegammaFeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCubicWeightsFeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCubicWeightsFeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCubicWeightsFeaturesQCOM, selectableCubicWeights),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCubicWeightsFeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImageProcessing2FeaturesQCOM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImageProcessing2FeaturesQCOM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImageProcessing2FeaturesQCOM, textureBlockMatch2),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImageProcessing2FeaturesQCOM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDescriptorPoolOverallocationFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV, descriptorPoolOverallocation),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDescriptorPoolOverallocationFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestPerStageDescriptorSetFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDevicePerStageDescriptorSetFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDevicePerStageDescriptorSetFeaturesNV, perStageDescriptorSet),
        FEATURE_ITEM (VkPhysicalDevicePerStageDescriptorSetFeaturesNV, dynamicPipelineLayout),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDevicePerStageDescriptorSetFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestExternalFormatResolveFeaturesANDROID (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceExternalFormatResolveFeaturesANDROID>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceExternalFormatResolveFeaturesANDROID, externalFormatResolve),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceExternalFormatResolveFeaturesANDROID*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCudaKernelLaunchFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCudaKernelLaunchFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCudaKernelLaunchFeaturesNV, cudaKernelLaunchFeatures),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCudaKernelLaunchFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestSchedulingControlsFeaturesARM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceSchedulingControlsFeaturesARM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceSchedulingControlsFeaturesARM, schedulingControls),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceSchedulingControlsFeaturesARM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRelaxedLineRasterizationFeaturesIMG (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG, relaxedLineRasterization),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRelaxedLineRasterizationFeaturesIMG*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRenderPassStripedFeaturesARM (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRenderPassStripedFeaturesARM>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRenderPassStripedFeaturesARM, renderPassStriped),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRenderPassStripedFeaturesARM*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderMaximalReconvergenceFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR, shaderMaximalReconvergence),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderMaximalReconvergenceFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderSubgroupRotateFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR, shaderSubgroupRotate),
        FEATURE_ITEM (VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR, shaderSubgroupRotateClustered),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderSubgroupRotateFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 2, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderExpectAssumeFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderExpectAssumeFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderExpectAssumeFeaturesKHR, shaderExpectAssume),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderExpectAssumeFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderFloatControls2FeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderFloatControls2FeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderFloatControls2FeaturesKHR, shaderFloatControls2),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderFloatControls2FeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestDynamicRenderingLocalReadFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR, dynamicRenderingLocalRead),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceDynamicRenderingLocalReadFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderQuadControlFeaturesKHR (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderQuadControlFeaturesKHR>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderQuadControlFeaturesKHR, shaderQuadControl),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderQuadControlFeaturesKHR*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderAtomicFloat16VectorFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV, shaderFloat16VectorAtomics),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderAtomicFloat16VectorFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestMapMemoryPlacedFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceMapMemoryPlacedFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, memoryMapPlaced),
        FEATURE_ITEM (VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, memoryMapRangePlaced),
        FEATURE_ITEM (VkPhysicalDeviceMapMemoryPlacedFeaturesEXT, memoryUnmapReserve),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceMapMemoryPlacedFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 3, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestRawAccessChainsFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceRawAccessChainsFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceRawAccessChainsFeaturesNV, shaderRawAccessChains),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceRawAccessChainsFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestCommandBufferInheritanceFeaturesNV (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceCommandBufferInheritanceFeaturesNV>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceCommandBufferInheritanceFeaturesNV, commandBufferInheritance),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceCommandBufferInheritanceFeaturesNV*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestImageAlignmentControlFeaturesMESA (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceImageAlignmentControlFeaturesMESA>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceImageAlignmentControlFeaturesMESA, imageAlignmentControl),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceImageAlignmentControlFeaturesMESA*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


tcu::TestStatus createDeviceWithUnsupportedFeaturesTestShaderReplicatedCompositesFeaturesEXT (Context& context)
{
    const PlatformInterface&                vkp = context.getPlatformInterface();
    tcu::TestLog&                            log = context.getTestContext().getLog();
    tcu::ResultCollector                    resultCollector            (log);
    const CustomInstance                    instance                (createCustomInstanceWithExtensions(context, context.getInstanceExtensions(), nullptr, true));
    const InstanceDriver&                    instanceDriver            (instance.getDriver());
    const VkPhysicalDevice                    physicalDevice = chooseDevice(instanceDriver, instance, context.getTestContext().getCommandLine());
    const uint32_t                            queueFamilyIndex = 0;
    const uint32_t                            queueCount = 1;
    const float                                queuePriority = 1.0f;
    const DeviceFeatures                    deviceFeaturesAll        (context.getInstanceInterface(), context.getUsedApiVersion(), physicalDevice, context.getInstanceExtensions(), context.getDeviceExtensions(), true);
    const VkPhysicalDeviceFeatures2            deviceFeatures2 = deviceFeaturesAll.getCoreFeatures2();
    int                                        numErrors = 0;
    const tcu::CommandLine&                    commandLine = context.getTestContext().getCommandLine();
    bool                                    isSubProcess = context.getTestContext().getCommandLine().isSubProcess();


    VkPhysicalDeviceFeatures emptyDeviceFeatures;
    deMemset(&emptyDeviceFeatures, 0, sizeof(emptyDeviceFeatures));

    // Only non-core extensions will be used when creating the device.
    const auto& extensionNames = context.getDeviceCreationExtensions();
    DE_UNREF(extensionNames); // In some cases this is not used.

    if (const void* featuresStruct = findStructureInChain(const_cast<const void*>(deviceFeatures2.pNext), getStructureType<VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT>()))
    {
        static const Feature features[] =
        {
        FEATURE_ITEM (VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT, shaderReplicatedComposites),
        };
        auto* supportedFeatures = reinterpret_cast<const VkPhysicalDeviceShaderReplicatedCompositesFeaturesEXT*>(featuresStruct);
        checkFeatures(vkp, instance, instanceDriver, physicalDevice, 1, features, supportedFeatures, queueFamilyIndex, queueCount, queuePriority, numErrors, resultCollector, &extensionNames, emptyDeviceFeatures, isSubProcess, context.getUsedApiVersion(), commandLine);
    }

    if (numErrors > 0)
        return tcu::TestStatus(resultCollector.getResult(), "Enabling unsupported features didn't return VK_ERROR_FEATURE_NOT_PRESENT.");

    return tcu::TestStatus(resultCollector.getResult(), resultCollector.getMessage());
}


void addSeparateUnsupportedFeatureTests (tcu::TestCaseGroup* testGroup)
{

	addFunctionCase(testGroup, "device_generated_commands_features_nv", createDeviceWithUnsupportedFeaturesTestDeviceGeneratedCommandsFeaturesNV);
	addFunctionCase(testGroup, "device_generated_commands_compute_features_nv", createDeviceWithUnsupportedFeaturesTestDeviceGeneratedCommandsComputeFeaturesNV);
	addFunctionCase(testGroup, "private_data_features", createDeviceWithUnsupportedFeaturesTestPrivateDataFeatures);
	addFunctionCase(testGroup, "variable_pointers_features", createDeviceWithUnsupportedFeaturesTestVariablePointersFeatures);
	addFunctionCase(testGroup, "multiview_features", createDeviceWithUnsupportedFeaturesTestMultiviewFeatures);
	addFunctionCase(testGroup, "present_id_features_khr", createDeviceWithUnsupportedFeaturesTestPresentIdFeaturesKHR);
	addFunctionCase(testGroup, "present_wait_features_khr", createDeviceWithUnsupportedFeaturesTestPresentWaitFeaturesKHR);
	addFunctionCase(testGroup, "16_bit_storage_features", createDeviceWithUnsupportedFeaturesTest16BitStorageFeatures);
	addFunctionCase(testGroup, "shader_subgroup_extended_types_features", createDeviceWithUnsupportedFeaturesTestShaderSubgroupExtendedTypesFeatures);
	addFunctionCase(testGroup, "sampler_ycbcr_conversion_features", createDeviceWithUnsupportedFeaturesTestSamplerYcbcrConversionFeatures);
	addFunctionCase(testGroup, "protected_memory_features", createDeviceWithUnsupportedFeaturesTestProtectedMemoryFeatures);
	addFunctionCase(testGroup, "blend_operation_advanced_features_ext", createDeviceWithUnsupportedFeaturesTestBlendOperationAdvancedFeaturesEXT);
	addFunctionCase(testGroup, "multi_draw_features_ext", createDeviceWithUnsupportedFeaturesTestMultiDrawFeaturesEXT);
	addFunctionCase(testGroup, "inline_uniform_block_features", createDeviceWithUnsupportedFeaturesTestInlineUniformBlockFeatures);
	addFunctionCase(testGroup, "maintenance4_features", createDeviceWithUnsupportedFeaturesTestMaintenance4Features);
	addFunctionCase(testGroup, "maintenance5_features_khr", createDeviceWithUnsupportedFeaturesTestMaintenance5FeaturesKHR);
	addFunctionCase(testGroup, "maintenance6_features_khr", createDeviceWithUnsupportedFeaturesTestMaintenance6FeaturesKHR);
	addFunctionCase(testGroup, "maintenance7_features_khr", createDeviceWithUnsupportedFeaturesTestMaintenance7FeaturesKHR);
	addFunctionCase(testGroup, "shader_draw_parameters_features", createDeviceWithUnsupportedFeaturesTestShaderDrawParametersFeatures);
	addFunctionCase(testGroup, "shader_float16_int8_features", createDeviceWithUnsupportedFeaturesTestShaderFloat16Int8Features);
	addFunctionCase(testGroup, "host_query_reset_features", createDeviceWithUnsupportedFeaturesTestHostQueryResetFeatures);
	addFunctionCase(testGroup, "global_priority_query_features_khr", createDeviceWithUnsupportedFeaturesTestGlobalPriorityQueryFeaturesKHR);
	addFunctionCase(testGroup, "device_memory_report_features_ext", createDeviceWithUnsupportedFeaturesTestDeviceMemoryReportFeaturesEXT);
	addFunctionCase(testGroup, "descriptor_indexing_features", createDeviceWithUnsupportedFeaturesTestDescriptorIndexingFeatures);
	addFunctionCase(testGroup, "timeline_semaphore_features", createDeviceWithUnsupportedFeaturesTestTimelineSemaphoreFeatures);
	addFunctionCase(testGroup, "8_bit_storage_features", createDeviceWithUnsupportedFeaturesTest8BitStorageFeatures);
	addFunctionCase(testGroup, "conditional_rendering_features_ext", createDeviceWithUnsupportedFeaturesTestConditionalRenderingFeaturesEXT);
	addFunctionCase(testGroup, "vulkan_memory_model_features", createDeviceWithUnsupportedFeaturesTestVulkanMemoryModelFeatures);
	addFunctionCase(testGroup, "shader_atomic_int64_features", createDeviceWithUnsupportedFeaturesTestShaderAtomicInt64Features);
	addFunctionCase(testGroup, "shader_atomic_float_features_ext", createDeviceWithUnsupportedFeaturesTestShaderAtomicFloatFeaturesEXT);
	addFunctionCase(testGroup, "shader_atomic_float2_features_ext", createDeviceWithUnsupportedFeaturesTestShaderAtomicFloat2FeaturesEXT);
	addFunctionCase(testGroup, "vertex_attribute_divisor_features_khr", createDeviceWithUnsupportedFeaturesTestVertexAttributeDivisorFeaturesKHR);
	addFunctionCase(testGroup, "astc_decode_features_ext", createDeviceWithUnsupportedFeaturesTestASTCDecodeFeaturesEXT);
	addFunctionCase(testGroup, "transform_feedback_features_ext", createDeviceWithUnsupportedFeaturesTestTransformFeedbackFeaturesEXT);
	addFunctionCase(testGroup, "representative_fragment_test_features_nv", createDeviceWithUnsupportedFeaturesTestRepresentativeFragmentTestFeaturesNV);
	addFunctionCase(testGroup, "exclusive_scissor_features_nv", createDeviceWithUnsupportedFeaturesTestExclusiveScissorFeaturesNV);
	addFunctionCase(testGroup, "corner_sampled_image_features_nv", createDeviceWithUnsupportedFeaturesTestCornerSampledImageFeaturesNV);
	addFunctionCase(testGroup, "compute_shader_derivatives_features_khr", createDeviceWithUnsupportedFeaturesTestComputeShaderDerivativesFeaturesKHR);
	addFunctionCase(testGroup, "shader_image_footprint_features_nv", createDeviceWithUnsupportedFeaturesTestShaderImageFootprintFeaturesNV);
	addFunctionCase(testGroup, "dedicated_allocation_image_aliasing_features_nv", createDeviceWithUnsupportedFeaturesTestDedicatedAllocationImageAliasingFeaturesNV);
	addFunctionCase(testGroup, "copy_memory_indirect_features_nv", createDeviceWithUnsupportedFeaturesTestCopyMemoryIndirectFeaturesNV);
	addFunctionCase(testGroup, "memory_decompression_features_nv", createDeviceWithUnsupportedFeaturesTestMemoryDecompressionFeaturesNV);
	addFunctionCase(testGroup, "shading_rate_image_features_nv", createDeviceWithUnsupportedFeaturesTestShadingRateImageFeaturesNV);
	addFunctionCase(testGroup, "invocation_mask_features_huawei", createDeviceWithUnsupportedFeaturesTestInvocationMaskFeaturesHUAWEI);
	addFunctionCase(testGroup, "mesh_shader_features_nv", createDeviceWithUnsupportedFeaturesTestMeshShaderFeaturesNV);
	addFunctionCase(testGroup, "mesh_shader_features_ext", createDeviceWithUnsupportedFeaturesTestMeshShaderFeaturesEXT);
	addFunctionCase(testGroup, "acceleration_structure_features_khr", createDeviceWithUnsupportedFeaturesTestAccelerationStructureFeaturesKHR);
	addFunctionCase(testGroup, "ray_tracing_pipeline_features_khr", createDeviceWithUnsupportedFeaturesTestRayTracingPipelineFeaturesKHR);
	addFunctionCase(testGroup, "ray_query_features_khr", createDeviceWithUnsupportedFeaturesTestRayQueryFeaturesKHR);
	addFunctionCase(testGroup, "ray_tracing_maintenance1_features_khr", createDeviceWithUnsupportedFeaturesTestRayTracingMaintenance1FeaturesKHR);
	addFunctionCase(testGroup, "fragment_density_map_features_ext", createDeviceWithUnsupportedFeaturesTestFragmentDensityMapFeaturesEXT);
	addFunctionCase(testGroup, "fragment_density_map2_features_ext", createDeviceWithUnsupportedFeaturesTestFragmentDensityMap2FeaturesEXT);
	addFunctionCase(testGroup, "fragment_density_map_offset_features_qcom", createDeviceWithUnsupportedFeaturesTestFragmentDensityMapOffsetFeaturesQCOM);
	addFunctionCase(testGroup, "scalar_block_layout_features", createDeviceWithUnsupportedFeaturesTestScalarBlockLayoutFeatures);
	addFunctionCase(testGroup, "uniform_buffer_standard_layout_features", createDeviceWithUnsupportedFeaturesTestUniformBufferStandardLayoutFeatures);
	addFunctionCase(testGroup, "depth_clip_enable_features_ext", createDeviceWithUnsupportedFeaturesTestDepthClipEnableFeaturesEXT);
	addFunctionCase(testGroup, "memory_priority_features_ext", createDeviceWithUnsupportedFeaturesTestMemoryPriorityFeaturesEXT);
	addFunctionCase(testGroup, "pageable_device_local_memory_features_ext", createDeviceWithUnsupportedFeaturesTestPageableDeviceLocalMemoryFeaturesEXT);
	addFunctionCase(testGroup, "buffer_device_address_features", createDeviceWithUnsupportedFeaturesTestBufferDeviceAddressFeatures);
	addFunctionCase(testGroup, "buffer_device_address_features_ext", createDeviceWithUnsupportedFeaturesTestBufferDeviceAddressFeaturesEXT);
	addFunctionCase(testGroup, "imageless_framebuffer_features", createDeviceWithUnsupportedFeaturesTestImagelessFramebufferFeatures);
	addFunctionCase(testGroup, "texture_compression_astchdr_features", createDeviceWithUnsupportedFeaturesTestTextureCompressionASTCHDRFeatures);
	addFunctionCase(testGroup, "cooperative_matrix_features_nv", createDeviceWithUnsupportedFeaturesTestCooperativeMatrixFeaturesNV);
	addFunctionCase(testGroup, "ycbcr_image_arrays_features_ext", createDeviceWithUnsupportedFeaturesTestYcbcrImageArraysFeaturesEXT);
	addFunctionCase(testGroup, "present_barrier_features_nv", createDeviceWithUnsupportedFeaturesTestPresentBarrierFeaturesNV);
	addFunctionCase(testGroup, "performance_query_features_khr", createDeviceWithUnsupportedFeaturesTestPerformanceQueryFeaturesKHR);
	addFunctionCase(testGroup, "coverage_reduction_mode_features_nv", createDeviceWithUnsupportedFeaturesTestCoverageReductionModeFeaturesNV);
	addFunctionCase(testGroup, "shader_integer_functions2_features_intel", createDeviceWithUnsupportedFeaturesTestShaderIntegerFunctions2FeaturesINTEL);
	addFunctionCase(testGroup, "shader_clock_features_khr", createDeviceWithUnsupportedFeaturesTestShaderClockFeaturesKHR);
	addFunctionCase(testGroup, "index_type_uint8_features_khr", createDeviceWithUnsupportedFeaturesTestIndexTypeUint8FeaturesKHR);
	addFunctionCase(testGroup, "shader_sm_builtins_features_nv", createDeviceWithUnsupportedFeaturesTestShaderSMBuiltinsFeaturesNV);
	addFunctionCase(testGroup, "fragment_shader_interlock_features_ext", createDeviceWithUnsupportedFeaturesTestFragmentShaderInterlockFeaturesEXT);
	addFunctionCase(testGroup, "separate_depth_stencil_layouts_features", createDeviceWithUnsupportedFeaturesTestSeparateDepthStencilLayoutsFeatures);
	addFunctionCase(testGroup, "primitive_topology_list_restart_features_ext", createDeviceWithUnsupportedFeaturesTestPrimitiveTopologyListRestartFeaturesEXT);
	addFunctionCase(testGroup, "pipeline_executable_properties_features_khr", createDeviceWithUnsupportedFeaturesTestPipelineExecutablePropertiesFeaturesKHR);
	addFunctionCase(testGroup, "shader_demote_to_helper_invocation_features", createDeviceWithUnsupportedFeaturesTestShaderDemoteToHelperInvocationFeatures);
	addFunctionCase(testGroup, "texel_buffer_alignment_features_ext", createDeviceWithUnsupportedFeaturesTestTexelBufferAlignmentFeaturesEXT);
	addFunctionCase(testGroup, "subgroup_size_control_features", createDeviceWithUnsupportedFeaturesTestSubgroupSizeControlFeatures);
	addFunctionCase(testGroup, "line_rasterization_features_khr", createDeviceWithUnsupportedFeaturesTestLineRasterizationFeaturesKHR);
	addFunctionCase(testGroup, "pipeline_creation_cache_control_features", createDeviceWithUnsupportedFeaturesTestPipelineCreationCacheControlFeatures);
	addFunctionCase(testGroup, "vulkan11_features", createDeviceWithUnsupportedFeaturesTestVulkan11Features);
	addFunctionCase(testGroup, "vulkan12_features", createDeviceWithUnsupportedFeaturesTestVulkan12Features);
	addFunctionCase(testGroup, "vulkan13_features", createDeviceWithUnsupportedFeaturesTestVulkan13Features);
	addFunctionCase(testGroup, "coherent_memory_features_amd", createDeviceWithUnsupportedFeaturesTestCoherentMemoryFeaturesAMD);
	addFunctionCase(testGroup, "custom_border_color_features_ext", createDeviceWithUnsupportedFeaturesTestCustomBorderColorFeaturesEXT);
	addFunctionCase(testGroup, "border_color_swizzle_features_ext", createDeviceWithUnsupportedFeaturesTestBorderColorSwizzleFeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state_features_ext", createDeviceWithUnsupportedFeaturesTestExtendedDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state2_features_ext", createDeviceWithUnsupportedFeaturesTestExtendedDynamicState2FeaturesEXT);
	addFunctionCase(testGroup, "extended_dynamic_state3_features_ext", createDeviceWithUnsupportedFeaturesTestExtendedDynamicState3FeaturesEXT);
	addFunctionCase(testGroup, "diagnostics_config_features_nv", createDeviceWithUnsupportedFeaturesTestDiagnosticsConfigFeaturesNV);
	addFunctionCase(testGroup, "zero_initialize_workgroup_memory_features", createDeviceWithUnsupportedFeaturesTestZeroInitializeWorkgroupMemoryFeatures);
	addFunctionCase(testGroup, "shader_subgroup_uniform_control_flow_features_khr", createDeviceWithUnsupportedFeaturesTestShaderSubgroupUniformControlFlowFeaturesKHR);
	addFunctionCase(testGroup, "robustness2_features_ext", createDeviceWithUnsupportedFeaturesTestRobustness2FeaturesEXT);
	addFunctionCase(testGroup, "image_robustness_features", createDeviceWithUnsupportedFeaturesTestImageRobustnessFeatures);
	addFunctionCase(testGroup, "workgroup_memory_explicit_layout_features_khr", createDeviceWithUnsupportedFeaturesTestWorkgroupMemoryExplicitLayoutFeaturesKHR);
	addFunctionCase(testGroup, "portability_subset_features_khr", createDeviceWithUnsupportedFeaturesTestPortabilitySubsetFeaturesKHR);
	addFunctionCase(testGroup, "4444_formats_features_ext", createDeviceWithUnsupportedFeaturesTest4444FormatsFeaturesEXT);
	addFunctionCase(testGroup, "subpass_shading_features_huawei", createDeviceWithUnsupportedFeaturesTestSubpassShadingFeaturesHUAWEI);
	addFunctionCase(testGroup, "cluster_culling_shader_features_huawei", createDeviceWithUnsupportedFeaturesTestClusterCullingShaderFeaturesHUAWEI);
	addFunctionCase(testGroup, "cluster_culling_shader_vrs_features_huawei", createDeviceWithUnsupportedFeaturesTestClusterCullingShaderVrsFeaturesHUAWEI);
	addFunctionCase(testGroup, "shader_image_atomic_int64_features_ext", createDeviceWithUnsupportedFeaturesTestShaderImageAtomicInt64FeaturesEXT);
	addFunctionCase(testGroup, "fragment_shading_rate_features_khr", createDeviceWithUnsupportedFeaturesTestFragmentShadingRateFeaturesKHR);
	addFunctionCase(testGroup, "shader_terminate_invocation_features", createDeviceWithUnsupportedFeaturesTestShaderTerminateInvocationFeatures);
	addFunctionCase(testGroup, "fragment_shading_rate_enums_features_nv", createDeviceWithUnsupportedFeaturesTestFragmentShadingRateEnumsFeaturesNV);
	addFunctionCase(testGroup, "image_2d_view_of_3d_features_ext", createDeviceWithUnsupportedFeaturesTestImage2DViewOf3DFeaturesEXT);
	addFunctionCase(testGroup, "image_sliced_view_of_3d_features_ext", createDeviceWithUnsupportedFeaturesTestImageSlicedViewOf3DFeaturesEXT);
	addFunctionCase(testGroup, "attachment_feedback_loop_dynamic_state_features_ext", createDeviceWithUnsupportedFeaturesTestAttachmentFeedbackLoopDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "legacy_vertex_attributes_features_ext", createDeviceWithUnsupportedFeaturesTestLegacyVertexAttributesFeaturesEXT);
	addFunctionCase(testGroup, "mutable_descriptor_type_features_ext", createDeviceWithUnsupportedFeaturesTestMutableDescriptorTypeFeaturesEXT);
	addFunctionCase(testGroup, "depth_clip_control_features_ext", createDeviceWithUnsupportedFeaturesTestDepthClipControlFeaturesEXT);
	addFunctionCase(testGroup, "device_generated_commands_features_ext", createDeviceWithUnsupportedFeaturesTestDeviceGeneratedCommandsFeaturesEXT);
	addFunctionCase(testGroup, "depth_clamp_control_features_ext", createDeviceWithUnsupportedFeaturesTestDepthClampControlFeaturesEXT);
	addFunctionCase(testGroup, "vertex_input_dynamic_state_features_ext", createDeviceWithUnsupportedFeaturesTestVertexInputDynamicStateFeaturesEXT);
	addFunctionCase(testGroup, "external_memory_rdma_features_nv", createDeviceWithUnsupportedFeaturesTestExternalMemoryRDMAFeaturesNV);
	addFunctionCase(testGroup, "shader_relaxed_extended_instruction_features_khr", createDeviceWithUnsupportedFeaturesTestShaderRelaxedExtendedInstructionFeaturesKHR);
	addFunctionCase(testGroup, "color_write_enable_features_ext", createDeviceWithUnsupportedFeaturesTestColorWriteEnableFeaturesEXT);
	addFunctionCase(testGroup, "synchronization2_features", createDeviceWithUnsupportedFeaturesTestSynchronization2Features);
	addFunctionCase(testGroup, "host_image_copy_features_ext", createDeviceWithUnsupportedFeaturesTestHostImageCopyFeaturesEXT);
	addFunctionCase(testGroup, "primitives_generated_query_features_ext", createDeviceWithUnsupportedFeaturesTestPrimitivesGeneratedQueryFeaturesEXT);
	addFunctionCase(testGroup, "legacy_dithering_features_ext", createDeviceWithUnsupportedFeaturesTestLegacyDitheringFeaturesEXT);
	addFunctionCase(testGroup, "multisampled_render_to_single_sampled_features_ext", createDeviceWithUnsupportedFeaturesTestMultisampledRenderToSingleSampledFeaturesEXT);
	addFunctionCase(testGroup, "pipeline_protected_access_features_ext", createDeviceWithUnsupportedFeaturesTestPipelineProtectedAccessFeaturesEXT);
	addFunctionCase(testGroup, "video_maintenance1_features_khr", createDeviceWithUnsupportedFeaturesTestVideoMaintenance1FeaturesKHR);
	addFunctionCase(testGroup, "inherited_viewport_scissor_features_nv", createDeviceWithUnsupportedFeaturesTestInheritedViewportScissorFeaturesNV);
	addFunctionCase(testGroup, "ycbcr2_plane444_formats_features_ext", createDeviceWithUnsupportedFeaturesTestYcbcr2Plane444FormatsFeaturesEXT);
	addFunctionCase(testGroup, "provoking_vertex_features_ext", createDeviceWithUnsupportedFeaturesTestProvokingVertexFeaturesEXT);
	addFunctionCase(testGroup, "descriptor_buffer_features_ext", createDeviceWithUnsupportedFeaturesTestDescriptorBufferFeaturesEXT);
	addFunctionCase(testGroup, "shader_integer_dot_product_features", createDeviceWithUnsupportedFeaturesTestShaderIntegerDotProductFeatures);
	addFunctionCase(testGroup, "fragment_shader_barycentric_features_khr", createDeviceWithUnsupportedFeaturesTestFragmentShaderBarycentricFeaturesKHR);
	addFunctionCase(testGroup, "ray_tracing_motion_blur_features_nv", createDeviceWithUnsupportedFeaturesTestRayTracingMotionBlurFeaturesNV);
	addFunctionCase(testGroup, "ray_tracing_validation_features_nv", createDeviceWithUnsupportedFeaturesTestRayTracingValidationFeaturesNV);
	addFunctionCase(testGroup, "rgba10_x6_formats_features_ext", createDeviceWithUnsupportedFeaturesTestRGBA10X6FormatsFeaturesEXT);
	addFunctionCase(testGroup, "dynamic_rendering_features", createDeviceWithUnsupportedFeaturesTestDynamicRenderingFeatures);
	addFunctionCase(testGroup, "image_view_min_lod_features_ext", createDeviceWithUnsupportedFeaturesTestImageViewMinLodFeaturesEXT);
	addFunctionCase(testGroup, "rasterization_order_attachment_access_features_ext", createDeviceWithUnsupportedFeaturesTestRasterizationOrderAttachmentAccessFeaturesEXT);
	addFunctionCase(testGroup, "linear_color_attachment_features_nv", createDeviceWithUnsupportedFeaturesTestLinearColorAttachmentFeaturesNV);
	addFunctionCase(testGroup, "graphics_pipeline_library_features_ext", createDeviceWithUnsupportedFeaturesTestGraphicsPipelineLibraryFeaturesEXT);
	addFunctionCase(testGroup, "pipeline_binary_features_khr", createDeviceWithUnsupportedFeaturesTestPipelineBinaryFeaturesKHR);
	addFunctionCase(testGroup, "descriptor_set_host_mapping_features_valve", createDeviceWithUnsupportedFeaturesTestDescriptorSetHostMappingFeaturesVALVE);
	addFunctionCase(testGroup, "nested_command_buffer_features_ext", createDeviceWithUnsupportedFeaturesTestNestedCommandBufferFeaturesEXT);
	addFunctionCase(testGroup, "shader_module_identifier_features_ext", createDeviceWithUnsupportedFeaturesTestShaderModuleIdentifierFeaturesEXT);
	addFunctionCase(testGroup, "image_compression_control_features_ext", createDeviceWithUnsupportedFeaturesTestImageCompressionControlFeaturesEXT);
	addFunctionCase(testGroup, "image_compression_control_swapchain_features_ext", createDeviceWithUnsupportedFeaturesTestImageCompressionControlSwapchainFeaturesEXT);
	addFunctionCase(testGroup, "subpass_merge_feedback_features_ext", createDeviceWithUnsupportedFeaturesTestSubpassMergeFeedbackFeaturesEXT);
	addFunctionCase(testGroup, "opacity_micromap_features_ext", createDeviceWithUnsupportedFeaturesTestOpacityMicromapFeaturesEXT);
	addFunctionCase(testGroup, "displacement_micromap_features_nv", createDeviceWithUnsupportedFeaturesTestDisplacementMicromapFeaturesNV);
	addFunctionCase(testGroup, "pipeline_properties_features_ext", createDeviceWithUnsupportedFeaturesTestPipelinePropertiesFeaturesEXT);
	addFunctionCase(testGroup, "shader_early_and_late_fragment_tests_features_amd", createDeviceWithUnsupportedFeaturesTestShaderEarlyAndLateFragmentTestsFeaturesAMD);
	addFunctionCase(testGroup, "non_seamless_cube_map_features_ext", createDeviceWithUnsupportedFeaturesTestNonSeamlessCubeMapFeaturesEXT);
	addFunctionCase(testGroup, "pipeline_robustness_features_ext", createDeviceWithUnsupportedFeaturesTestPipelineRobustnessFeaturesEXT);
	addFunctionCase(testGroup, "image_processing_features_qcom", createDeviceWithUnsupportedFeaturesTestImageProcessingFeaturesQCOM);
	addFunctionCase(testGroup, "tile_properties_features_qcom", createDeviceWithUnsupportedFeaturesTestTilePropertiesFeaturesQCOM);
	addFunctionCase(testGroup, "amigo_profiling_features_sec", createDeviceWithUnsupportedFeaturesTestAmigoProfilingFeaturesSEC);
	addFunctionCase(testGroup, "attachment_feedback_loop_layout_features_ext", createDeviceWithUnsupportedFeaturesTestAttachmentFeedbackLoopLayoutFeaturesEXT);
	addFunctionCase(testGroup, "depth_clamp_zero_one_features_ext", createDeviceWithUnsupportedFeaturesTestDepthClampZeroOneFeaturesEXT);
	addFunctionCase(testGroup, "address_binding_report_features_ext", createDeviceWithUnsupportedFeaturesTestAddressBindingReportFeaturesEXT);
	addFunctionCase(testGroup, "optical_flow_features_nv", createDeviceWithUnsupportedFeaturesTestOpticalFlowFeaturesNV);
	addFunctionCase(testGroup, "fault_features_ext", createDeviceWithUnsupportedFeaturesTestFaultFeaturesEXT);
	addFunctionCase(testGroup, "pipeline_library_group_handles_features_ext", createDeviceWithUnsupportedFeaturesTestPipelineLibraryGroupHandlesFeaturesEXT);
	addFunctionCase(testGroup, "shader_core_builtins_features_arm", createDeviceWithUnsupportedFeaturesTestShaderCoreBuiltinsFeaturesARM);
	addFunctionCase(testGroup, "frame_boundary_features_ext", createDeviceWithUnsupportedFeaturesTestFrameBoundaryFeaturesEXT);
	addFunctionCase(testGroup, "dynamic_rendering_unused_attachments_features_ext", createDeviceWithUnsupportedFeaturesTestDynamicRenderingUnusedAttachmentsFeaturesEXT);
	addFunctionCase(testGroup, "swapchain_maintenance1_features_ext", createDeviceWithUnsupportedFeaturesTestSwapchainMaintenance1FeaturesEXT);
	addFunctionCase(testGroup, "depth_bias_control_features_ext", createDeviceWithUnsupportedFeaturesTestDepthBiasControlFeaturesEXT);
	addFunctionCase(testGroup, "ray_tracing_invocation_reorder_features_nv", createDeviceWithUnsupportedFeaturesTestRayTracingInvocationReorderFeaturesNV);
	addFunctionCase(testGroup, "extended_sparse_address_space_features_nv", createDeviceWithUnsupportedFeaturesTestExtendedSparseAddressSpaceFeaturesNV);
	addFunctionCase(testGroup, "multiview_per_view_viewports_features_qcom", createDeviceWithUnsupportedFeaturesTestMultiviewPerViewViewportsFeaturesQCOM);
	addFunctionCase(testGroup, "ray_tracing_position_fetch_features_khr", createDeviceWithUnsupportedFeaturesTestRayTracingPositionFetchFeaturesKHR);
	addFunctionCase(testGroup, "multiview_per_view_render_areas_features_qcom", createDeviceWithUnsupportedFeaturesTestMultiviewPerViewRenderAreasFeaturesQCOM);
	addFunctionCase(testGroup, "shader_object_features_ext", createDeviceWithUnsupportedFeaturesTestShaderObjectFeaturesEXT);
	addFunctionCase(testGroup, "shader_tile_image_features_ext", createDeviceWithUnsupportedFeaturesTestShaderTileImageFeaturesEXT);
	addFunctionCase(testGroup, "external_memory_screen_buffer_features_qnx", createDeviceWithUnsupportedFeaturesTestExternalMemoryScreenBufferFeaturesQNX);
	addFunctionCase(testGroup, "cooperative_matrix_features_khr", createDeviceWithUnsupportedFeaturesTestCooperativeMatrixFeaturesKHR);
	addFunctionCase(testGroup, "shader_enqueue_features_amdx", createDeviceWithUnsupportedFeaturesTestShaderEnqueueFeaturesAMDX);
	addFunctionCase(testGroup, "anti_lag_features_amd", createDeviceWithUnsupportedFeaturesTestAntiLagFeaturesAMD);
	addFunctionCase(testGroup, "cubic_clamp_features_qcom", createDeviceWithUnsupportedFeaturesTestCubicClampFeaturesQCOM);
	addFunctionCase(testGroup, "ycbcr_degamma_features_qcom", createDeviceWithUnsupportedFeaturesTestYcbcrDegammaFeaturesQCOM);
	addFunctionCase(testGroup, "cubic_weights_features_qcom", createDeviceWithUnsupportedFeaturesTestCubicWeightsFeaturesQCOM);
	addFunctionCase(testGroup, "image_processing2_features_qcom", createDeviceWithUnsupportedFeaturesTestImageProcessing2FeaturesQCOM);
	addFunctionCase(testGroup, "descriptor_pool_overallocation_features_nv", createDeviceWithUnsupportedFeaturesTestDescriptorPoolOverallocationFeaturesNV);
	addFunctionCase(testGroup, "per_stage_descriptor_set_features_nv", createDeviceWithUnsupportedFeaturesTestPerStageDescriptorSetFeaturesNV);
	addFunctionCase(testGroup, "external_format_resolve_features_android", createDeviceWithUnsupportedFeaturesTestExternalFormatResolveFeaturesANDROID);
	addFunctionCase(testGroup, "cuda_kernel_launch_features_nv", createDeviceWithUnsupportedFeaturesTestCudaKernelLaunchFeaturesNV);
	addFunctionCase(testGroup, "scheduling_controls_features_arm", createDeviceWithUnsupportedFeaturesTestSchedulingControlsFeaturesARM);
	addFunctionCase(testGroup, "relaxed_line_rasterization_features_img", createDeviceWithUnsupportedFeaturesTestRelaxedLineRasterizationFeaturesIMG);
	addFunctionCase(testGroup, "render_pass_striped_features_arm", createDeviceWithUnsupportedFeaturesTestRenderPassStripedFeaturesARM);
	addFunctionCase(testGroup, "shader_maximal_reconvergence_features_khr", createDeviceWithUnsupportedFeaturesTestShaderMaximalReconvergenceFeaturesKHR);
	addFunctionCase(testGroup, "shader_subgroup_rotate_features_khr", createDeviceWithUnsupportedFeaturesTestShaderSubgroupRotateFeaturesKHR);
	addFunctionCase(testGroup, "shader_expect_assume_features_khr", createDeviceWithUnsupportedFeaturesTestShaderExpectAssumeFeaturesKHR);
	addFunctionCase(testGroup, "shader_float_controls2_features_khr", createDeviceWithUnsupportedFeaturesTestShaderFloatControls2FeaturesKHR);
	addFunctionCase(testGroup, "dynamic_rendering_local_read_features_khr", createDeviceWithUnsupportedFeaturesTestDynamicRenderingLocalReadFeaturesKHR);
	addFunctionCase(testGroup, "shader_quad_control_features_khr", createDeviceWithUnsupportedFeaturesTestShaderQuadControlFeaturesKHR);
	addFunctionCase(testGroup, "shader_atomic_float16_vector_features_nv", createDeviceWithUnsupportedFeaturesTestShaderAtomicFloat16VectorFeaturesNV);
	addFunctionCase(testGroup, "map_memory_placed_features_ext", createDeviceWithUnsupportedFeaturesTestMapMemoryPlacedFeaturesEXT);
	addFunctionCase(testGroup, "raw_access_chains_features_nv", createDeviceWithUnsupportedFeaturesTestRawAccessChainsFeaturesNV);
	addFunctionCase(testGroup, "command_buffer_inheritance_features_nv", createDeviceWithUnsupportedFeaturesTestCommandBufferInheritanceFeaturesNV);
	addFunctionCase(testGroup, "image_alignment_control_features_mesa", createDeviceWithUnsupportedFeaturesTestImageAlignmentControlFeaturesMESA);
	addFunctionCase(testGroup, "shader_replicated_composites_features_ext", createDeviceWithUnsupportedFeaturesTestShaderReplicatedCompositesFeaturesEXT);
}

