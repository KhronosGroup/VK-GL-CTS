{	"access-new-vector-inside-if-condition.amber",												"access-new-vector-inside-if-condition",											"A shader that accesses a new vector within an if condition"						},
{	"always-discarding-function.amber",															"always-discarding-function",														"A fragment shader with an always discarding main function"							},
{	"always-false-if-in-do-while.amber",														"always-false-if-in-do-while",														"A fragment shader with an always false if."										},
{	"always-false-if-with-discard-return.amber",												"always-false-if-with-discard-return",												"A fragment shader with discard keyword and a return"								},
{	"arr-value-set-to-arr-value-squared.amber",													"arr-value-set-to-arr-value-squared",												"A fragment shader with an arr value set to itself squared"							},
{	"array-idx-multiplied-by-for-loop-idx.amber",												"array-idx-multiplied-by-for-loop-idx",												"A fragment shader with array index multiplied"										},
{	"assign-array-value-to-another-array.amber",												"assign-array-value-to-another-array",												"A fragment shader that assigns array values to other array"						},
{	"assign-array-value-to-another-array-2.amber",												"assign-array-value-to-another-array-2",											"A fragment shader that assigns array values to other array"						},
{	"barrier-in-loop-with-break.amber",															"barrier-in-loop-with-break",														"A compute shader with a barrier in a loop with a break"							},
{	"break-in-do-while-with-nested-if.amber",													"break-in-do-while-with-nested-if",													"A fragment shader with nested if"													},
{	"call-function-with-discard.amber",															"call-function-with-discard",														"Calls a function containing a discard"												},
{	"call-if-while-switch.amber",																"call-if-while-switch",																"A fragment shader with a call, if, while, switch"									},
{	"color-set-in-for-loop.amber",																"color-set-in-for-loop",															"A fragment shader with color set in for loop"										},
{	"color-write-in-loop.amber",																"color-write-in-loop",																"A fragment shader that writes to color in a loop"									},
{	"complex-nested-loops-and-call.amber",														"complex-nested-loops-and-call",													"A fragment shader with complex nested loops, breaks, etc."							},
{	"conditional-return-in-infinite-while.amber",												"conditional-return-in-infinite-while",												"A shader with conditional return inside an infinite loop"							},
{	"continue-and-merge.amber",																	"continue-and-merge",																"A fragment shader with two nested loops"											},
{	"control-flow-in-function.amber",															"control-flow-in-function",															"A fragment shader with a lot of control flow"										},
{	"control-flow-switch.amber",																"control-flow-switch",																"A fragment shader with somewhat complex control flow and a switch"					},
{	"cosh-return-inf-unused.amber",																"cosh-return-inf-unused",															"Cosh returns inf for one component which is never used"							},
{	"cov-analysis-reachable-from-many.amber",													"cov-analysis-reachable-from-many",													"A fragment shader that covers a specific LLVM analysis code path."					},
{	"cov-apfloat-acos-ldexp.amber",																"cov-apfloat-acos-ldexp",															"A fragment shader that covers a specific AP float code path."						},
{	"cov-apfloat-determinant.amber",															"cov-apfloat-determinant",															"A fragment shader that covers a specific arbitrary precision float usage."			},
{	"cov-apfloat-tanh.amber",																	"cov-apfloat-tanh",																	"A fragment shader that covers a specific arbitrary precision float usage."			},
{	"cov-basic-block-discard-in-function.amber",												"cov-basic-block-discard-in-function",												"A fragment shader that covers a specific basic block code path"					},
{	"cov-blockfrequency-several-for-loops.amber",												"cov-blockfrequency-several-for-loops",												"A fragment shader that covers a specific block frequency info code path."			},
{	"cov-branch-probability-identity-matrix.amber",												"cov-branch-probability-identity-matrix",											"A fragment shader that covers a specific branch propability path"					},
{	"cov-combine-and-or-xor-gt-lt.amber",														"cov-combine-and-or-xor-gt-lt",														"A fragment shader that covers a specific bitwise operator cobmining code path"		},
{	"cov-const-folding-ceil-vec4.amber",														"cov-const-folding-ceil-vec4",														"A fragment shader that covers a specific constant folding code path"				},
{	"cov-const-folding-clamp.amber",															"cov-const-folding-clamp",															"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-clamp-inside-while.amber",												"cov-const-folding-clamp-inside-while",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-const-folding-clamp-max.amber",														"cov-const-folding-clamp-max",														"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-clamp-min.amber",														"cov-const-folding-clamp-min",														"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-clamp-vs-original.amber",												"cov-const-folding-clamp-vs-original",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-const-folding-det-identity.amber",														"cov-const-folding-det-identity",													"A fragment shader that covers a specific const folding path"						},
{	"cov-const-folding-dot-condition-true.amber",												"cov-const-folding-dot-condition-true",												"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-dot-determinant.amber",													"cov-const-folding-dot-determinant",												"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-gte-const-first.amber",													"cov-const-folding-gte-const-first",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-const-folding-min-as-loop-range.amber",												"cov-const-folding-min-as-loop-range",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-const-folding-same-condition.amber",													"cov-const-folding-same-condition",													"A fragment shader that covers a specific constant folding code path"				},
{	"cov-const-folding-sinh-inf.amber",															"cov-const-folding-sinh-inf",														"A fragment shader that covers a specific const folding path"						},
{	"cov-const-folding-vector-shuffle.amber",													"cov-const-folding-vector-shuffle",													"A fragment shader that covers a specific const folding rule path."					},
{	"cov-constant-folding-atan-over-tanh.amber",												"cov-constant-folding-atan-over-tanh",												"A fragment shader that covers a specific constant folding code path."				},
{	"cov-constants-mix-uniform.amber",															"cov-constants-mix-uniform",														"A fragment shader that covers a specific constant handling path."					},
{	"cov-copy-prop-arrays-func-argument.amber",													"cov-copy-prop-arrays-func-argument",												"A fragment shader that covers a specific propagate array copy path."				},
{	"cov-copy-prop-arrays-no-stores.amber",														"cov-copy-prop-arrays-no-stores",													"A fragment shader that covers a specific propagate array copy path."				},
{	"cov-copy-prop-arrays-param-uniform.amber",													"cov-copy-prop-arrays-param-uniform",												"A fragment shader that covers a specific propagate array copy path."				},
{	"cov-dag-combiner-combine-casts-legalize-vector-types-xyz-swizzle-for-loop.amber",			"cov-dag-combiner-combine-casts-legalize-vector-types-xyz-swizzle-for-loop",		"Covers DAG combiner, cast combining and legalize vector types code paths"			},
{	"cov-dag-combiner-findmsb-loop.amber",														"cov-dag-combiner-findmsb-loop",													"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dag-combiner-increment-color.amber",													"cov-dag-combiner-increment-color",													"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dag-combiner-neg-div-pow2.amber",														"cov-dag-combiner-neg-div-pow2",													"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dag-combiner-same-cond-nested.amber",													"cov-dag-combiner-same-cond-nested",												"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dead-branch-func-return-arg.amber",													"cov-dead-branch-func-return-arg",													"A fragment shader that covers a specific dead branch elimination path"				},
{	"cov-dead-code-unreachable-merge.amber",													"cov-dead-code-unreachable-merge",													"A fragment shader that covers a specific dead code elimination path."				},
{	"cov-fold-and-in-for-loop-range.amber",														"cov-fold-and-in-for-loop-range",													"A fragment shader that covers a specific folding path"								},
{	"cov-fold-bitwise-and-zero.amber",															"cov-fold-bitwise-and-zero",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-bitwise-or-full-mask.amber",														"cov-fold-bitwise-or-full-mask",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-bitwise-xor.amber",																"cov-fold-bitwise-xor",																"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-logical-and-const-variable.amber",												"cov-fold-logical-and-const-variable",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-logical-and-constant.amber",														"cov-fold-logical-and-constant",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-logical-or-constant.amber",														"cov-fold-logical-or-constant",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-negate-min-int-value.amber",														"cov-fold-negate-min-int-value",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-negate-variable.amber",															"cov-fold-negate-variable",															"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-shift-gte32.amber",																"cov-fold-shift-gte32",																"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-shift-right-arithmetic.amber",													"cov-fold-shift-right-arithmetic",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-switch-udiv.amber",																"cov-fold-switch-udiv",																"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-clamp-cmp-const-first.amber",													"cov-folding-clamp-cmp-const-first",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-folding-merge-add-sub-uniform.amber",													"cov-folding-merge-add-sub-uniform",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-construct-extract.amber",												"cov-folding-rules-construct-extract",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-dot-extract.amber",														"cov-folding-rules-dot-extract",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-dot-no-extract.amber",													"cov-folding-rules-dot-no-extract",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-add-sub.amber",													"cov-folding-rules-merge-add-sub",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-div-mul.amber",													"cov-folding-rules-merge-div-mul",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-divs.amber",														"cov-folding-rules-merge-divs",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-mul-div.amber",													"cov-folding-rules-merge-mul-div",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-sub-add.amber",													"cov-folding-rules-merge-sub-add",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-sub-sub.amber",													"cov-folding-rules-merge-sub-sub",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-var-sub.amber",													"cov-folding-rules-merge-var-sub",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-mix-uniform-weight.amber",												"cov-folding-rules-mix-uniform-weight",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-negate-div.amber",														"cov-folding-rules-negate-div",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-negate-sub.amber",														"cov-folding-rules-negate-sub",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-redundant-mix.amber",													"cov-folding-rules-redundant-mix",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-shuffle-extract.amber",													"cov-folding-rules-shuffle-extract",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-shuffle-mix.amber",														"cov-folding-rules-shuffle-mix",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-split-vector-init.amber",												"cov-folding-rules-split-vector-init",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-vec-mix-uniform.amber",													"cov-folding-rules-vec-mix-uniform",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-if-conversion-identical-branches.amber",												"cov-if-conversion-identical-branches",												"A fragment shader that covers a specific if condition conversion path."			},
{	"cov-inc-inside-switch-and-for.amber",														"cov-inc-inside-switch-and-for",													"A fragment shader that covers a specific LLVM analysis code path."					},
{	"cov-increment-inside-clamp.amber",															"cov-increment-inside-clamp",														"A fragment shader that covers specific value tracking and simplification paths"	},
{	"cov-inline-pass-empty-block.amber",														"cov-inline-pass-empty-block",														"A fragment shader that covers a specific inlining optimization path."				},
{	"cov-inline-pass-nested-loops.amber",														"cov-inline-pass-nested-loops",														"A fragment shader that covers a specific inlining optimization path."				},
{	"cov-inline-pass-return-in-loop.amber",														"cov-inline-pass-return-in-loop",													"A fragment shader that covers a specific inlining optimization path."				},
{	"cov-inline-pass-unreachable-func.amber",													"cov-inline-pass-unreachable-func",													"A fragment shader that covers a specific inlining optimization path."				},
{	"cov-inst-combine-compares-while-modulo.amber",												"cov-inst-combine-compares-while-modulo",											"A fragment shader that covers a specific inst combine compares code path"			},
{	"cov-inst-peephole-optimizer-acosh.amber",													"cov-inst-peephole-optimizer-acosh",												"A fragment shader that covers a specific peephole optimizer code path"				},
{	"cov-inst-value-tracking-inversesqrt.amber",												"cov-inst-value-tracking-inversesqrt",												"A fragment shader that covers a specific value tracking path"						},
{	"cov-instr-emitter-pow-asinh.amber",														"cov-instr-emitter-pow-asinh",														"A fragment shader that covers a specific instruction emitter code path"			},
{	"cov-instruction-simplify-atanh-log-undefined.amber",										"cov-instruction-simplify-atanh-log-undefined",										"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-bit-shifting.amber",												"cov-instruction-simplify-bit-shifting",											"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-inclusive-or.amber",												"cov-instruction-simplify-inclusive-or",											"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-inst-combine-calls-for-compare-function-call-result.amber",		"cov-instruction-simplify-inst-combine-calls-for-compare-function-call-result",		"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-mod-acos-undefined.amber",										"cov-instruction-simplify-mod-acos-undefined",										"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-mod-sqrt-undefined.amber",										"cov-instruction-simplify-mod-sqrt-undefined",										"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-sqrt.amber",														"cov-instruction-simplify-sqrt",													"A fragment shader that covers a specific instruction simplify code path"			},
{	"cov-instructions-first-value-phi.amber",													"cov-instructions-first-value-phi",													"A fragment shader that covers a specific instructions code path"					},
{	"cov-intervalmap-set-stop.amber",															"cov-intervalmap-set-stop",															"A fragment shader that covers a specific interval map code path."					},
{	"cov-ir-builder-constant-fold-inst-combine-calls-value-tracking-findmsb-incr-if.amber",		"cov-ir-builder-constant-fold-inst-combine-calls-value-tracking-findmsb-incr-if",	"Covers IR builder, constant fold, inst combine calls and value tracking code paths"},
{	"cov-irbuilder-matrix-cell-uniform.amber",													"cov-irbuilder-matrix-cell-uniform",												"A fragment shader that covers a specific IR builder path."							},
{	"cov-liveinterval-different-dest.amber",													"cov-liveinterval-different-dest",													"A fragment shader that covers a specific live interval code path."					},
{	"cov-loop-findmsb-findlsb.amber",															"cov-loop-findmsb-findlsb",															"A fragment shader that covers specific simplification and value tracking paths"	},
{	"cov-machinevaluetype-one-iter-loop.amber",													"cov-machinevaluetype-one-iter-loop",												"A fragment shader that covers a specific machine value type code path"				},
{	"cov-max-clamp-same-minval.amber",															"cov-max-clamp-same-minval",														"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-mem-pass-sum-struct-members.amber",													"cov-mem-pass-sum-struct-members",													"A fragment shader that covers a specific mem pass code path."						},
{	"cov-mem-pass-unused-component.amber",														"cov-mem-pass-unused-component",													"A fragment shader that covers a specific mem pass code path."						},
{	"cov-merge-return-condition-twice.amber",													"cov-merge-return-condition-twice",													"A fragment shader that covers a specific return merge path."						},
{	"cov-modf-integer-to-private.amber",														"cov-modf-integer-to-private",														"A fragment shader that covers a specific private to local path."					},
{	"cov-optimize-phis-for.amber",																"cov-optimize-phis-for",															"A fragment shader that cover specific optimize phis code paths"					},
{	"cov-optimize-phis-for-for-do-while-if-if.amber",											"cov-optimize-phis-for-for-do-while-if-if",											"A fragment shader that covers a specific optimize PHIs code path"					},
{	"cov-pattern-match-signum.amber",															"cov-pattern-match-signum",															"A fragment shader that covers a specific pattern matching path."					},
{	"cov-pattern-match-single-bit.amber",														"cov-pattern-match-single-bit",														"A fragment shader that covers a specific pattern matching path."					},
{	"cov-peephole-optimizer-target-instr-info-for-if-if-if.amber",								"cov-peephole-optimizer-target-instr-info-for-if-if-if",							"Covers peephole optimizer and instr info code paths"								},
{	"cov-reduce-load-replace-extract.amber",													"cov-reduce-load-replace-extract",													"A fragment shader that covers a specific load size reduction path."				},
{	"cov-replace-copy-object.amber",															"cov-replace-copy-object",															"A fragment shader that covers a specific shader simplification path."				},
{	"cov-scaled-number-nested-loops.amber",														"cov-scaled-number-nested-loops",													"A fragment shader that covers a specific scaled number code path."					},
{	"cov-selection-dag-assign-back-and-forth.amber",											"cov-selection-dag-assign-back-and-forth",											"A fragment shader that covers a specific selection DAG code path"					},
{	"cov-selection-dag-lt-gt.amber",															"cov-selection-dag-lt-gt",															"A fragment shader that covers a specific selection DAG code path"					},
{	"cov-selection-dag-same-cond-twice.amber",													"cov-selection-dag-same-cond-twice",												"A fragment shader that covers a specific selection DAG code path"					},
{	"cov-set-vector-cos-fragcoord.amber",														"cov-set-vector-cos-fragcoord",														"A fragment shader that covers a specific set vector code path."					},
{	"cov-simplification-unused-struct.amber",													"cov-simplification-unused-struct",													"A fragment shader that covers a specific shader simplification path."				},
{	"cov-simplification-while-inside-for.amber",												"cov-simplification-while-inside-for",												"A fragment shader that covers a specific code simplification path."				},
{	"cov-simplify-clamp-max-itself.amber",														"cov-simplify-clamp-max-itself",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-component-uniform-idx.amber",													"cov-simplify-component-uniform-idx",												"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-div-by-uint-one.amber",														"cov-simplify-div-by-uint-one",														"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-ldexp-exponent-zero.amber",													"cov-simplify-ldexp-exponent-zero",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-mul-identity.amber",															"cov-simplify-mul-identity",														"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-not-less-than-neg.amber",														"cov-simplify-not-less-than-neg",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-select-fragcoord.amber",														"cov-simplify-select-fragcoord",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-sign-cosh.amber",																"cov-simplify-sign-cosh",															"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-simplify-smoothstep-undef.amber",														"cov-simplify-smoothstep-undef",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-single-block-elim-self-assign.amber",													"cov-single-block-elim-self-assign",												"A fragment shader that covers a specific single block elimination path."			},
{	"cov-single-store-elim-assume-store.amber",													"cov-single-store-elim-assume-store",												"A fragment shader that covers a specific single store elimination path."			},
{	"cov-ssa-rewrite-case-with-default.amber",													"cov-ssa-rewrite-case-with-default",												"A fragment shader that covers a specific SSA rewrite path."						},
{	"cov-target-lowering-dfdx-cos.amber",														"cov-target-lowering-dfdx-cos",														"A fragment shader that covers a specific target lowering code path."				},
{	"cov-target-lowering-inst-combine-compares-struct-array-clamp-function-cal.amber",			"cov-target-lowering-inst-combine-compares-struct-array-clamp-function-cal",		"Covers target lowering and compare combining code paths"							},
{	"cov-types-return-in-main-never-hit.amber",													"cov-types-return-in-main-never-hit",												"A fragment shader that covers a specific types optimization path."					},
{	"cov-val-cfg-case-fallthrough.amber",														"cov-val-cfg-case-fallthrough",														"A fragment shader that covers a specific shader validation path."					},
{	"cov-value-inst-combine-select-value-tracking-flip-bits.amber",								"cov-value-inst-combine-select-value-tracking-flip-bits",							"Covers value, inst combine select and value tracking code paths"					},
{	"cov-value-tracking-apint-inst-combine-simplify-one-mod-loop-iterator.amber",				"cov-value-tracking-apint-inst-combine-simplify-one-mod-loop-iterator",				"A fragment shader that calculates modulo of constant one with a loop iterator"		},
{	"cov-value-tracking-const-dfdy.amber",														"cov-value-tracking-const-dfdy",													"A fragment shader that covers a specific value tracking code path"					},
{	"cov-value-tracking-constant-fold-refraction-dfxd-determinant.amber",						"cov-value-tracking-constant-fold-refraction-dfxd-determinant",						"A fragment shader that calculates refraction with certain values"					},
{	"cov-value-tracking-inclusive-or.amber",													"cov-value-tracking-inclusive-or",													"A fragment shader that covers a specific value tracking path"						},
{	"cov-value-tracking-known-nonzero.amber",													"cov-value-tracking-known-nonzero",													"A fragment shader that covers a specific value tracking path"						},
{	"cov-value-tracking-max-uintbitstofloat.amber",												"cov-value-tracking-max-uintbitstofloat",											"A fragment shader that covers a specific value tracking path"						},
{	"cov-value-tracking-selection-dag-negation-clamp-loop.amber",								"cov-value-tracking-selection-dag-negation-clamp-loop",								"A fragment shader that calculates negation of clamped loop iterator values"		},
{	"cov-value-tracking-uniform-incident.amber",												"cov-value-tracking-uniform-incident",												"A fragment shader that covers a specific value tracking code path"					},
{	"cov-vector-dce-inc-unused-comp.amber",														"cov-vector-dce-inc-unused-comp",													"A fragment shader that covers a specific vector DCE path."							},
{	"cov-vector-dce-unused-component.amber",													"cov-vector-dce-unused-component",													"A fragment shader that covers a specific vector DCE path."							},
{	"cov-vector-log2-cosh.amber",																"cov-vector-log2-cosh",																"A fragment shader that covers a specific vector log2 and cosh code path."			},
{	"cov-wrap-op-kill-for-loop.amber",															"cov-wrap-op-kill-for-loop",														"A fragment shader that covers a specific OpKill wrapping code path"				},
{	"cov-wrap-op-kill-two-branches.amber",														"cov-wrap-op-kill-two-branches",													"A fragment shader that covers a specific OpKill wrapping path."					},
{	"create-color-in-do-while-for-loop.amber",													"create-color-in-do-while-for-loop",												"A fragment shader that creates the color inside two loops"							},
{	"dead-barriers-in-loops.amber",																"dead-barriers-in-loops",															"A compute shader with dead barriers"												},
{	"dead-struct-init.amber",																	"dead-struct-init",																	"A fragment shader that uses struct initializers"									},
{	"disc-and-add-in-func-in-loop.amber",														"disc-and-add-in-func-in-loop",														"A fragment shader with discard and add in function in loop"						},
{	"discard-continue-return.amber",															"discard-continue-return",															"A fragment shader with a discard, continue, and return"							},
{	"discard-in-array-manipulating-loop.amber",													"discard-in-array-manipulating-loop",												"An array-manipulating fragment shader with a discard"								},
{	"discard-in-loop.amber",																	"discard-in-loop",																	"A shader with a discard in a loop"													},
{	"discard-in-loop-in-function.amber",														"discard-in-loop-in-function",														"A shader with a discard nested in a loop in a function"							},
{	"discards-in-control-flow.amber",															"discards-in-control-flow",															"A fragment shader with discards in loops and conditionals"							},
{	"do-while-false-loops.amber",																"do-while-false-loops",																"Code wrapped in nested single iteration loops"										},
{	"do-while-loop-in-conditionals.amber",														"do-while-loop-in-conditionals",													"A fragment shader with do-while loop in conditional nest"							},
{	"do-while-with-always-true-if.amber",														"do-while-with-always-true-if",														"A fragment shader with a do while that always returns"								},
{	"do-while-with-if-condition.amber",															"do-while-with-if-condition",														"A fragment shader that has nested if condition in do while"						},
{	"early-return-and-barrier.amber",															"early-return-and-barrier",															"A compute shader with an early return and a barrier"								},
{	"find-msb-from-lsb.amber",																	"find-msb-from-lsb",																"A fragment shader that finds MSB from LSB"											},
{	"for-condition-always-false.amber",															"for-condition-always-false",														"A fragment shader that uses a for loop with condition always false"				},
{	"for-loop-with-return.amber",																"for-loop-with-return",																"A fragment shader with a for loop that loops only once"							},
{	"for-with-ifs-and-return.amber",															"for-with-ifs-and-return",															"A fragment shader with two ifs and return/continue inside a for loop"				},
{	"frag-coord-func-call-and-ifs.amber",														"frag-coord-func-call-and-ifs",														"A fragment shader with many uses of gl_FragCoord"									},
{	"fragcoord-control-flow.amber",																"fragcoord-control-flow",															"A fragment shader that uses FragCoord and somewhat complex control flow"			},
{	"fragcoord-control-flow-2.amber",															"fragcoord-control-flow-2",															"A fragment shader that uses FragCoord and somewhat complex control flow"			},
{	"function-with-float-comparison.amber",														"function-with-float-comparison",													"A fragment shader that compares a float and a coordinate"							},
{	"function-with-uniform-return.amber",														"function-with-uniform-return",														"A fragment shader with uniform value as a return"									},
{	"global-array-loops.amber",																	"global-array-loops",																"A loop that writes then reads a global array"										},
{	"if-and-switch.amber",																		"if-and-switch",																	"A fragment shader with a switch and some data flow"								},
{	"increment-value-in-nested-for-loop.amber",													"increment-value-in-nested-for-loop",												"A frag. shader that increments a value in nested for loop"							},
{	"injection-switch-as-comparison.amber",														"injection-switch-as-comparison",													"A fragment shader with uniform comparison in loop"									},
{	"int-mat2-struct.amber",																	"int-mat2-struct",																	"Fragment shader using (int, mat2) struct"											},
{	"loop-call-discard.amber",																	"loop-call-discard",																"A fragment shader with nested loops and a function call"							},
{	"loop-dead-if-loop.amber",																	"loop-dead-if-loop",																"A fragment shader with a loop, dead if, and a loop"								},
{	"loop-nested-ifs.amber",																	"loop-nested-ifs",																	"A fragment shader with a for loop containing nested ifs"							},
{	"loops-breaks-returns.amber",																"loops-breaks-returns",																"A compute shader with loops, breaks, returns"										},
{	"loops-ifs-continues-call.amber",															"loops-ifs-continues-call",															"A fragment shader with nested control flow and a call"								},
{	"mat-array-deep-control-flow.amber",														"mat-array-deep-control-flow",														"A fragment shader that uses an array of matrices and has deep control flow"		},
{	"mat-array-distance.amber",																	"mat-array-distance",																"A fragment shader that uses an array of matrices and distance"						},
{	"mat-mul-in-loop.amber",																	"mat-mul-in-loop",																	"Shader with matrix multiplication in loop"											},
{	"matrices-and-return-in-loop.amber",														"matrices-and-return-in-loop",														"A fragment shader with matrices and a return in a loop"							},
{	"max-mix-conditional-discard.amber",														"max-mix-conditional-discard",														"A fragment shader with an expression used in two discard guards"					},
{	"mix-floor-add.amber",																		"mix-floor-add",																	"A fragment shader with mix, uintBitsToFloat, and floor"							},
{	"modf-gl-color.amber",																		"modf-gl-color",																	"A fragment shader with modf of gl color"											},
{	"modf-temp-modf-color.amber",																"modf-temp-modf-color",																"A fragment shader that calls modf twice, once with color"							},
{	"nested-for-break-mat-color.amber",															"nested-for-break-mat-color",														"Two nested for loops modify a mat4 then writes red"								},
{	"nested-for-loops-switch-fallthrough.amber",												"nested-for-loops-switch-fallthrough",												"A fragment shader with few nested loops with fallthrough"							},
{	"nested-for-loops-with-return.amber",														"nested-for-loops-with-return",														"A fragment shader with two nested for loops with return"							},
{	"nested-ifs-and-return-in-for-loop.amber",													"nested-ifs-and-return-in-for-loop",												"A fragment shader with return in nest of ifs, inside loop"							},
{	"nested-loops-switch.amber",																"nested-loops-switch",																"A fragment shader with nested loops and a switch"									},
{	"nested-switch-break-discard.amber",														"nested-switch-break-discard",														"Nested switches with break and discard"											},
{	"one-sized-array.amber",																	"one-sized-array",																	"A fragment shader that uses a struct with an array of size one"					},
{	"pow-vec4.amber",																			"pow-vec4",																			"A fragment shader that uses pow"													},
{	"return-before-writing-wrong-color.amber",													"return-before-writing-wrong-color",												"A fragment shader with return before writing wrong color"							},
{	"return-float-from-while-loop.amber",														"return-float-from-while-loop",														"A fragment shader with unreachable while loop"										},
{	"return-in-loop-in-function.amber",															"return-in-loop-in-function",														"A fragment shader with early return from loop in function"							},
{	"return-inside-loop-in-function.amber",														"return-inside-loop-in-function",													"A fragment shader with return inside loop"											},
{	"returned-boolean-in-vector.amber",															"returned-boolean-in-vector",														"A fragment shader with returned boolean in vector"									},
{	"set-color-in-one-iteration-while-loop.amber",												"set-color-in-one-iteration-while-loop",											"A frag shader that sets the color in one iter while loop"							},
{	"similar-nested-ifs.amber",																	"similar-nested-ifs",																"A fragment shader with similar nested ifs and loops"								},
{	"smoothstep-after-loop.amber",																"smoothstep-after-loop",															"Fragment shader with 1-iteration loop and smoothstep"								},
{	"spv-access-chains.amber",																	"spv-access-chains",																"Equivalent shaders, one with extra access chains"									},
{	"spv-composite-phi.amber",																	"spv-composite-phi",																"Equivalent shaders, one with id used by OpPhi hidden in composite"					},
{	"spv-composite2.amber",																		"spv-composite2",																	"Equivalent shaders, one where an id is hidden inside a composite"					},
{	"spv-composites.amber",																		"spv-composites",																	"Equivalent shaders; one obfuscates an id via composites"							},
{	"spv-copy-object.amber",																	"spv-copy-object",																	"Equivalent shaders; one features extra OpCopyObject instructions"					},
{	"spv-dead-break-and-unroll.amber",															"spv-dead-break-and-unroll",														"Equivalent shaders, one with a dead break and an Unroll annotation"				},
{	"spv-declare-bvec4.amber",																	"spv-declare-bvec4",																"Equivalent shaders except one declares a bvec4"									},
{	"spv-double-branch-to-same-block.amber",													"spv-double-branch-to-same-block",													"Equivalent shaders, one with more complex branching"								},
{	"spv-double-branch-to-same-block2.amber",													"spv-double-branch-to-same-block2",													"Equivalent shaders, one with more complex branching"								},
{	"spv-double-branch-to-same-block3.amber",													"spv-double-branch-to-same-block3",													"Equivalent shaders, one with more complex branching"								},
{	"spv-load-from-frag-color.amber",															"spv-load-from-frag-color",															"Equivalent shaders, one with extra access chains and load"							},
{	"spv-null-in-phi-and-unroll.amber",															"spv-null-in-phi-and-unroll",														"Equivalent shaders, one that uses null for 0 and an Unroll annotation"				},
{	"stable-binarysearch-tree-with-loop-read-write-global.amber",								"stable-binarysearch-tree-with-loop-read-write-global",								"A pair of fragment shaders that both render red"									},
{	"stable-colorgrid-modulo-injected-conditional-true.amber",									"stable-colorgrid-modulo-injected-conditional-true",								"A fragment shader with an always true conditional"									},
{	"stable-colorgrid-modulo-true-conditional-simple-loop.amber",								"stable-colorgrid-modulo-true-conditional-simple-loop",								"A fragment shader with conditional and simple loop"								},
{	"stable-colorgrid-modulo-vec3-values-from-matrix.amber",									"stable-colorgrid-modulo-vec3-values-from-matrix",									"A fragment shader with vec3 values set from matrix4x2"								},
{	"stable-quicksort-for-loop-with-injection.amber",											"stable-quicksort-for-loop-with-injection",											"A fragment shader with a for loop containing injection"							},
{	"stable-quicksort-if-false-else-return.amber",												"stable-quicksort-if-false-else-return",											"A fragment shader with an always false if statement"								},
{	"stable-quicksort-max-value-as-index.amber",												"stable-quicksort-max-value-as-index",												"A fragment shader with greater of two values as index"								},
{	"stable-rects-vec4-clamp-conditional-min-mix.amber",										"stable-rects-vec4-clamp-conditional-min-mix",										"A fragment shader with min-mix in always false conditional"						},
{	"struct-and-unreachable-infinite-loop.amber",												"struct-and-unreachable-infinite-loop",												"Fragment shader with struct and unreachable infinite loop"							},
{	"struct-array-data-as-loop-iterator.amber",													"struct-array-data-as-loop-iterator",												"A fragment shader that uses struct array data for loop iterator value"				},
{	"struct-controlled-loop.amber",																"struct-controlled-loop",															"Shader with loop controlled by struct"												},
{	"struct-used-as-temporary.amber",															"struct-used-as-temporary",															"A fragment shader that uses a temporary struct variable"							},
{	"switch-case-with-undefined-expression.amber",												"switch-case-with-undefined-expression",											"A fragment shader with undefined expression"										},
{	"switch-if-discard.amber",																	"switch-if-discard",																"A fragment shader with a switch, if, and discard"									},
{	"switch-inside-while-always-return.amber",													"switch-inside-while-always-return",												"A fragment shader with a switch inside while always return"						},
{	"switch-loop-switch-if.amber",																"switch-loop-switch-if",															"A nested switch-loop-switch"														},
{	"switch-with-empty-if-false.amber",															"switch-with-empty-if-false",														"A fragment shader with always false if in switch statement"						},
{	"switch-with-fall-through-cases.amber",														"switch-with-fall-through-cases",													"A fragment shader with switch cases that fall through"								},
{	"swizzle-struct-init-min.amber",															"swizzle-struct-init-min",															"A fragment shader that uses vector swizzles, struct initializers, and min"			},
{	"transpose-rectangular-matrix.amber",														"transpose-rectangular-matrix",														"Fragment shader that uses 'transpose'"												},
{	"two-2-iteration-loops.amber",																"two-2-iteration-loops",															"Fragment shader with pair of outer loops"											},
{	"two-for-loops-with-barrier-function.amber",												"two-for-loops-with-barrier-function",												"A compute shader with two barrier functions"										},
{	"two-loops-mat-add.amber",																	"two-loops-mat-add",																"A fragment shader with two for loops over a global matrix"							},
{	"two-loops-matrix.amber",																	"two-loops-matrix",																	"A fragment shader with two loops and some matrices"								},
{	"two-loops-set-struct.amber",																"two-loops-set-struct",																"A fragment shader with two loops that write to a struct"							},
{	"two-loops-with-break.amber",																"two-loops-with-break",																"A fragment shader with two loops with breaks"										},
{	"two-nested-do-whiles.amber",																"two-nested-do-whiles",																"A fragment shader with nested do while"											},
{	"two-nested-for-loops-with-returns.amber",													"two-nested-for-loops-with-returns",												"A compute shader with two nested for loops"										},
{	"two-nested-infinite-loops-discard.amber",													"two-nested-infinite-loops-discard",												"A fragment shader with an always false if function"								},
{	"undefined-integer-in-function.amber",														"undefined-integer-in-function",													"A fragment shader with nested do while and undefined int"							},
{	"uninit-element-cast-in-loop.amber",														"uninit-element-cast-in-loop",														"A fragment shader with uninitialized element cast in loop"							},
{	"uninitialized-var-decrement-and-add.amber",												"uninitialized-var-decrement-and-add",												"A fragment shader that uses an uninitialized variable"								},
{	"undefined-assign-in-infinite-loop.amber",													"undefined-assign-in-infinite-loop",												"A fragment shader with uninitialized read in infinite loop"						},
{	"unreachable-barrier-in-loops.amber",														"unreachable-barrier-in-loops",														"A compute shader with an unreachable barrier in a loop nest"						},
{	"unreachable-continue-statement.amber",														"unreachable-continue-statement",													"A fragment shader with unreachable continue statement"								},
{	"unreachable-discard-statement-in-if.amber",												"unreachable-discard-statement-in-if",												"A fragment shader with discard keyword and a return"								},
{	"unreachable-discard-statement.amber",														"unreachable-discard-statement",													"A fragment shader with unreachable discard statement"								},
{	"unreachable-loops.amber",																	"unreachable-loops",																"Fragment shader that writes red despite unreachable loops"							},
{	"unreachable-loops-in-switch.amber",														"unreachable-loops-in-switch",														"A fragment shader with unreachable loops in a switch"								},
{	"unreachable-return-in-loop.amber",															"unreachable-return-in-loop",														"A fragment shader with an unreachable return in a loop"							},
{	"unreachable-switch-case-with-discards.amber",												"unreachable-switch-case-with-discards",											"A shader with a switch statement containing unreachable discards"					},
{	"uv-value-comparison-as-boolean.amber",														"uv-value-comparison-as-boolean",													"A fragment shader with uv value comparison as boolean"								},
{	"vector-values-multiplied-by-fragcoord.amber",												"vector-values-multiplied-by-fragcoord",											"A shader that multiplies a vector by fragcoord"									},
{	"vectors-and-discard-in-function.amber",													"vectors-and-discard-in-function",													"A fragment shader that assigns vector values"										},
{	"while-function-always-false.amber",														"while-function-always-false",														"A fragment shader with an always false while function"								},
{	"while-inside-switch.amber",																"while-inside-switch",																"A fragment shader that uses a while loop inside a switch"							},
{	"write-before-break.amber",																	"write-before-break",																"Fragment shader that writes red before loop break"									},
{	"write-red-in-loop-nest.amber",																"write-red-in-loop-nest",															"A fragment shader that writes red in a nest of loops"								},
{	"wrong-color-in-always-false-if.amber",														"wrong-color-in-always-false-if",													"A fragment shader with wrong color write in false if"								},
