{	"access-new-vector-inside-if-condition.amber",												"access-new-vector-inside-if-condition",											"A shader that accesses a new vector within an if condition"						},
{	"always-discarding-function.amber",															"always-discarding-function",														"A fragment shader with an always discarding main function",						"VK_KHR_shader_terminate_invocation"},
{	"always-false-if-in-do-while.amber",														"always-false-if-in-do-while",														"A fragment shader with an always false if."										},
{	"always-false-if-with-discard-return.amber",												"always-false-if-with-discard-return",												"A fragment shader with discard keyword and a return",								"VK_KHR_shader_terminate_invocation"},
{	"arr-value-set-to-arr-value-squared.amber",													"arr-value-set-to-arr-value-squared",												"A fragment shader with an arr value set to itself squared"							},
{	"array-idx-multiplied-by-for-loop-idx.amber",												"array-idx-multiplied-by-for-loop-idx",												"A fragment shader with array index multiplied"										},
{	"assign-array-value-to-another-array.amber",												"assign-array-value-to-another-array",												"A fragment shader that assigns array values to other array"						},
{	"assign-array-value-to-another-array-2.amber",												"assign-array-value-to-another-array-2",											"A fragment shader that assigns array values to other array"						},
{	"barrier-in-loop-with-break.amber",															"barrier-in-loop-with-break",														"A compute shader with a barrier in a loop with a break"							},
{	"break-in-do-while-with-nested-if.amber",													"break-in-do-while-with-nested-if",													"A fragment shader with nested if"													},
{	"call-function-with-discard.amber",															"call-function-with-discard",														"Calls a function containing a discard",											"VK_KHR_shader_terminate_invocation"},
{	"call-if-while-switch.amber",																"call-if-while-switch",																"A fragment shader with a call, if, while, switch"									},
{	"color-set-in-for-loop.amber",																"color-set-in-for-loop",															"A fragment shader with color set in for loop"										},
{	"color-write-in-loop.amber",																"color-write-in-loop",																"A fragment shader that writes to color in a loop"									},
{	"complex-nested-loops-and-call.amber",														"complex-nested-loops-and-call",													"A fragment shader with complex nested loops, breaks, etc."	,						"VK_KHR_shader_terminate_invocation"},
{	"conditional-return-in-infinite-while.amber",												"conditional-return-in-infinite-while",												"A shader with conditional return inside an infinite loop"							},
{	"continue-and-merge.amber",																	"continue-and-merge",																"A fragment shader with two nested loops"											},
{	"control-flow-in-function.amber",															"control-flow-in-function",															"A fragment shader with a lot of control flow"										},
{	"control-flow-switch.amber",																"control-flow-switch",																"A fragment shader with somewhat complex control flow and a switch"					},
{	"cosh-return-inf-unused.amber",																"cosh-return-inf-unused",															"Cosh returns inf for one component which is never used",							"VK_KHR_shader_terminate_invocation"},
{	"cov-access-array-dot.amber",																"cov-access-array-dot",																"Covers instruction combine casting, combine shifting and DAG code paths"			},
{	"cov-analysis-reachable-from-many.amber",													"cov-analysis-reachable-from-many",													"A fragment shader that covers a specific LLVM analysis code path."	,				"VK_KHR_shader_terminate_invocation"},
{	"cov-and-even-numbers-from-fragcoord.amber",												"cov-and-even-numbers-from-fragcoord",												"A fragment shader that covers specific NIR code paths"								},
{	"cov-apfloat-acos-ldexp.amber",																"cov-apfloat-acos-ldexp",															"A fragment shader that covers a specific AP float code path."						},
{	"cov-apfloat-determinant.amber",															"cov-apfloat-determinant",															"A fragment shader that covers a specific arbitrary precision float usage."			},
{	"cov-apfloat-mix-nan.amber",																"cov-apfloat-mix-nan",																"A fragment shader that covers a specific floating point code path"					},
{	"cov-apfloat-mod-zero.amber",																"cov-apfloat-mod-zero",																"A fragment shader that covers a specific floating point code path"					},
{	"cov-apfloat-module-small-number.amber",													"cov-apfloat-module-small-number",													"A fragment shader that covers a specific floating point code path"					},
{	"cov-apfloat-negative-step-func.amber",														"cov-apfloat-negative-step-func",													"A fragment shader that covers a specific floating point code path"					},
{	"cov-apfloat-sinh-negative-log2.amber",														"cov-apfloat-sinh-negative-log2",													"A fragment shader that covers a specific floating point code path"					},
{	"cov-apfloat-tanh.amber",																	"cov-apfloat-tanh",																	"A fragment shader that covers a specific arbitrary precision float usage."			},
{	"cov-apfloat-undefined-matrix-mul.amber",													"cov-apfloat-undefined-matrix-mul",													"A fragment shader that covers a specific floating point code path"					},
{	"cov-apfloat-determinant-for-if.amber",														"cov-apfloat-determinant-for-if",													"A fragment shader that covers a specific APFloat code path"						},
{	"cov-apfloat-reflect-denorm.amber",															"cov-apfloat-reflect-denorm",														"A fragment shader that covers a specific floating point code path"					},
{	"cov-apfloat-unpackunorm-loop.amber",														"cov-apfloat-unpackunorm-loop",														"A fragment shader that covers a specific floating point code path"					},
{	"cov-array-accesses-clamp.amber",															"cov-array-accesses-clamp",															"A fragment shader that covers a specific inst combine select path"					},
{	"cov-array-cast-bool-float-div-by-zero-no-effect.amber",									"cov-array-cast-bool-float-div-by-zero-no-effect",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-array-copies-loops-with-limiters.amber",												"cov-array-copies-loops-with-limiters",												"A fragment shader that covers specific NIR code paths"								},
{	"cov-array-set-element-condition-negative-modulus.amber",									"cov-array-set-element-condition-negative-modulus",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-asin-undefined-smoothstep.amber",														"cov-asin-undefined-smoothstep",													"A fragment shader that covers a specific instruction simplify code path"			},
{	"cov-atan-trunc-vec4.amber",																"cov-atan-trunc-vec4",																"A fragment shader that covers specific NIR code paths"								},
{	"cov-basic-block-discard-in-function.amber",												"cov-basic-block-discard-in-function",												"A fragment shader that covers a specific basic block code path",					"VK_KHR_shader_terminate_invocation"},
{	"cov-bitcount.amber",																		"cov-bitcount",																		"Covers specific inst combine add sub and inst combine simplify demanded code paths"},
{	"cov-bitfieldExtract-undefined.amber",														"cov-bitfieldExtract-undefined",													"A fragment shader that covers a specific constant fold code path"					},
{	"cov-bitfieldinsert-undefined.amber",														"cov-bitfieldinsert-undefined",														"A fragment shader that covers a specific instruction simplify code path"			},
{	"cov-bitfieldreverse-left-shift-findmsb.amber",												"cov-bitfieldreverse-left-shift-findmsb",											"Covers specific DAG combiner and legalize vector ops code paths"					},
{	"cov-bitfieldreverse-loop-limit-underflow.amber",											"cov-bitfieldreverse-loop-limit-underflow",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-bitwise-and-variable-and-its-negation.amber",											"cov-bitwise-and-variable-and-its-negation",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-bitwise-inverse-uniform-condition.amber",												"cov-bitwise-inverse-uniform-condition",											"A fragment shader that covers specific BRW code paths"								},
{	"cov-bitwise-or-uniform-zero-tenth-bit-loop-limit-find-lsb.amber",							"cov-bitwise-or-uniform-zero-tenth-bit-loop-limit-find-lsb",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-bitwise-shift-right-always-select-one.amber",											"cov-bitwise-shift-right-always-select-one",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-bitwise-shift-right-full-bits-no-effect-clamp.amber",									"cov-bitwise-shift-right-full-bits-no-effect-clamp",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-blockfrequency-several-for-loops.amber",												"cov-blockfrequency-several-for-loops",												"A fragment shader that covers a specific block frequency info code path."			},
{	"cov-branch-probability-identity-matrix.amber",												"cov-branch-probability-identity-matrix",											"A fragment shader that covers a specific branch propability path"					},
{	"cov-cast-float-to-int-and-back.amber",														"cov-cast-float-to-int-and-back",													"A fragment shader that covers specific NIR code paths"								},
{	"cov-clamp-loop-limit-increment-float-array.amber",											"cov-clamp-loop-limit-increment-float-array",										"A fragment shader that covers specific NIR code paths"								},
{	"cov-clamp-lower-limit-from-always-false.amber",											"cov-clamp-lower-limit-from-always-false",											"A fragment shader that covers specific BRW code paths"								},
{	"cov-clamp-min-bitcount-uniform.amber",														"cov-clamp-min-bitcount-uniform",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-clamp-value-and-min-select-uniform.amber",												"cov-clamp-value-and-min-select-uniform",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-clamp-vector-component-condition-using-matrix.amber",									"cov-clamp-vector-component-condition-using-matrix",								"A fragment shader that covers specific patch optimization code paths"				},
{	"cov-clamp-vector-element-ceil-negative.amber",												"cov-clamp-vector-element-ceil-negative",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-clamp-vector-variable-negative-offset.amber",											"cov-clamp-vector-variable-negative-offset",										"A fragment shader that covers specific NIR code paths"								},
{	"cov-clear-yz-inside-condition.amber",														"cov-clear-yz-inside-condition",													"A fragment shader that covers specific NIR code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-color-output-undefined-in-unexecuted-branch.amber",									"cov-color-output-undefined-in-unexecuted-branch",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-combine-and-or-xor-gt-lt.amber",														"cov-combine-and-or-xor-gt-lt",														"A fragment shader that covers a specific bitwise operator cobmining code path"		},
{	"cov-condition-bitfield-extract-integer.amber",												"cov-condition-bitfield-extract-integer",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-condition-clamp-min-from-uniform-never-larger.amber",									"cov-condition-clamp-min-from-uniform-never-larger",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-condition-increment-zero-to-one-divide-by-two.amber",									"cov-condition-increment-zero-to-one-divide-by-two",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-condition-loop-index-bitwise-not.amber",												"cov-condition-loop-index-bitwise-not",												"A fragment shader that covers specific BRW code paths"								},
{	"cov-condition-matrix-determinant-uniform.amber",											"cov-condition-matrix-determinant-uniform",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-conditional-discard-inside-loop.amber",												"cov-conditional-discard-inside-loop",												"A fragment shader that covers specific NIR code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-conditions-empty-blocks-index-array-one-divided-by-findlsb.amber",						"cov-conditions-empty-blocks-index-array-one-divided-by-findlsb",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-const-folding-bitfieldinsert-div-one.amber",											"cov-const-folding-bitfieldinsert-div-one",											"A fragment shader that covers a specific const folding path"						},
{	"cov-color-overwrite-identity-matrix-multiply.amber",										"cov-color-overwrite-identity-matrix-multiply",										"A fragment shader that covers a specific DAG code paths"							},
{	"cov-const-folding-ceil-vec4.amber",														"cov-const-folding-ceil-vec4",														"A fragment shader that covers a specific constant folding code path"				},
{	"cov-const-folding-clamp.amber",															"cov-const-folding-clamp",															"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-clamp-inside-while.amber",												"cov-const-folding-clamp-inside-while",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-const-folding-clamp-max.amber",														"cov-const-folding-clamp-max",														"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-clamp-min.amber",														"cov-const-folding-clamp-min",														"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-clamp-vs-original.amber",												"cov-const-folding-clamp-vs-original",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-const-folding-det-identity.amber",														"cov-const-folding-det-identity",													"A fragment shader that covers a specific const folding path"						},
{	"cov-const-folding-dot-condition-true.amber",												"cov-const-folding-dot-condition-true",												"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-dot-determinant.amber",													"cov-const-folding-dot-determinant",												"A fragment shader that covers a specific const folding rule path."					},
{	"cov-const-folding-gte-const-first.amber",													"cov-const-folding-gte-const-first",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-const-folding-min-as-loop-range.amber",												"cov-const-folding-min-as-loop-range",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-const-folding-mod-one-one-lte.amber",													"cov-const-folding-mod-one-one-lte",												"A fragment shader that covers a specific const folding path"						},
{	"cov-const-folding-pow-large-exp.amber",													"cov-const-folding-pow-large-exp",													"A fragment shader that covers a specific const folding path"						},
{	"cov-const-folding-same-condition.amber",													"cov-const-folding-same-condition",													"A fragment shader that covers a specific constant folding code path"				},
{	"cov-const-folding-sinh-inf.amber",															"cov-const-folding-sinh-inf",														"A fragment shader that covers a specific const folding path"						},
{	"cov-const-folding-vector-shuffle.amber",													"cov-const-folding-vector-shuffle",													"A fragment shader that covers a specific const folding rule path."					},
{	"cov-constant-folding-atan-over-tanh.amber",												"cov-constant-folding-atan-over-tanh",												"A fragment shader that covers a specific constant folding code path."				},
{	"cov-constants-combine-add-sub.amber",														"cov-constants-combine-add-sub",													"A fragment shader that covers a specific constants and add/sub combining path"		},
{	"cov-constants-mix-uniform.amber",															"cov-constants-mix-uniform",														"A fragment shader that covers a specific constant handling path."					},
{	"cov-continue-break-discard-return-in-loop.amber",											"cov-continue-break-discard-return-in-loop",										"A fragment shader that covers specific NIR code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-copy-array-elements-except-first-nested-loop-replace-identical-values.amber",			"cov-copy-array-elements-except-first-nested-loop-replace-identical-values",		"A fragment shader that covers specific LLVM code paths"							},
{	"cov-copy-output-color-swizzle-array-indexing.amber",										"cov-copy-output-color-swizzle-array-indexing",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-copy-prop-arrays-func-argument.amber",													"cov-copy-prop-arrays-func-argument",												"A fragment shader that covers a specific propagate array copy path."				},
{	"cov-copy-prop-arrays-no-stores.amber",														"cov-copy-prop-arrays-no-stores",													"A fragment shader that covers a specific propagate array copy path."				},
{	"cov-copy-prop-arrays-param-uniform.amber",													"cov-copy-prop-arrays-param-uniform",												"A fragment shader that covers a specific propagate array copy path."				},
{	"cov-cosh-clamped-to-one.amber",															"cov-cosh-clamped-to-one",															"A fragment shader that covers specific NIR code paths"								},
{	"cov-cumulate-loops-unreachable.amber",														"cov-cumulate-loops-unreachable",													"A fragment shader that covers specific NIR code paths"								},
{	"cov-dag-combiner-clamp-undefined-access-array.amber",										"cov-dag-combiner-clamp-undefined-access-array",									"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dag-combiner-combine-casts-legalize-vector-types-xyz-swizzle-for-loop.amber",			"cov-dag-combiner-combine-casts-legalize-vector-types-xyz-swizzle-for-loop",		"Covers DAG combiner, cast combining and legalize vector types code paths"			},
{	"cov-dag-combiner-findmsb-loop.amber",														"cov-dag-combiner-findmsb-loop",													"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dag-combiner-increment-color.amber",													"cov-dag-combiner-increment-color",													"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dag-combiner-glf_color.amber",															"cov-dag-combiner-glf_color",														"A fragment shader that covers specific dag combiner code path"						},
{	"cov-dag-combiner-loop-bitfieldreverse.amber",												"cov-dag-combiner-loop-bitfieldreverse",											"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dag-combiner-neg-div-pow2.amber",														"cov-dag-combiner-neg-div-pow2",													"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dag-combiner-same-cond-nested.amber",													"cov-dag-combiner-same-cond-nested",												"A fragment shader that covers a specific DAG combiner code path"					},
{	"cov-dead-branch-func-return-arg.amber",													"cov-dead-branch-func-return-arg",													"A fragment shader that covers a specific dead branch elimination path"				},
{	"cov-dead-code-unreachable-merge.amber",													"cov-dead-code-unreachable-merge",													"A fragment shader that covers a specific dead code elimination path."				},
{	"cov-decrement-vector-elements-clamp-index.amber",											"cov-decrement-vector-elements-clamp-index",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-derivative-uniform-vector-global-loop-count.amber",									"cov-derivative-uniform-vector-global-loop-count",									"A fragment shader that covers specific BRW code paths"								},
{	"cov-descending-loop-index-temporary-array.amber",											"cov-descending-loop-index-temporary-array",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-descending-loop-min-max-always-zero.amber",											"cov-descending-loop-min-max-always-zero",											"A fragment shader that covers specific BRW code paths"								},
{	"cov-determinant-uninitialized-matrix-never-chosen.amber",									"cov-determinant-uninitialized-matrix-never-chosen",								"A fragment shader that covers specific BRW code paths"								},
{	"cov-dfdx-dfdy-after-nested-loops.amber",													"cov-dfdx-dfdy-after-nested-loops",													"A fragment shader that covers specific BRW code paths"								},
{	"cov-discard-condition-loop-same-condition-again.amber",									"cov-discard-condition-loop-same-condition-again",									"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-divide-matrix-transpose-by-constant.amber",											"cov-divide-matrix-transpose-by-constant",											"A fragment shader that covers specific VTN code path"								},
{	"cov-do-while-loop-until-uniform-lt-itself.amber",											"cov-do-while-loop-until-uniform-lt-itself",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-do-while-negative-iterator-nested-loops-increment-array-element.amber",				"cov-do-while-negative-iterator-nested-loops-increment-array-element",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-do-while-switch-case-bitcount-findmsb.amber",											"cov-do-while-switch-case-bitcount-findmsb",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-double-if-true-in-loop.amber",															"cov-double-if-true-in-loop",														"A fragment shader that covers specific NIR code paths"								},
{	"cov-double-negation-fragcoord-cast-ivec2-bitwise-and.amber",								"cov-double-negation-fragcoord-cast-ivec2-bitwise-and",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-dummy-function-loop-array-element-increment-never-read.amber",							"cov-dummy-function-loop-array-element-increment-never-read",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-empty-loop-minus-one-modulo-variable-one.amber",										"cov-empty-loop-minus-one-modulo-variable-one",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-enable-bits-pixel-location-negate-not-equal-one.amber",								"cov-enable-bits-pixel-location-negate-not-equal-one",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-exp2-two.amber",																		"cov-exp2-two",																		"A fragment shader that covers specific NIR code paths"								},
{	"cov-extend-uniform-vec2-to-vec3-matrix-multiply.amber",									"cov-extend-uniform-vec2-to-vec3-matrix-multiply",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-find-msb-input-either-zero-or-minus-one.amber",										"cov-find-msb-input-either-zero-or-minus-one",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-findlsb-division-by-zero.amber",														"cov-findlsb-division-by-zero",														"A fragment shader that covers a specific instruction simplify code path"			},
{	"cov-float-array-init-pow.amber",															"cov-float-array-init-pow",															"A fragment shader that covers specific arith builder code path"					},
{	"cov-fold-and-in-for-loop-range.amber",														"cov-fold-and-in-for-loop-range",													"A fragment shader that covers a specific folding path"								},
{	"cov-fold-bitwise-and-zero.amber",															"cov-fold-bitwise-and-zero",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-bitwise-or-full-mask.amber",														"cov-fold-bitwise-or-full-mask",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-bitwise-xor.amber",																"cov-fold-bitwise-xor",																"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-logical-and-const-variable.amber",												"cov-fold-logical-and-const-variable",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-logical-and-constant.amber",														"cov-fold-logical-and-constant",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-logical-or-constant.amber",														"cov-fold-logical-or-constant",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-negate-min-int-value.amber",														"cov-fold-negate-min-int-value",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-negate-variable.amber",															"cov-fold-negate-variable",															"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-shift-gte32.amber",																"cov-fold-shift-gte32",																"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-shift-right-arithmetic.amber",													"cov-fold-shift-right-arithmetic",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-fold-switch-udiv.amber",																"cov-fold-switch-udiv",																"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-clamp-cmp-const-first.amber",													"cov-folding-clamp-cmp-const-first",												"A fragment shader that covers a specific constant folding path"					},
{	"cov-folding-merge-add-sub-uniform.amber",													"cov-folding-merge-add-sub-uniform",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-construct-extract.amber",												"cov-folding-rules-construct-extract",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-dot-extract.amber",														"cov-folding-rules-dot-extract",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-dot-no-extract.amber",													"cov-folding-rules-dot-no-extract",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-add-sub.amber",													"cov-folding-rules-merge-add-sub",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-div-mul.amber",													"cov-folding-rules-merge-div-mul",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-divs.amber",														"cov-folding-rules-merge-divs",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-mul-div.amber",													"cov-folding-rules-merge-mul-div",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-sub-add.amber",													"cov-folding-rules-merge-sub-add",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-sub-sub.amber",													"cov-folding-rules-merge-sub-sub",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-merge-var-sub.amber",													"cov-folding-rules-merge-var-sub",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-mix-uniform-weight.amber",												"cov-folding-rules-mix-uniform-weight",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-negate-div.amber",														"cov-folding-rules-negate-div",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-negate-sub.amber",														"cov-folding-rules-negate-sub",														"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-redundant-mix.amber",													"cov-folding-rules-redundant-mix",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-shuffle-extract.amber",													"cov-folding-rules-shuffle-extract",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-shuffle-mix.amber",														"cov-folding-rules-shuffle-mix",													"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-split-vector-init.amber",												"cov-folding-rules-split-vector-init",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-folding-rules-vec-mix-uniform.amber",													"cov-folding-rules-vec-mix-uniform",												"A fragment shader that covers a specific instruction folding path."				},
{	"cov-for-array-initializing-modulo.amber",													"cov-for-array-initializing-modulo",												"A fragment shader that covers a specific inst combine compares code path"			},
{	"cov-for-loop-condition-one-shift-right-integer-comparison-break.amber",					"cov-for-loop-condition-one-shift-right-integer-comparison-break",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-for-loop-min-increment-array-element.amber",											"cov-for-loop-min-increment-array-element",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-for-loop-start-negative-increment-variable.amber",										"cov-for-loop-start-negative-increment-variable",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-for-loop-struct-as-iterator.amber",													"cov-for-loop-struct-as-iterator",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-for-switch-fallthrough.amber",															"cov-for-switch-fallthrough",														"A fragment shader that covers a specific inst combine and or xor code path"		},
{	"cov-fract-asin-undefined-never-used.amber",												"cov-fract-asin-undefined-never-used",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fract-smoothstep-undefined.amber",														"cov-fract-smoothstep-undefined",													"A fragment shader that covers a specific APFloat code path"						},
{	"cov-fract-trunc-always-zero.amber",														"cov-fract-trunc-always-zero",														"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fragcood-multiple-conditions-function-loop-global-counter.amber",						"cov-fragcood-multiple-conditions-function-loop-global-counter",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fragcoord-and-one-or-same-value.amber",												"cov-fragcoord-and-one-or-same-value",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fragcoord-bitwise-and-loop-reduce-value-index-array.amber",							"cov-fragcoord-bitwise-and-loop-reduce-value-index-array",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fragcoord-bitwise-not.amber",															"cov-fragcoord-bitwise-not",														"A fragment shader that covers specific BRW code paths"								},
{	"cov-fragcoord-clamp-array-access.amber",													"cov-fragcoord-clamp-array-access",													"A fragment shader that covers a specific instruction simplify path"				},
{	"cov-fragcoord-conditions-never-return-index-array-using-uniform.amber",					"cov-fragcoord-conditions-never-return-index-array-using-uniform",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fragcoord-integer-loop-reduce-to-range.amber",											"cov-fragcoord-integer-loop-reduce-to-range",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fragcoord-loop-limit-negative-decrease-sum-first-iteration.amber",						"cov-fragcoord-loop-limit-negative-decrease-sum-first-iteration",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fragcoord-multiple-conditions-function-global-loop-counter-simplified.amber",			"cov-fragcoord-multiple-conditions-function-global-loop-counter-simplified",		"A fragment shader that covers specific LLVM code paths"							},
{	"cov-fragcoord-multiply.amber",																"cov-fragcoord-multiply",															"A fragment shader that covers specific NIR code paths"								},
{	"cov-fragcoord-select-always-one.amber",													"cov-fragcoord-select-always-one",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-always-return-negative-bitfield-extract.amber",								"cov-function-always-return-negative-bitfield-extract",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-argument-uniform-float-loop-never-return.amber",								"cov-function-argument-uniform-float-loop-never-return",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-check-argument-one-always-return-minus-one.amber",							"cov-function-check-argument-one-always-return-minus-one",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-clamp-min-identical-shift-right.amber",										"cov-function-clamp-min-identical-shift-right",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-call-twice-clamp-global-variable.amber",										"cov-function-call-twice-clamp-global-variable",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-divide-argument-until-lt-one.amber",											"cov-function-divide-argument-until-lt-one",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-find-lsb-ivec2-one.amber",													"cov-function-find-lsb-ivec2-one",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-fragcoord-condition-always-return.amber",										"cov-function-fragcoord-condition-always-return",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-global-loop-counter-sample-texture.amber",									"cov-function-global-loop-counter-sample-texture",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-global-variables-fragcoord-condition-call-twice.amber",						"cov-function-global-variables-fragcoord-condition-call-twice",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-index-array-redundant-clamps.amber",											"cov-function-index-array-redundant-clamps",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-infinite-loop-always-return.amber",											"cov-function-infinite-loop-always-return",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-infinite-loop-return-identical-condition.amber",								"cov-function-infinite-loop-return-identical-condition",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-large-array-max-clamp.amber",													"cov-function-large-array-max-clamp",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-large-loop-always-return-first-iteration.amber",								"cov-function-large-loop-always-return-first-iteration",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-large-loop-break-argument-lte-global-loop-bound.amber",						"cov-function-large-loop-break-argument-lte-global-loop-bound",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-check-determinant-zero-return-vector.amber",								"cov-function-loop-check-determinant-zero-return-vector",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-clamp-no-effect.amber",													"cov-function-loop-clamp-no-effect",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-condition-constant-array-always-false.amber",							"cov-function-loop-condition-constant-array-always-false",							"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-function-loop-condition-uniform-shift-right.amber",									"cov-function-loop-condition-uniform-shift-right",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-condition-variable-less-than-min-itself.amber",							"cov-function-loop-condition-variable-less-than-min-itself",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-copy-array-elements-based-on-arguments.amber",							"cov-function-loop-copy-array-elements-based-on-arguments",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-modify-ivec-components-infinite-loop-never-executed.amber",				"cov-function-loop-modify-ivec-components-infinite-loop-never-executed",			"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-same-conditions-multiple-times-struct-array.amber",						"cov-function-loop-same-conditions-multiple-times-struct-array",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-switch-increment-array-element-return.amber",							"cov-function-loop-switch-increment-array-element-return",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-max-all-ones-select-always-true.amber",										"cov-function-max-all-ones-select-always-true",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-min-identical-integer-division-multiplication.amber",							"cov-function-min-identical-integer-division-multiplication",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-min-integer-large-shift-unused.amber",										"cov-function-min-integer-large-shift-unused",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loop-variable-multiplied-unused.amber",										"cov-function-loop-variable-multiplied-unused",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-loops-vector-mul-matrix-never-executed.amber",								"cov-function-loops-vector-mul-matrix-never-executed",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-multiple-loops-compare-integer-return.amber",									"cov-function-multiple-loops-compare-integer-return",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-nested-do-whiles-looped-once.amber",											"cov-function-nested-do-whiles-looped-once",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-nested-loops-break-early-never-discard.amber",								"cov-function-nested-loops-break-early-never-discard",								"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-function-nested-loops-limit-uniform-xor-uniform.amber",								"cov-function-nested-loops-limit-uniform-xor-uniform",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-set-struct-field-zero-loop-reset-first-element.amber",						"cov-function-set-struct-field-zero-loop-reset-first-element",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-parameter-zero-divided-by-uniform.amber",										"cov-function-parameter-zero-divided-by-uniform",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-round-unpack-half-2x16.amber",												"cov-function-round-unpack-half-2x16",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-struct-int-array-loop-check-element.amber",									"cov-function-struct-int-array-loop-check-element",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-switch-case-constant-clamp-transpose-identity-matrices.amber",				"cov-function-switch-case-constant-clamp-transpose-identity-matrices",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-trivial-switch-case.amber",													"cov-function-trivial-switch-case",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-two-loops-limit-using-arguments-array-element-copies.amber",					"cov-function-two-loops-limit-using-arguments-array-element-copies",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-undefined-shift-left-index-array-with-return-value.amber",					"cov-function-undefined-shift-left-index-array-with-return-value",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-unpack-unorm-2x16-one.amber",													"cov-function-unpack-unorm-2x16-one",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-unused-argument-single-loop-iteration-icrement-global-counter.amber",			"cov-function-unused-argument-single-loop-iteration-icrement-global-counter",		"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-variable-plus-one-minus-one.amber",											"cov-function-variable-plus-one-minus-one",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-function-vec2-never-discard.amber",													"cov-function-vec2-never-discard",													"A fragment shader that covers specific BRW code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-function-with-nested-loops-called-from-nested-loops.amber",							"cov-function-with-nested-loops-called-from-nested-loops",							"A fragment shader that covers specific BRW code paths"								},
{	"cov-global-loop-bound-true-logical-or.amber",												"cov-global-loop-bound-true-logical-or",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-global-loop-count-array-struct-field-set-int-array-element.amber",						"cov-global-loop-count-array-struct-field-set-int-array-element",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-global-loop-counter-accumulate-integer-condition-large-array-elements.amber",			"cov-global-loop-counter-accumulate-integer-condition-large-array-elements",		"A fragment shader that covers specific LLVM code paths"							},
{	"cov-global-loop-counter-exhaust-calling-function-twice.amber",								"cov-global-loop-counter-exhaust-calling-function-twice",							"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-global-loop-counter-findlsb-zero.amber",												"cov-global-loop-counter-findlsb-zero",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-global-loop-counter-float-accumulate-matrix.amber",									"cov-global-loop-counter-float-accumulate-matrix",									"A fragment shader that covers specific BRW code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-global-loop-counter-for-loop-function-call-inside-never-called.amber",					"cov-global-loop-counter-for-loop-function-call-inside-never-called",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-global-loop-counter-main-function-call.amber",											"cov-global-loop-counter-main-function-call",										"A fragment shader that covers specific NIR code paths"								},
{	"cov-global-loop-counter-multiply-one-minus.amber",											"cov-global-loop-counter-multiply-one-minus",										"A fragment shader that covers specific BRW code paths"								},
{	"cov-global-loop-counter-read-past-matrix-size-never-executed.amber",						"cov-global-loop-counter-read-past-matrix-size-never-executed",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-global-loop-counter-select-one-or-zero-never-greater-than-one.amber",					"cov-global-loop-counter-select-one-or-zero-never-greater-than-one",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-global-loop-counter-set-array-element-once-index-using-findmsb.amber",					"cov-global-loop-counter-set-array-element-once-index-using-findmsb",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-global-loop-counter-squared-comparison.amber",											"cov-global-loop-counter-squared-comparison",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-global-loop-counter-texture-sample-loop-condition-set-array-element.amber",			"cov-global-loop-counter-texture-sample-loop-condition-set-array-element",			"A fragment shader that covers specific LLVM code paths"							},
{	"cov-if-conversion-identical-branches.amber",												"cov-if-conversion-identical-branches",												"A fragment shader that covers a specific if condition conversion path."			},
{	"cov-if-switch-fallthrough.amber",															"cov-if-switch-fallthrough",														"A fragment shader that covers a specific inst combine and or xor code path"		},
{	"cov-if-true-continue.amber",																"cov-if-true-continue",																"A fragment shader that covers specific NIR code paths"								},
{	"cov-if-true-discard-in-do-while-never-reached.amber",										"cov-if-true-discard-in-do-while-never-reached",									"A fragment shader that covers specific NIR code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-if-true-float-bits-to-int-one.amber",													"cov-if-true-float-bits-to-int-one",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-inc-array-element-loop-lsb.amber",														"cov-inc-array-element-loop-lsb",													"A fragment shader that covers a specific SSCP path"								},
{	"cov-inc-inside-switch-and-for.amber",														"cov-inc-inside-switch-and-for",													"A fragment shader that covers a specific LLVM analysis code path."					},
{	"cov-increment-array-element-in-loop.amber",												"cov-increment-array-element-in-loop",												"A fragment shader that covers specific NIR code paths"								},
{	"cov-increment-array-element-usub-borrow.amber",											"cov-increment-array-element-usub-borrow",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-increment-float-in-loop-abs.amber",													"cov-increment-float-in-loop-abs",													"A fragment shader that covers specific BRW code paths"								},
{	"cov-increment-global-counter-loop-function.amber",											"cov-increment-global-counter-loop-function",										"A fragment shader that covers specific NIR code paths"								},
{	"cov-increment-inside-clamp.amber",															"cov-increment-inside-clamp",														"A fragment shader that covers specific value tracking and simplification paths"	},
{	"cov-increment-int-loop-counter-mod-array.amber",											"cov-increment-int-loop-counter-mod-array",											"A fragment shader that covers specific BRW code paths"								},
{	"cov-increment-multiple-integers.amber",													"cov-increment-multiple-integers",													"A fragment shader that covers specific NIR code paths"								},
{	"cov-increment-one-array-element-check-index-from-fragcoord.amber",							"cov-increment-one-array-element-check-index-from-fragcoord",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-increment-vector-array-matrix-element.amber",											"cov-increment-vector-array-matrix-element",										"A fragment shader that covers specific NIR code paths"								},
{	"cov-increment-vector-component-with-matrix-copy.amber",									"cov-increment-vector-component-with-matrix-copy",									"A fragment shader that covers specific NIR code paths"								},
{	"cov-increment-vector-function-call-conditional.amber",										"cov-increment-vector-function-call-conditional",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-index-array-using-uniform-bitwise-or-one.amber",										"cov-index-array-using-uniform-bitwise-or-one",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-initialize-integer-array-variable-divided-by-itself.amber",							"cov-initialize-integer-array-variable-divided-by-itself",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-inline-pass-empty-block.amber",														"cov-inline-pass-empty-block",														"A fragment shader that covers a specific inlining optimization path."				},
{	"cov-inline-pass-nested-loops.amber",														"cov-inline-pass-nested-loops",														"A fragment shader that covers a specific inlining optimization path."				},
{	"cov-inline-pass-return-in-loop.amber",														"cov-inline-pass-return-in-loop",													"A fragment shader that covers a specific inlining optimization path."				},
{	"cov-inline-pass-unreachable-func.amber",													"cov-inline-pass-unreachable-func",													"A fragment shader that covers a specific inlining optimization path."				},
{	"cov-inst-combine-add-sub-ldexp.amber",														"cov-inst-combine-add-sub-ldexp",													"A fragment shader that covers specific inst combine add sub code paths"			},
{	"cov-inst-combine-add-sub-pre-increase.amber",												"cov-inst-combine-add-sub-pre-increase",											"Covers specific inst combine add sub and dag combiner code paths"					},
{	"cov-inst-combine-compares-while-modulo.amber",												"cov-inst-combine-compares-while-modulo",											"A fragment shader that covers a specific inst combine compares code path"			},
{	"cov-inst-combine-shifts-left-shift-for.amber",												"cov-inst-combine-shifts-left-shift-for",											"A fragment shader that covers a specific inst combine shifts code path"			},
{	"cov-inst-peephole-optimizer-acosh.amber",													"cov-inst-peephole-optimizer-acosh",												"A fragment shader that covers a specific peephole optimizer code path",			"VK_KHR_shader_terminate_invocation"},
{	"cov-inst-value-tracking-inversesqrt.amber",												"cov-inst-value-tracking-inversesqrt",												"A fragment shader that covers a specific value tracking path"						},
{	"cov-instr-emitter-pow-asinh.amber",														"cov-instr-emitter-pow-asinh",														"A fragment shader that covers a specific instruction emitter code path"			},
{	"cov-instruction-simplify-atanh-log-undefined.amber",										"cov-instruction-simplify-atanh-log-undefined",										"A fragment shader that covers a specific instruction simplification path",			"VK_KHR_shader_float_controls"},
{	"cov-instruction-simplify-bit-shifting.amber",												"cov-instruction-simplify-bit-shifting",											"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-inclusive-or.amber",												"cov-instruction-simplify-inclusive-or",											"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-inst-combine-calls-for-compare-function-call-result.amber",		"cov-instruction-simplify-inst-combine-calls-for-compare-function-call-result",		"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-mod-acos-undefined.amber",										"cov-instruction-simplify-mod-acos-undefined",										"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-mod-sqrt-undefined.amber",										"cov-instruction-simplify-mod-sqrt-undefined",										"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-instruction-simplify-sqrt.amber",														"cov-instruction-simplify-sqrt",													"A fragment shader that covers a specific instruction simplify code path"			},
{	"cov-instructions-first-value-phi.amber",													"cov-instructions-first-value-phi",													"A fragment shader that covers a specific instructions code path",					"VK_KHR_shader_terminate_invocation"},
{	"cov-inst-combine-add-sub-determinant.amber",												"cov-inst-combine-add-sub-determinant",												"A fragment shader that covers a specific inst combine add sub code path"			},
{	"cov-inst-combine-add-sub-increase-negative.amber",											"cov-inst-combine-add-sub-increase-negative",										"A fragment shader that covers a specific inst combine add sub code path"			},
{	"cov-inst-combine-add-sub-neg-func-arg.amber",												"cov-inst-combine-add-sub-neg-func-arg",											"A fragment shader that covers a specific add/sub combining path"					},
{	"cov-inst-combine-and-or-xor-pack-unpack.amber",											"cov-inst-combine-and-or-xor-pack-unpack",											"A fragment shader that covers a specific inst combine and or xor code path"		},
{	"cov-inst-combine-and-or-xor-switch.amber",													"cov-inst-combine-and-or-xor-switch",												"A fragment shader that covers a specific inst combine and or xor code path"		},
{	"cov-inst-combine-and-or-xor-xor-add.amber",												"cov-inst-combine-and-or-xor-xor-add",												"A fragment shader that covers a specific inst combine and or xor code path"		},
{	"cov-inst-combine-compares-combine-select-uaddcarry.amber",									"cov-inst-combine-compares-combine-select-uaddcarry",								"Covers a specific instruction combine compares and combine select code paths"		},
{	"cov-inst-combine-compares-isnan.amber",													"cov-inst-combine-compares-isnan",													"A fragment shader that covers a specific instruction combine compare code path"	},
{	"cov-inst-combine-compares-ldexp.amber",													"cov-inst-combine-compares-ldexp",													"A fragment shader that covers a specific instruction combine compares code path"	},
{	"cov-inst-combine-compares-ternary-vector-access.amber",									"cov-inst-combine-compares-ternary-vector-access",									"A fragment shader that covers a specific instruction combine compare code path"	},
{	"cov-inst-combine-shifts-bitfield-bitcount.amber",											"cov-inst-combine-shifts-bitfield-bitcount",										"A fragment shader that covers a specific instruction combine shifts code path"		},
{	"cov-inst-combine-shifts-mix-mix-clamp.amber",												"cov-inst-combine-shifts-mix-mix-clamp",											"A fragment shader that covers a specific instruction combine shifts code path"		},
{	"cov-instr-info-det-mat-min.amber",															"cov-instr-info-det-mat-min",														"A fragment shader that covers a specific instr info code path"						},
{	"cov-instructions-for-if-less-than-equal.amber",											"cov-instructions-for-if-less-than-equal",											"Covers specific instruction simplify and combine compare code paths"				},
{	"cov-inst-combine-and-or-xor-for-bitfieldinsert.amber",										"cov-inst-combine-and-or-xor-for-bitfieldinsert",									"A fragment shader that covers a specific inst combine and or xor code path"		},
{	"cov-inst-combine-compares-pre-increment-clamp.amber",										"cov-inst-combine-compares-pre-increment-clamp",									"A fragment shader that covers a specific inst combine compares code path"			},
{	"cov-inst-combine-mul-div-rem-if-undefined-divide-mix.amber",								"cov-inst-combine-mul-div-rem-if-undefined-divide-mix",								"A fragment shader that covers a specific inst combine mul div rem code path"		},
{	"cov-inst-combine-pack-unpack.amber",														"cov-inst-combine-pack-unpack",														"Covers specific combine shifts and combine simplify demanded code paths"			},
{	"cov-inst-combine-select-findlsb-uaddcarry.amber",											"cov-inst-combine-select-findlsb-uaddcarry",										"A fragment shader that covers a specific instruction combine select code path"		},
{	"cov-inst-combine-simplify-demanded-pack-unpack.amber",										"cov-inst-combine-simplify-demanded-pack-unpack",									"Covers a specific instruction combine simplify demanded code path"					},
{	"cov-inst-combine-simplify-demanded-packsnorm-unpackunorm.amber",							"cov-inst-combine-simplify-demanded-packsnorm-unpackunorm",							"Covers a specific instruction combine simplify demanded code path"					},
{	"cov-inst-combine-simplify-demanded-switch-or-xor.amber",									"cov-inst-combine-simplify-demanded-switch-or-xor",									"A fragment shader that covers a specific inst combine simplify demanded path"		},
{	"cov-inst-combine-vector-ops-asin.amber",													"cov-inst-combine-vector-ops-asin",													"A fragment shader that covers specific inst combine vector ops code paths"			},
{	"cov-int-div-round-to-zero.amber",															"cov-int-div-round-to-zero",														"A fragment shader that covers specific fast idiv code path"						},
{	"cov-int-full-bits-divide-by-two-loop.amber",												"cov-int-full-bits-divide-by-two-loop",												"A fragment shader that covers specific BRW code paths"								},
{	"cov-int-initialize-from-multiple-large-arrays.amber",										"cov-int-initialize-from-multiple-large-arrays",									"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-integer-constant-mod-variable-increased-condition-array-element.amber",				"cov-integer-constant-mod-variable-increased-condition-array-element",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-integer-minus-one-increased-before-indexing-array.amber",								"cov-integer-minus-one-increased-before-indexing-array",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-integer-modulo-negative.amber",														"cov-integer-modulo-negative",														"A fragment shader that covers specific instruction combining code paths"			},
{	"cov-integer-variable-or-with-inversion.amber",												"cov-integer-variable-or-with-inversion",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-intervalmap-set-stop.amber",															"cov-intervalmap-set-stop",															"A fragment shader that covers a specific interval map code path."					},
{	"cov-ir-builder-constant-fold-inst-combine-calls-value-tracking-findmsb-incr-if.amber",		"cov-ir-builder-constant-fold-inst-combine-calls-value-tracking-findmsb-incr-if",	"Covers IR builder, constant fold, inst combine calls and value tracking code paths"},
{	"cov-irbuilder-matrix-cell-uniform.amber",													"cov-irbuilder-matrix-cell-uniform",												"A fragment shader that covers a specific IR builder path."							},
{	"cov-isnan-asinh-clamp-always-zero.amber",													"cov-isnan-asinh-clamp-always-zero",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-ivec-from-uniform-float-shift-right-add-components.amber",								"cov-ivec-from-uniform-float-shift-right-add-components",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-ivec-shift-right-by-large-number.amber",												"cov-ivec-shift-right-by-large-number",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-large-for-loop-exit-early-set-iterator-array-element.amber",							"cov-large-for-loop-exit-early-set-iterator-array-element",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-large-int-array-nested-loops-set-ivec-index-component-sum.amber",						"cov-large-int-array-nested-loops-set-ivec-index-component-sum",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-large-loop-break-early-condition-iterator-divided.amber",								"cov-large-loop-break-early-condition-iterator-divided",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-large-loop-multiply-integer-by-uniform-one.amber",										"cov-large-loop-multiply-integer-by-uniform-one",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-large-number-of-false-conditions-return-discard-continue.amber",						"cov-large-number-of-false-conditions-return-discard-continue",						"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-ldexp-exponent-undefined-divided-fragcoord-never-executed.amber",						"cov-ldexp-exponent-undefined-divided-fragcoord-never-executed",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-ldexp-undefined-mat-vec-multiply.amber",												"cov-ldexp-undefined-mat-vec-multiply",												"Covers specific inst combine simplify demanded and inst combine shifts path"		},
{	"cov-left-shift-array-access.amber",														"cov-left-shift-array-access",														"A fragment shader that covers a specific inst combine shifts code path"			},
{	"cov-left-shift-right-shift-compare.amber",													"cov-left-shift-right-shift-compare",												"A fragment shader that covers a specific inst combine compares code path"			},
{	"cov-liveinterval-different-dest.amber",													"cov-liveinterval-different-dest",													"A fragment shader that covers a specific live interval code path."					},
{	"cov-loop-abs-multiply-offset.amber",														"cov-loop-abs-multiply-offset",														"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-array-element-bitfield-insert-undefined-never-read.amber",						"cov-loop-array-element-bitfield-insert-undefined-never-read",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-array-element-copy-index-clamp-sign.amber",										"cov-loop-array-element-copy-index-clamp-sign",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-array-index-decrement-never-negative.amber",										"cov-loop-array-index-decrement-never-negative",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-array-struct-field-index-array-with-uniforms.amber",								"cov-loop-array-struct-field-index-array-with-uniforms",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-break-after-first-iteration-set-array-element.amber",								"cov-loop-break-after-first-iteration-set-array-element",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-break-floor-nan-never-executed.amber",											"cov-loop-break-floor-nan-never-executed",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-break-fragcoord-x-empty-loop.amber",												"cov-loop-break-fragcoord-x-empty-loop",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-clamp-to-one-empty-condition.amber",												"cov-loop-clamp-to-one-empty-condition",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-condition-bitfield-extract-set-array-elements.amber",								"cov-loop-condition-bitfield-extract-set-array-elements",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-condition-clamp-vec-of-ones.amber",												"cov-loop-condition-clamp-vec-of-ones",												"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-condition-constant-struct-field-data.amber",										"cov-loop-condition-constant-struct-field-data",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-condition-divide-by-uniform-always-false.amber",									"cov-loop-condition-divide-by-uniform-always-false",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-condition-double-negate.amber",													"cov-loop-condition-double-negate",													"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-condition-filter-some-iterations-never-discard.amber",							"cov-loop-condition-filter-some-iterations-never-discard",							"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-loop-condition-increment-integer-fallback-global-counter.amber",						"cov-loop-condition-increment-integer-fallback-global-counter",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-condition-logical-or-never-iterated.amber",										"cov-loop-condition-logical-or-never-iterated",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-decrease-integer-never-break.amber",												"cov-loop-decrease-integer-never-break",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-construct-vec4-from-vec4-clamp-same-min-max.amber",								"cov-loop-construct-vec4-from-vec4-clamp-same-min-max",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-decrease-vector-components-assign-multiple-times.amber",							"cov-loop-decrease-vector-components-assign-multiple-times",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-decrease-vector-component-only-first-iteration.amber",							"cov-loop-decrease-vector-component-only-first-iteration",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-dfdx-constant-divide.amber",														"cov-loop-dfdx-constant-divide",													"A fragment shader that covers specific patch optimization code paths"				},
{	"cov-loop-exit-conditions-sampler-struct-integer-variable.amber",							"cov-loop-exit-conditions-sampler-struct-integer-variable",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-divide-uninitialized-vector-min-unused.amber",									"cov-loop-divide-uninitialized-vector-min-unused",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-find-lsb-eight-fragcoord-never-discard.amber",									"cov-loop-find-lsb-eight-fragcoord-never-discard",									"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-loop-findmsb-findlsb.amber",															"cov-loop-findmsb-findlsb",															"A fragment shader that covers specific simplification and value tracking paths"	},
{	"cov-loop-fragcoord-identical-condition.amber",												"cov-loop-fragcoord-identical-condition",											"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-loop-function-call-vector-matrix-multiplication.amber",								"cov-loop-function-call-vector-matrix-multiplication",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-global-counter-break-set-ivec-elements.amber",									"cov-loop-global-counter-break-set-ivec-elements",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-function-call-negative-argument.amber",											"cov-loop-function-call-negative-argument",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-global-counter-increment-iterator-select-uniform.amber",							"cov-loop-global-counter-increment-iterator-select-uniform",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-increase-iterator-condition-uniform-copy-array-elements.amber",					"cov-loop-increase-iterator-condition-uniform-copy-array-elements",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-increment-array-elements-clamp-index.amber",										"cov-loop-increment-array-elements-clamp-index",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-increment-array-index-array-usuborrow-feedback.amber",							"cov-loop-increment-array-index-array-usuborrow-feedback",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-increment-integer-findmsb-minus-uniform.amber",									"cov-loop-increment-integer-findmsb-minus-uniform",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-increment-integer-set-output-color-break.amber",									"cov-loop-increment-integer-set-output-color-break",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-increment-matrix-element-break-after-first-iteration.amber",						"cov-loop-increment-matrix-element-break-after-first-iteration",					"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-increment-or-divide-by-loop-index.amber",											"cov-loop-increment-or-divide-by-loop-index",										"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-index-array-max-negative-zero.amber",												"cov-loop-index-array-max-negative-zero",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-integer-half-minus-one.amber",													"cov-loop-integer-half-minus-one",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-iterator-bitwise-negate.amber",													"cov-loop-iterator-bitwise-negate",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-iterator-limit-xor-and-unifrom.amber",											"cov-loop-iterator-limit-xor-and-unifrom",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-iterator-plus-one-variable-outside-index-array.amber",							"cov-loop-iterator-plus-one-variable-outside-index-array",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-iterator-start-select-uniform-negative-integer.amber",							"cov-loop-iterator-start-select-uniform-negative-integer",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-large-array-index-clamp-negative-value.amber",									"cov-loop-large-array-index-clamp-negative-value",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-iterator-start-shift-left-right.amber",											"cov-loop-iterator-start-shift-left-right",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-limiter-min-findlsb.amber",														"cov-loop-limiter-min-findlsb",														"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-limiter-uniform-bitwise-and-one-always-break.amber",								"cov-loop-limiter-uniform-bitwise-and-one-always-break",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-logical-xor.amber",																"cov-loop-logical-xor",																"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-multiple-iterator-variables-copy-array-elements.amber",							"cov-loop-multiple-iterator-variables-copy-array-elements",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-never-iterated-constant-vector-condition.amber",									"cov-loop-never-iterated-constant-vector-condition",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-read-array-index-from-array-data.amber",											"cov-loop-read-array-index-from-array-data",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-max-divide-integer-by-ten.amber",													"cov-loop-max-divide-integer-by-ten",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-overwrite-sample-texture-as-color-output.amber",									"cov-loop-overwrite-sample-texture-as-color-output",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-min-max-clamp-increment-only-first-iteration.amber",								"cov-loop-min-max-clamp-increment-only-first-iteration",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-replace-output-color-restore-original.amber",										"cov-loop-replace-output-color-restore-original",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-returns-behind-true-and-false.amber",												"cov-loop-returns-behind-true-and-false",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-loop-sampled-texel-integer-counter.amber",												"cov-loop-sampled-texel-integer-counter",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-set-vector-components-pow-two.amber",												"cov-loop-set-vector-components-pow-two",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-start-fragcoord-while-iterates-once.amber",										"cov-loop-start-fragcoord-while-iterates-once",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-start-from-one-switch-case-invalid-color-never-executed.amber",					"cov-loop-start-from-one-switch-case-invalid-color-never-executed",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-start-from-one-switch-case-never-executed.amber",									"cov-loop-start-from-one-switch-case-never-executed",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-struct-array-field-set-value-self-dependency.amber",								"cov-loop-struct-array-field-set-value-self-dependency",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-switch-discard-never-hit.amber",													"cov-loop-switch-discard-never-hit",												"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-loop-two-iterators-increment-array-empty-do-while.amber",								"cov-loop-two-iterators-increment-array-empty-do-while",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-variable-less-than-itself.amber",													"cov-loop-variable-less-than-itself",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-loop-with-two-integers.amber",															"cov-loop-with-two-integers",														"A fragment shader that covers specific NIR code paths"								},
{	"cov-loops-and-conditions-fragcoord-always-false-floats-one.amber",							"cov-loops-and-conditions-fragcoord-always-false-floats-one",						"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-loops-same-code-outside-loop.amber",													"cov-loops-same-code-outside-loop",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-machine-scheduler-for-if-pow.amber",													"cov-machine-scheduler-for-if-pow",													"A fragment shader that covers a specific machine scheduler path",					"VK_KHR_shader_terminate_invocation"},
{	"cov-machine-basic-block-for-for-for-less-than.amber",										"cov-machine-basic-block-for-for-for-less-than",									"A fragment shader that covers a specific machine basic block code paths"			},
{	"cov-machinevaluetype-one-iter-loop.amber",													"cov-machinevaluetype-one-iter-loop",												"A fragment shader that covers a specific machine value type code path"				},
{	"cov-matching-conditions-break.amber",														"cov-matching-conditions-break",													"A fragment shader that covers specific NIR code paths"								},
{	"cov-matching-if-always-true-inside-loop.amber",											"cov-matching-if-always-true-inside-loop",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-matrix-double-transpose.amber",														"cov-matrix-double-transpose",														"A fragment shader that covers specific NIR code paths"								},
{	"cov-matrix-mult-round-even-asinh.amber",													"cov-matrix-mult-round-even-asinh",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-matrix-square-mul-with-vector.amber",													"cov-matrix-square-mul-with-vector",												"A fragment shader that covers specific NIR code paths"								},
{	"cov-max-clamp-same-minval.amber",															"cov-max-clamp-same-minval",														"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-max-min-less-than.amber",																"cov-max-min-less-than",															"A fragment shader that covers a specific inst combine select code path"			},
{	"cov-mem-pass-sum-struct-members.amber",													"cov-mem-pass-sum-struct-members",													"A fragment shader that covers a specific mem pass code path."						},
{	"cov-mem-pass-unused-component.amber",														"cov-mem-pass-unused-component",													"A fragment shader that covers a specific mem pass code path."						},
{	"cov-merge-return-condition-twice.amber",													"cov-merge-return-condition-twice",													"A fragment shader that covers a specific return merge path."						},
{	"cov-min-identical-uint-uniform.amber",														"cov-min-identical-uint-uniform",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-min-identical-uint-uniform-check-highest-bit.amber",									"cov-min-identical-uint-uniform-check-highest-bit",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-min-intbitstofloat-undefined-never-used.amber",										"cov-min-intbitstofloat-undefined-never-used",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-min-negative-constant-always-below-one.amber",											"cov-min-negative-constant-always-below-one",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-min-nested-loop-same-value-for-variables.amber",										"cov-min-nested-loop-same-value-for-variables",										"A fragment shader that covers specific NIR code paths"								},
{	"cov-min-vec2-transpose-mat2-identity.amber",												"cov-min-vec2-transpose-mat2-identity",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-missing-return-value-function-never-called.amber",										"cov-missing-return-value-function-never-called",									"A fragment shader that covers specific BRW code paths"								},
{	"cov-mix-uninitialized-float-never-selected.amber",											"cov-mix-uninitialized-float-never-selected",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-mix-uninitialized-vector-select-only-defined-data.amber",								"cov-mix-uninitialized-vector-select-only-defined-data",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-mod-acosh.amber",																		"cov-mod-acosh",																	"A fragment shader that calculates modulo of an acosh result"						},
{	"cov-mod-uint-bits-float.amber",															"cov-mod-uint-bits-float",															"A fragment shader that covers a specific APFloat path"								},
{	"cov-modf-clamp-for.amber",																	"cov-modf-clamp-for",																"A fragment shader that covers a specific live intervals code path"					},
{	"cov-modf-integer-to-private.amber",														"cov-modf-integer-to-private",														"A fragment shader that covers a specific private to local path."					},
{	"cov-modulo-zero-never-executed.amber",														"cov-modulo-zero-never-executed",													"A fragment shader that covers specific NIR code paths"								},
{	"cov-multiple-fragcoord-conditions-false-never-return-sample-texture.amber",				"cov-multiple-fragcoord-conditions-false-never-return-sample-texture",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-multiple-fragcoord-conditions-never-return-color-uninitialized.amber",					"cov-multiple-fragcoord-conditions-never-return-color-uninitialized",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-multiple-functions-global-never-change.amber",											"cov-multiple-functions-global-never-change",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-multiple-loops-same-condition-always-false-global-loop-counter.amber",					"cov-multiple-loops-same-condition-always-false-global-loop-counter",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-multiple-one-iteration-loops-global-counter-write-matrices.amber",						"cov-multiple-one-iteration-loops-global-counter-write-matrices",					"A fragment shader that covers specific BRW code paths"								},
{	"cov-negative-integer-bitwise-or-uniform-increment-loop.amber",								"cov-negative-integer-bitwise-or-uniform-increment-loop",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-functions-accumulate-global-matrix.amber",										"cov-nested-functions-accumulate-global-matrix",									"A fragment shader that covers specific NIR code paths"								},
{	"cov-nested-functions-compare-fragcood-length-zero-vector.amber",							"cov-nested-functions-compare-fragcood-length-zero-vector",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-functions-loop-assign-global-array-element.amber",								"cov-nested-functions-loop-assign-global-array-element",							"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-nested-functions-struct-arrays-vector-lengths.amber",									"cov-nested-functions-struct-arrays-vector-lengths",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-functions-vec4-array-element-argument.amber",									"cov-nested-functions-vec4-array-element-argument",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loop-continue-inner-copy-array-element.amber",									"cov-nested-loop-continue-inner-copy-array-element",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loop-decrease-vector-components.amber",											"cov-nested-loop-decrease-vector-components",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loop-initializer-value-increased-inside.amber",									"cov-nested-loop-initializer-value-increased-inside",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loop-large-array-index-using-vector-components.amber",							"cov-nested-loop-large-array-index-using-vector-components",						"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-nested-loop-not-greater-than-increment-array-element.amber",							"cov-nested-loop-not-greater-than-increment-array-element",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loop-undefined-smoothstep-never-executed.amber",								"cov-nested-loop-undefined-smoothstep-never-executed",								"A fragment shader that covers specific BRW code paths"								},
{	"cov-nested-loops-assign-vector-elements-from-matrix-no-negative-indexing.amber",			"cov-nested-loops-assign-vector-elements-from-matrix-no-negative-indexing",			"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-nested-loops-array-choose-red-last-iteration.amber",									"cov-nested-loops-array-choose-red-last-iteration",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-clamp-ivec-push-constant-increment-global-counter.amber",					"cov-nested-loops-clamp-ivec-push-constant-increment-global-counter",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-copy-array-elements-skip-first.amber",									"cov-nested-loops-copy-array-elements-skip-first",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-decrease-ivec-component.amber",											"cov-nested-loops-decrease-ivec-component",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-different-iteration-rates-function-copy-array-elements.amber",			"cov-nested-loops-different-iteration-rates-function-copy-array-elements",			"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-divide-integer-constant-always-zero.amber",								"cov-nested-loops-divide-integer-constant-always-zero",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-decrease-vector-component-by-matrix-element-global-loop-counter.amber",	"cov-nested-loops-decrease-vector-component-by-matrix-element-global-loop-counter",	"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-float-array-select-by-fragcoord.amber",									"cov-nested-loops-float-array-select-by-fragcoord",									"A fragment shader that covers specific BRW code paths"								},
{	"cov-nested-loops-float-bits-to-int-increment-array.amber",									"cov-nested-loops-float-bits-to-int-increment-array",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-fragcoord-conditions-empty-blocks.amber",									"cov-nested-loops-fragcoord-conditions-empty-blocks",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-fragcoord-never-return-descending-loop.amber",							"cov-nested-loops-fragcoord-never-return-descending-loop",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-global-counter-func-set-struct-field.amber",								"cov-nested-loops-global-counter-func-set-struct-field",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-global-counter-increment-single-element.amber",							"cov-nested-loops-global-counter-increment-single-element",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-global-loop-counter-do-while-accumulate-float.amber",						"cov-nested-loops-global-loop-counter-do-while-accumulate-float",					"A fragment shader that covers specific BRW code paths"								},
{	"cov-nested-loops-global-loop-counter-fragcoord-negative-always-false.amber",				"cov-nested-loops-global-loop-counter-fragcoord-negative-always-false",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-global-loop-counter-index-array-vec2.amber",								"cov-nested-loops-global-loop-counter-index-array-vec2",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-global-loop-counter-iterator-dependency.amber",							"cov-nested-loops-global-loop-counter-iterator-dependency",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-global-loop-counter-output-color-from-backup.amber",						"cov-nested-loops-global-loop-counter-output-color-from-backup",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-global-loop-counter-reached-second-iteration.amber",						"cov-nested-loops-global-loop-counter-reached-second-iteration",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-identical-iterator-names-multiply-divide.amber",							"cov-nested-loops-identical-iterator-names-multiply-divide",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-identical-iterators-compare-same-array-elements.amber",					"cov-nested-loops-identical-iterators-compare-same-array-elements",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-increase-integer-dot-product.amber",										"cov-nested-loops-increase-integer-dot-product",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-inner-loop-min-copy-array-elements.amber",								"cov-nested-loops-inner-loop-min-copy-array-elements",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-iterator-times-two-while-min.amber",										"cov-nested-loops-iterator-times-two-while-min",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-never-change-array-element-one.amber",									"cov-nested-loops-never-change-array-element-one",									"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-nested-loops-redundant-condition.amber",												"cov-nested-loops-redundant-condition",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-return-inside-while-never-executed.amber",								"cov-nested-loops-return-inside-while-never-executed",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-sample-opposite-corners.amber",											"cov-nested-loops-sample-opposite-corners",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-select-starting-value-fragcoord.amber",									"cov-nested-loops-select-starting-value-fragcoord",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-set-struct-data-verify-in-function.amber",								"cov-nested-loops-set-struct-data-verify-in-function",								"A fragment shader that covers specific BRW code paths"								},
{	"cov-nested-loops-substract-matrix-element-change-float.amber",								"cov-nested-loops-substract-matrix-element-change-float",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-switch-case-fallthrough-increment-array-element.amber",					"cov-nested-loops-switch-case-fallthrough-increment-array-element",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-temporary-copy-output-color-index-matrix.amber",							"cov-nested-loops-temporary-copy-output-color-index-matrix",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-while-min-iterator-condition-always-false.amber",							"cov-nested-loops-while-min-iterator-condition-always-false",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-switch-add-zero-matrix-elements.amber",									"cov-nested-loops-switch-add-zero-matrix-elements",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nested-loops-while-condition-integer-range-increment-variable.amber",					"cov-nested-loops-while-condition-integer-range-increment-variable",				"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-nested-structs-function-set-inner-struct-field-return.amber",							"cov-nested-structs-function-set-inner-struct-field-return",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-nir-array-access.amber",																"cov-nir-array-access",																"A fragment shader that covers a specific nir path"									},
{	"cov-nir-opt-large-constants-for-clamp-vector-access.amber",								"cov-nir-opt-large-constants-for-clamp-vector-access",								"A fragment shader that covers a specific nir opt large constants path"				},
{	"cov-nir-opt-loop-unroll-if-if-if-if-do-while.amber",										"cov-nir-opt-loop-unroll-if-if-if-if-do-while",										"A fragment shader that covers a specific nir opt loop unroll path"					},
{	"cov-nouble-negation-fragcoord-cast-ivec2-bitwise-and.amber",								"cov-nouble-negation-fragcoord-cast-ivec2-bitwise-and",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-one-bitwise-and-bitwise-or-full-bits.amber",											"cov-one-bitwise-and-bitwise-or-full-bits",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-one-minus-clamp-always-one-cast-to-int.amber",											"cov-one-minus-clamp-always-one-cast-to-int",										"A fragment shader that covers specific NIR code paths"								},
{	"cov-optimize-phis-for.amber",																"cov-optimize-phis-for",															"A fragment shader that cover specific optimize phis code paths"					},
{	"cov-optimize-phis-for-for-do-while-if-if.amber",											"cov-optimize-phis-for-for-do-while-if-if",											"A fragment shader that covers a specific optimize PHIs code path",					"VK_KHR_shader_terminate_invocation"},
{	"cov-not-clamp-matrix-access.amber",														"cov-not-clamp-matrix-access",														"A fragment shader that covers a specific selection dag code path"					},
{	"cov-packhalf-unpackunorm.amber",															"cov-packhalf-unpackunorm",															"A fragment shader that covers a specific inst combine shifts code path"			},
{	"cov-pattern-match-signum.amber",															"cov-pattern-match-signum",															"A fragment shader that covers a specific pattern matching path."					},
{	"cov-pattern-match-single-bit.amber",														"cov-pattern-match-single-bit",														"A fragment shader that covers a specific pattern matching path."					},
{	"cov-peephole-optimizer-target-instr-info-for-if-if-if.amber",								"cov-peephole-optimizer-target-instr-info-for-if-if-if",							"Covers peephole optimizer and instr info code paths",								"VK_KHR_shader_terminate_invocation"},
{	"cov-pow-distance-uniform-vector-constant-one-vector.amber",								"cov-pow-distance-uniform-vector-constant-one-vector",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-pow-identical-value-sqrt.amber",														"cov-pow-identical-value-sqrt",														"A fragment shader that covers specific SPIR-V lower math code paths"				},
{	"cov-pow-undefined.amber",																	"cov-pow-undefined",																"A fragment shader that covers specific constant fold and selection dag code paths"	},
{	"cov-pow-undefined-result-condition-with-always-true.amber",								"cov-pow-undefined-result-condition-with-always-true",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-rcp-negative-int.amber",																"cov-rcp-negative-int",																"A fragment shader that covers specific NIR code paths"								},
{	"cov-read-matrix-push-constant.amber",														"cov-read-matrix-push-constant",													"A fragment shader that covers specific SPIR-V reader code paths"					},
{	"cov-reciprocal-var-minus-one.amber",														"cov-reciprocal-var-minus-one",														"A fragment shader that covers specific NIR code paths"								},
{	"cov-reduce-load-replace-extract.amber",													"cov-reduce-load-replace-extract",													"A fragment shader that covers a specific load size reduction path."				},
{	"cov-register-coalescer-live-intervals-target-instr-info-for-discard-for-discard.amber",	"cov-register-coalescer-live-intervals-target-instr-info-for-discard-for-discard",	"Covers register coalescer, live intervals and target instr info code paths",		"VK_KHR_shader_terminate_invocation"},
{	"cov-reinitialize-matrix-after-undefined-value.amber",										"cov-reinitialize-matrix-after-undefined-value",									"A fragment shader that covers specific NIR code paths"								},
{	"cov-repeating-conditions-fract-unused.amber",												"cov-repeating-conditions-fract-unused",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-replace-copy-object.amber",															"cov-replace-copy-object",															"A fragment shader that covers a specific shader simplification path."				},
{	"cov-return-after-do-while.amber",															"cov-return-after-do-while",														"A fragment shader that covers a specific simplify cfg code path"					},
{	"cov-return-after-first-iteration.amber",													"cov-return-after-first-iteration",													"A fragment shader that covers specific BRW code paths"								},
{	"cov-return-partly-undefined-vector-from-array.amber",										"cov-return-partly-undefined-vector-from-array",									"A fragment shader that covers specific NIR code paths"								},
{	"cov-sample-texture-hundred-iterations.amber",												"cov-sample-texture-hundred-iterations",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-sampler-as-function-argument.amber",													"cov-sampler-as-function-argument",													"A fragment shader that covers specific SPIR-V reader code paths"					},
{	"cov-scaled-number-nested-loops.amber",														"cov-scaled-number-nested-loops",													"A fragment shader that covers a specific scaled number code path."					},
{	"cov-selection-dag-assign-back-and-forth.amber",											"cov-selection-dag-assign-back-and-forth",											"A fragment shader that covers a specific selection DAG code path"					},
{	"cov-selection-dag-lt-gt.amber",															"cov-selection-dag-lt-gt",															"A fragment shader that covers a specific selection DAG code path"					},
{	"cov-scaled-number-nested-loops-array-access.amber",										"cov-scaled-number-nested-loops-array-access",										"A fragment shader that covers a specific scaled number path"						},
{	"cov-schedule-dag-rrlist-mix-log-cos.amber",												"cov-schedule-dag-rrlist-mix-log-cos",												"Covers a specific schedule dag register reduction list code path"					},
{	"cov-selection-dag-inverse-clamp.amber",													"cov-selection-dag-inverse-clamp",													"A fragment shader that covers a specific selection DAG code path"					},
{	"cov-selection-dag-same-cond-twice.amber",													"cov-selection-dag-same-cond-twice",												"A fragment shader that covers a specific selection DAG code path"					},
{	"cov-set-array-elements-to-uniform-check-value-break.amber",								"cov-set-array-elements-to-uniform-check-value-break",								"A fragment shader that covers specific LLVM code paths"							},
{	"cov-set-output-color-function-call-nested-loop.amber",										"cov-set-output-color-function-call-nested-loop",									"A fragment shader that covers specific BRW code paths"								},
{	"cov-set-vector-cos-fragcoord.amber",														"cov-set-vector-cos-fragcoord",														"A fragment shader that covers a specific set vector code path."					},
{	"cov-sign-array-access-uaddcarry.amber",													"cov-sign-array-access-uaddcarry",													"A fragment shader that covers a specific inst combine compares code path"			},
{	"cov-simplification-unused-struct.amber",													"cov-simplification-unused-struct",													"A fragment shader that covers a specific shader simplification path."				},
{	"cov-simplification-while-inside-for.amber",												"cov-simplification-while-inside-for",												"A fragment shader that covers a specific code simplification path."				},
{	"cov-simplify-clamp-max-itself.amber",														"cov-simplify-clamp-max-itself",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-combine-compares-max-max-one.amber",											"cov-simplify-combine-compares-max-max-one",										"Covers specific instruction simplifying and combining code paths"					},
{	"cov-simplify-component-uniform-idx.amber",													"cov-simplify-component-uniform-idx",												"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-div-by-uint-one.amber",														"cov-simplify-div-by-uint-one",														"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-for-bitwise-condition.amber",													"cov-simplify-for-bitwise-condition",												"A fragment shader that covers a specific instruction simplify code path"			},
{	"cov-simplify-ldexp-exponent-zero.amber",													"cov-simplify-ldexp-exponent-zero",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-max-multiplied-values.amber",													"cov-simplify-max-multiplied-values",												"A fragment shader that covers a specific instruction simplify code path"			},
{	"cov-simplify-modulo-1.amber",																"cov-simplify-modulo-1",															"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-mul-identity.amber",															"cov-simplify-mul-identity",														"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-not-less-than-neg.amber",														"cov-simplify-not-less-than-neg",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-right-shift-greater-than-zero.amber",											"cov-simplify-right-shift-greater-than-zero",										"Covers specific instruction simplify and combine compare code paths"				},
{	"cov-simplify-select-fragcoord.amber",														"cov-simplify-select-fragcoord",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-simplify-sign-cosh.amber",																"cov-simplify-sign-cosh",															"A fragment shader that covers a specific instruction simplification path"			},
{	"cov-simplify-smoothstep-undef.amber",														"cov-simplify-smoothstep-undef",													"A fragment shader that covers a specific instruction simplification code path"		},
{	"cov-sin-mul-mat-mat-mul-vec-mat.amber",													"cov-sin-mul-mat-mat-mul-vec-mat",													"A fragment shader that covers a specific dag combiner code path"					},
{	"cov-single-block-elim-self-assign.amber",													"cov-single-block-elim-self-assign",												"A fragment shader that covers a specific single block elimination path."			},
{	"cov-single-store-elim-assume-store.amber",													"cov-single-store-elim-assume-store",												"A fragment shader that covers a specific single store elimination path."			},
{	"cov-sinh-ldexp.amber",																		"cov-sinh-ldexp",																	"A fragment shader that covers a specific inst combine compares code path"			},
{	"cov-small-array-overwrite-most-uniform-value-check-data-break.amber",						"cov-small-array-overwrite-most-uniform-value-check-data-break",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-ssa-rewrite-case-with-default.amber",													"cov-ssa-rewrite-case-with-default",												"A fragment shader that covers a specific SSA rewrite path."						},
{	"cov-step-sinh.amber",																		"cov-step-sinh",																	"A fragment shader that covers a specific APFloat code path"						},
{	"cov-struct-array-ivec-negative-modulus-empty-function.amber",								"cov-struct-array-ivec-negative-modulus-empty-function",							"A fragment shader that covers specific LLVM code paths"							},
{	"cov-struct-float-array-mix-uniform-vectors.amber",											"cov-struct-float-array-mix-uniform-vectors",										"A fragment shader that covers specific LLVM code paths"							},
{	"cov-struct-int-array-select-uniform-ivec.amber",											"cov-struct-int-array-select-uniform-ivec",											"A fragment shader that covers specific LLVM code paths"							},
{	"cov-sum-uniform-vector-components-round.amber",											"cov-sum-uniform-vector-components-round",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-switch-fallthrough-variable-from-first-case.amber",									"cov-switch-fallthrough-variable-from-first-case",									"A fragment shader that covers specific LLVM code paths"							},
{	"cov-tail-duplicator-for-for-for.amber",													"cov-tail-duplicator-for-for-for",													"A fragment shader that covers a specific tail duplicator code path"				},
{	"cov-tail-duplicator-infinite-loops.amber",													"cov-tail-duplicator-infinite-loops",												"A fragment shader that covers a specific tail duplicator code path"				},
{	"cov-target-lowering-dfdx-cos.amber",														"cov-target-lowering-dfdx-cos",														"A fragment shader that covers a specific target lowering code path."				},
{	"cov-target-lowering-inst-combine-compares-struct-array-clamp-function-cal.amber",			"cov-target-lowering-inst-combine-compares-struct-array-clamp-function-cal",		"Covers target lowering and compare combining code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-texel-double-negation.amber",															"cov-texel-double-negation",														"A fragment shader that covers specific NIR code paths"								},
{	"cov-transpose-multiply.amber",																"cov-transpose-multiply",															"A fragment shader that covers specific NIR code paths"								},
{	"cov-trunc-fract-always-zero.amber",														"cov-trunc-fract-always-zero",														"A fragment shader that covers specific NIR code paths"								},
{	"cov-two-functions-loops-copy-elements-infinite-loops-never-executed.amber",				"cov-two-functions-loops-copy-elements-infinite-loops-never-executed",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-two-functions-modify-struct-array-element-return-from-loop.amber",						"cov-two-functions-modify-struct-array-element-return-from-loop",					"A fragment shader that covers specific LLVM code paths"							},
{	"cov-two-loops-global-loop-counter-clamp-ivec-elements-index-array.amber",					"cov-two-loops-global-loop-counter-clamp-ivec-elements-index-array",				"A fragment shader that covers specific LLVM code paths"							},
{	"cov-two-loops-global-loop-counter-shift-right-zero-increment-array-element.amber",			"cov-two-loops-global-loop-counter-shift-right-zero-increment-array-element",		"A fragment shader that covers specific LLVM code paths"							},
{	"cov-two-loops-increment-integer-global-counter-break-square-threshold.amber",				"cov-two-loops-increment-integer-global-counter-break-square-threshold",			"A fragment shader that covers specific LLVM code paths"							},
{	"cov-two-loops-never-iterated.amber",														"cov-two-loops-never-iterated",														"A fragment shader that covers specific LLVM code paths"							},
{	"cov-two-nested-loops-switch-case-matrix-array-increment.amber",							"cov-two-nested-loops-switch-case-matrix-array-increment",							"A fragment shader that covers specific LLVM code paths",							"VK_KHR_shader_terminate_invocation"},
{	"cov-types-return-in-main-never-hit.amber",													"cov-types-return-in-main-never-hit",												"A fragment shader that covers a specific types optimization path."					},
{	"cov-uadd-carry-bit-count-index-array.amber",												"cov-uadd-carry-bit-count-index-array",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-ucarryadd-one-and-one.amber",															"cov-ucarryadd-one-and-one",														"A fragment shader that covers specific LLVM code paths"							},
{	"cov-undefined-inversesqrt-reflect.amber",													"cov-undefined-inversesqrt-reflect",												"A fragment shader that covers a specific APFloat code path"						},
{	"cov-uniform-vector-copy.amber",															"cov-uniform-vector-copy",															"A fragment shader that covers specific NIR code paths"								},
{	"cov-uniform-vector-function-argument-mod-increment-integers.amber",						"cov-uniform-vector-function-argument-mod-increment-integers",						"A fragment shader that covers specific LLVM code paths"							},
{	"cov-uninitialized-values-passed-to-function-never-executed.amber",							"cov-uninitialized-values-passed-to-function-never-executed",						"A fragment shader that covers specific NIR code paths"								},
{	"cov-unpack-unorm-mix-always-one.amber",													"cov-unpack-unorm-mix-always-one",													"A fragment shader that covers specific NIR code paths"								},
{	"cov-unused-access-past-matrix-elements.amber",												"cov-unused-access-past-matrix-elements",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-unused-matrix-copy-inside-loop.amber",													"cov-unused-matrix-copy-inside-loop",												"A fragment shader that covers specific NIR code paths"								},
{	"cov-val-cfg-case-fallthrough.amber",														"cov-val-cfg-case-fallthrough",														"A fragment shader that covers a specific shader validation path."					},
{	"cov-value-inst-combine-select-value-tracking-flip-bits.amber",								"cov-value-inst-combine-select-value-tracking-flip-bits",							"Covers value, inst combine select and value tracking code paths"					},
{	"cov-value-tracking-apint-inst-combine-simplify-one-mod-loop-iterator.amber",				"cov-value-tracking-apint-inst-combine-simplify-one-mod-loop-iterator",				"A fragment shader that calculates modulo of constant one with a loop iterator"		},
{	"cov-value-tracking-const-dfdy.amber",														"cov-value-tracking-const-dfdy",													"A fragment shader that covers a specific value tracking code path"					},
{	"cov-value-tracking-constant-fold-refraction-dfxd-determinant.amber",						"cov-value-tracking-constant-fold-refraction-dfxd-determinant",						"A fragment shader that calculates refraction with certain values"					},
{	"cov-value-tracking-inclusive-or.amber",													"cov-value-tracking-inclusive-or",													"A fragment shader that covers a specific value tracking path"						},
{	"cov-value-tracking-known-nonzero.amber",													"cov-value-tracking-known-nonzero",													"A fragment shader that covers a specific value tracking path"						},
{	"cov-value-tracking-max-uintbitstofloat.amber",												"cov-value-tracking-max-uintbitstofloat",											"A fragment shader that covers a specific value tracking path"						},
{	"cov-value-tracking-selection-dag-negation-clamp-loop.amber",								"cov-value-tracking-selection-dag-negation-clamp-loop",								"A fragment shader that calculates negation of clamped loop iterator values"		},
{	"cov-value-tracking-uniform-incident.amber",												"cov-value-tracking-uniform-incident",												"A fragment shader that covers a specific value tracking code path"					},
{	"cov-variable-copy-in-function-tex-sample.amber",											"cov-variable-copy-in-function-tex-sample",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-vec2-dot-max-uniform.amber",															"cov-vec2-dot-max-uniform",															"A fragment shader that covers specific LLVM code paths"							},
{	"cov-vec2-dot-minus-negative-zero.amber",													"cov-vec2-dot-minus-negative-zero",													"A fragment shader that covers specific LLVM code paths"							},
{	"cov-vec2-duplicate-min-always-half.amber",													"cov-vec2-duplicate-min-always-half",												"A fragment shader that covers specific LLVM code paths"							},
{	"cov-vector-dce-inc-unused-comp.amber",														"cov-vector-dce-inc-unused-comp",													"A fragment shader that covers a specific vector DCE path."							},
{	"cov-vector-dce-unused-component.amber",													"cov-vector-dce-unused-component",													"A fragment shader that covers a specific vector DCE path."							},
{	"cov-vector-illegal-index-never-executed.amber",											"cov-vector-illegal-index-never-executed",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-vector-log2-cosh.amber",																"cov-vector-log2-cosh",																"A fragment shader that covers a specific vector log2 and cosh code path."			},
{	"cov-wrap-op-kill-for-loop.amber",															"cov-wrap-op-kill-for-loop",														"A fragment shader that covers a specific OpKill wrapping code path",				"VK_KHR_shader_terminate_invocation"},
{	"cov-wrap-op-kill-two-branches.amber",														"cov-wrap-op-kill-two-branches",													"A fragment shader that covers a specific OpKill wrapping path."	,				"VK_KHR_shader_terminate_invocation"},
{	"cov-write-past-matrix-elements-unused.amber",												"cov-write-past-matrix-elements-unused",											"A fragment shader that covers specific NIR code paths"								},
{	"cov-x86-instr-info-determinant-min.amber",													"cov-x86-instr-info-determinant-min",												"A fragment shader that covers a specific x86 instr info code path"					},
{	"cov-x86-isel-lowering-determinant-exp-acos.amber",											"cov-x86-isel-lowering-determinant-exp-acos",										"A fragment shader that covers a specific x86 isel lowering code path"				},
{	"cov-x86-isel-lowering-machine-value-type-uint-to-float.amber",								"cov-x86-isel-lowering-machine-value-type-uint-to-float",							"Covers specific X86 ISel lowering and machine value type code paths"				},
{	"cov-x86-isel-lowering-selection-dag-struct-array-clamp-index.amber",						"cov-x86-isel-lowering-selection-dag-struct-array-clamp-index",						"Covers a specific X86 ISel lowering and DAG selection code paths"					},
{	"cov-x86-isel-lowering-apfloat-nan-cos-cos.amber",											"cov-x86-isel-lowering-apfloat-nan-cos-cos",										"A fragment shader that covers a specific X86 ISel lowering and AP Float code paths"},
{	"cov-x86-isel-lowering-negative-left-shift.amber",											"cov-x86-isel-lowering-negative-left-shift",										"A fragment shader that covers a specific X86 ISel lowering code path"				},
{	"create-color-in-do-while-for-loop.amber",													"create-color-in-do-while-for-loop",												"A fragment shader that creates the color inside two loops",						"VK_KHR_shader_terminate_invocation"},
{	"dead-barriers-in-loops.amber",																"dead-barriers-in-loops",															"A compute shader with dead barriers"												},
{	"dead-struct-init.amber",																	"dead-struct-init",																	"A fragment shader that uses struct initializers"									},
{	"disc-and-add-in-func-in-loop.amber",														"disc-and-add-in-func-in-loop",														"A fragment shader with discard and add in function in loop",						"VK_KHR_shader_terminate_invocation"},
{	"discard-continue-return.amber",															"discard-continue-return",															"A fragment shader with a discard, continue, and return",							"VK_KHR_shader_terminate_invocation"},
{	"discard-in-array-manipulating-loop.amber",													"discard-in-array-manipulating-loop",												"An array-manipulating fragment shader with a discard",								"VK_KHR_shader_terminate_invocation"},
{	"discard-in-loop.amber",																	"discard-in-loop",																	"A shader with a discard in a loop",												"VK_KHR_shader_terminate_invocation"},
{	"discard-in-loop-in-function.amber",														"discard-in-loop-in-function",														"A shader with a discard nested in a loop in a function",							"VK_KHR_shader_terminate_invocation"},
{	"discards-in-control-flow.amber",															"discards-in-control-flow",															"A fragment shader with discards in loops and conditionals",						"VK_KHR_shader_terminate_invocation"},
{	"do-while-false-if.amber",																	"do-while-false-if",																"A fragment shader with false if return in do while loop"							},
{	"do-while-false-loops.amber",																"do-while-false-loops",																"Code wrapped in nested single iteration loops"										},
{	"do-while-if-return.amber",																	"do-while-if-return",																"A fragment shader with true if in a nested do while loop"							},
{	"do-while-loop-in-conditionals.amber",														"do-while-loop-in-conditionals",													"A fragment shader with do-while loop in conditional nest"							},
{	"do-while-with-always-true-if.amber",														"do-while-with-always-true-if",														"A fragment shader with a do while that always returns"								},
{	"do-while-with-if-condition.amber",															"do-while-with-if-condition",														"A fragment shader that has nested if condition in do while"						},
{	"early-return-and-barrier.amber",															"early-return-and-barrier",															"A compute shader with an early return and a barrier"								},
{	"find-msb-from-lsb.amber",																	"find-msb-from-lsb",																"A fragment shader that finds MSB from LSB"											},
{	"flag-always-false-if.amber",																"flag-always-false-if",																"A fragment shader with recurrent always false if statement"						},
{	"for-condition-always-false.amber",															"for-condition-always-false",														"A fragment shader that uses a for loop with condition always false"				},
{	"for-loop-with-return.amber",																"for-loop-with-return",																"A fragment shader with a for loop that loops only once"							},
{	"for-with-ifs-and-return.amber",															"for-with-ifs-and-return",															"A fragment shader with two ifs and return/continue inside a for loop"				},
{	"frag-coord-func-call-and-ifs.amber",														"frag-coord-func-call-and-ifs",														"A fragment shader with many uses of gl_FragCoord"									},
{	"fragcoord-control-flow.amber",																"fragcoord-control-flow",															"A fragment shader that uses FragCoord and somewhat complex control flow",			"VK_KHR_shader_terminate_invocation"},
{	"fragcoord-control-flow-2.amber",															"fragcoord-control-flow-2",															"A fragment shader that uses FragCoord and somewhat complex control flow",			"VK_KHR_shader_terminate_invocation"},
{	"function-with-float-comparison.amber",														"function-with-float-comparison",													"A fragment shader that compares a float and a coordinate"							},
{	"function-with-uniform-return.amber",														"function-with-uniform-return",														"A fragment shader with uniform value as a return"									},
{	"global-array-loops.amber",																	"global-array-loops",																"A loop that writes then reads a global array"										},
{	"if-and-switch.amber",																		"if-and-switch",																	"A fragment shader with a switch and some data flow"								},
{	"increment-value-in-nested-for-loop.amber",													"increment-value-in-nested-for-loop",												"A frag. shader that increments a value in nested for loop"							},
{	"injection-switch-as-comparison.amber",														"injection-switch-as-comparison",													"A fragment shader with uniform comparison in loop"									},
{	"int-mat2-struct.amber",																	"int-mat2-struct",																	"Fragment shader using (int, mat2) struct"											},
{	"loop-call-discard.amber",																	"loop-call-discard",																"A fragment shader with nested loops and a function call",							"VK_KHR_shader_terminate_invocation"},
{	"loop-dead-if-loop.amber",																	"loop-dead-if-loop",																"A fragment shader with a loop, dead if, and a loop"								},
{	"loop-nested-ifs.amber",																	"loop-nested-ifs",																	"A fragment shader with a for loop containing nested ifs"							},
{	"loops-breaks-returns.amber",																"loops-breaks-returns",																"A compute shader with loops, breaks, returns"										},
{	"loops-ifs-continues-call.amber",															"loops-ifs-continues-call",															"A fragment shader with nested control flow and a call"								},
{	"mat-array-deep-control-flow.amber",														"mat-array-deep-control-flow",														"A fragment shader that uses an array of matrices and has deep control flow"		},
{	"mat-array-distance.amber",																	"mat-array-distance",																"A fragment shader that uses an array of matrices and distance"						},
{	"mat-mul-in-loop.amber",																	"mat-mul-in-loop",																	"Shader with matrix multiplication in loop"											},
{	"matrices-and-return-in-loop.amber",														"matrices-and-return-in-loop",														"A fragment shader with matrices and a return in a loop"							},
{	"max-mix-conditional-discard.amber",														"max-mix-conditional-discard",														"A fragment shader with an expression used in two discard guards",					"VK_KHR_shader_terminate_invocation"},
{	"mix-floor-add.amber",																		"mix-floor-add",																	"A fragment shader with mix, uintBitsToFloat, and floor"							},
{	"modf-gl-color.amber",																		"modf-gl-color",																	"A fragment shader with modf of gl color"											},
{	"modf-temp-modf-color.amber",																"modf-temp-modf-color",																"A fragment shader that calls modf twice, once with color"							},
{	"nested-for-break-mat-color.amber",															"nested-for-break-mat-color",														"Two nested for loops modify a mat4 then writes red"								},
{	"nested-for-loops-switch-fallthrough.amber",												"nested-for-loops-switch-fallthrough",												"A fragment shader with few nested loops with fallthrough",							"VK_KHR_shader_terminate_invocation"},
{	"nested-for-loops-with-return.amber",														"nested-for-loops-with-return",														"A fragment shader with two nested for loops with return"							},
{	"nested-ifs-and-return-in-for-loop.amber",													"nested-ifs-and-return-in-for-loop",												"A fragment shader with return in nest of ifs, inside loop"							},
{	"nested-loops-switch.amber",																"nested-loops-switch",																"A fragment shader with nested loops and a switch"									},
{	"nested-switch-break-discard.amber",														"nested-switch-break-discard",														"Nested switches with break and discard",											"VK_KHR_shader_terminate_invocation"},
{	"one-sized-array.amber",																	"one-sized-array",																	"A fragment shader that uses a struct with an array of size one"					},
{	"pow-vec4.amber",																			"pow-vec4",																			"A fragment shader that uses pow"													},
{	"return-before-writing-wrong-color.amber",													"return-before-writing-wrong-color",												"A fragment shader with return before writing wrong color"							},
{	"return-float-from-while-loop.amber",														"return-float-from-while-loop",														"A fragment shader with unreachable while loop"										},
{	"return-in-loop-in-function.amber",															"return-in-loop-in-function",														"A fragment shader with early return from loop in function"							},
{	"return-inside-loop-in-function.amber",														"return-inside-loop-in-function",													"A fragment shader with return inside loop"											},
{	"returned-boolean-in-vector.amber",															"returned-boolean-in-vector",														"A fragment shader with returned boolean in vector"									},
{	"set-color-in-one-iteration-while-loop.amber",												"set-color-in-one-iteration-while-loop",											"A frag shader that sets the color in one iter while loop"							},
{	"similar-nested-ifs.amber",																	"similar-nested-ifs",																"A fragment shader with similar nested ifs and loops"								},
{	"smoothstep-after-loop.amber",																"smoothstep-after-loop",															"Fragment shader with 1-iteration loop and smoothstep"								},
{	"spv-access-chains.amber",																	"spv-access-chains",																"Equivalent shaders, one with extra access chains"									},
{	"spv-composite-phi.amber",																	"spv-composite-phi",																"Equivalent shaders, one with id used by OpPhi hidden in composite"					},
{	"spv-composite2.amber",																		"spv-composite2",																	"Equivalent shaders, one where an id is hidden inside a composite"					},
{	"spv-composites.amber",																		"spv-composites",																	"Equivalent shaders; one obfuscates an id via composites"							},
{	"spv-copy-object.amber",																	"spv-copy-object",																	"Equivalent shaders; one features extra OpCopyObject instructions"					},
{	"spv-dead-break-and-unroll.amber",															"spv-dead-break-and-unroll",														"Equivalent shaders, one with a dead break and an Unroll annotation"				},
{	"spv-declare-bvec4.amber",																	"spv-declare-bvec4",																"Equivalent shaders except one declares a bvec4"									},
{	"spv-double-branch-to-same-block.amber",													"spv-double-branch-to-same-block",													"Equivalent shaders, one with more complex branching",								"VK_KHR_shader_terminate_invocation"},
{	"spv-double-branch-to-same-block2.amber",													"spv-double-branch-to-same-block2",													"Equivalent shaders, one with more complex branching"								},
{	"spv-double-branch-to-same-block3.amber",													"spv-double-branch-to-same-block3",													"Equivalent shaders, one with more complex branching",								"VK_KHR_shader_terminate_invocation"},
{	"spv-load-from-frag-color.amber",															"spv-load-from-frag-color",															"Equivalent shaders, one with extra access chains and load"							},
{	"spv-null-in-phi-and-unroll.amber",															"spv-null-in-phi-and-unroll",														"Equivalent shaders, one that uses null for 0 and an Unroll annotation"				},
{	"spv-stable-bifurcation-Os-mutate-var-vector-shuffle.amber",								"spv-stable-bifurcation-Os-mutate-var-vector-shuffle",								"Three shaders diff: mutate var, vector shuffle"									},
{	"spv-stable-bubblesort-flag-complex-conditionals.amber",									"spv-stable-bubblesort-flag-complex-conditionals",									"Equivalent shaders, one with more complex conditionals"							},
{	"spv-stable-collatz-O-mutate-composite-construct-extract.amber",							"spv-stable-collatz-O-mutate-composite-construct-extract",							"Two shaders diff: mutate var, comp extract/construct"								},
{	"spv-stable-colorgrid-modulo-O-move-block-down.amber",										"spv-stable-colorgrid-modulo-O-move-block-down",									"Two shaders with diff: some blocks moved down"										},
{	"spv-stable-maze-O-dead-code.amber",														"spv-stable-maze-O-dead-code",														"Equivalent shaders, one with instructions propagated to predecessors"				},
{	"spv-stable-maze-O-memory-accesses.amber",													"spv-stable-maze-O-memory-accesses",												"Equivalent shaders, one extra memory accesses"										},
{	"spv-stable-maze-flatten-copy-composite.amber",												"spv-stable-maze-flatten-copy-composite",											"Three shaders with diff: conditional %270 is flattened"							},
{	"spv-stable-mergesort-O-prop-up-mutate-var.amber",											"spv-stable-mergesort-O-prop-up-mutate-var",										"Three shaders with diff: mutate var",												"VK_KHR_shader_terminate_invocation"},
{	"spv-stable-mergesort-dead-code.amber",														"spv-stable-mergesort-dead-code",													"Equivalent shaders, one with additional dead code",								"VK_KHR_shader_terminate_invocation"},
{	"spv-stable-mergesort-flatten-selection-dead-continues.amber",								"spv-stable-mergesort-flatten-selection-dead-continues",							"Shaders diff: selection %25 flattened; dead continues",							"VK_KHR_shader_terminate_invocation"},
{	"spv-stable-mergesort-func-inline-mutate-var.amber",										"spv-stable-mergesort-func-inline-mutate-var",										"Three shaders diff: mutated var",													"VK_KHR_shader_terminate_invocation"},
{	"spv-stable-orbit-O-mutate-variable.amber",													"spv-stable-orbit-O-mutate-variable",												"Two shaders with diff: variable mutated"											},
{	"spv-stable-orbit-Os-access-chain-mutate-pointer.amber",									"spv-stable-orbit-Os-access-chain-mutate-pointer",									"Three shaders with diff: added mutate pointer"										},
{	"spv-stable-pillars-O-op-select-to-op-phi.amber",											"spv-stable-pillars-O-op-select-to-op-phi",											"Three shaders diff: OpSelect -> OpPhi"												},
{	"spv-stable-pillars-volatile-nontemporal-store.amber",										"spv-stable-pillars-volatile-nontemporal-store",									"Equivalent shaders, one with additional memory usage"								},
{	"spv-stable-quicksort-dontinline.amber",													"spv-stable-quicksort-dontinline",													"Equivalent shaders, one with DontInline attribute"									},
{	"spv-stable-quicksort-mat-func-param.amber",												"spv-stable-quicksort-mat-func-param",												"Two shaders with diff: added mat3x3 func param"									},
{	"spv-stable-rects-Os-mutate-var-push-through-var.amber",									"spv-stable-rects-Os-mutate-var-push-through-var",									"Three shaders diff: new variable used and mutated"									},
{	"spv-stable-sampler-loop-extra-instructions.amber",											"spv-stable-sampler-loop-extra-instructions",										"Equivalent shaders, one with irrelevant extra instructions"						},
{	"spv-stable-sampler-polar-simple-O-access-chain.amber",										"spv-stable-sampler-polar-simple-O-access-chain",									"Equivalent shaders, one with an additional access chain"							},
{	"stable-binarysearch-tree-false-if-discard-loop.amber",										"stable-binarysearch-tree-false-if-discard-loop",									"A fragment shader with always false if with discard loop",							"VK_KHR_shader_terminate_invocation"},
{	"stable-binarysearch-tree-fragcoord-less-than-zero.amber",									"stable-binarysearch-tree-fragcoord-less-than-zero",								"A fragment shader with gl_FragCoord.x less than zero"								},
{	"stable-binarysearch-tree-nested-if-and-conditional.amber",									"stable-binarysearch-tree-nested-if-and-conditional",								"A fragment shader with nested if and conditional statement"						},
{	"stable-binarysearch-tree-with-loop-read-write-global.amber",								"stable-binarysearch-tree-with-loop-read-write-global",								"A pair of fragment shaders that both render red"									},
{	"stable-collatz-push-constant-with-nested-min-max.amber",									"stable-collatz-push-constant-with-nested-min-max",									"A fragment shader with push constant and nested min max"							},
{	"stable-colorgrid-modulo-double-always-false-discard.amber",								"stable-colorgrid-modulo-double-always-false-discard",								"A fragment shader with two always false discards",									"VK_KHR_shader_terminate_invocation"},
{	"stable-mergesort-for-always-false-if-discard.amber",										"stable-mergesort-for-always-false-if-discard",										"A fragment shader with for loop and always false if",								"VK_KHR_shader_terminate_invocation"},
{	"stable-mergesort-reversed-for-loop.amber",													"stable-mergesort-reversed-for-loop",												"A fragment shader with once iterated reversed for loop",							"VK_KHR_shader_terminate_invocation"},
{	"stable-colorgrid-modulo-float-mat-determinant-clamp.amber",								"stable-colorgrid-modulo-float-mat-determinant-clamp",								"A fragment shader with clamped float in determinant matrix"						},
{	"stable-colorgrid-modulo-injected-conditional-true.amber",									"stable-colorgrid-modulo-injected-conditional-true",								"A fragment shader with an always true conditional"									},
{	"stable-colorgrid-modulo-true-conditional-divided-1.amber",									"stable-colorgrid-modulo-true-conditional-divided-1",								"A fragment shader with true conditional divided by 1",								"VK_KHR_shader_terminate_invocation"},
{	"stable-colorgrid-modulo-true-conditional-simple-loop.amber",								"stable-colorgrid-modulo-true-conditional-simple-loop",								"A fragment shader with conditional and simple loop"								},
{	"stable-colorgrid-modulo-vec3-values-from-matrix.amber",									"stable-colorgrid-modulo-vec3-values-from-matrix",									"A fragment shader with vec3 values set from matrix4x2"								},
{	"stable-mergesort-clamped-conditional-bit-shift.amber",										"stable-mergesort-clamped-conditional-bit-shift",									"Two shaders with diff: conditional bit shift in a clamp",							"VK_KHR_shader_terminate_invocation"},
{	"stable-quicksort-conditional-bitwise-or-clamp.amber",										"stable-quicksort-conditional-bitwise-or-clamp",									"A fragment shader with conditional bitwise or clamped"								},
{	"stable-quicksort-for-loop-with-injection.amber",											"stable-quicksort-for-loop-with-injection",											"A fragment shader with a for loop containing injection"							},
{	"stable-quicksort-if-false-else-return.amber",												"stable-quicksort-if-false-else-return",											"A fragment shader with an always false if statement"								},
{	"stable-quicksort-max-value-as-index.amber",												"stable-quicksort-max-value-as-index",												"A fragment shader with greater of two values as index"								},
{	"stable-rects-vec4-clamp-conditional-min-mix.amber",										"stable-rects-vec4-clamp-conditional-min-mix",										"A fragment shader with min-mix in always false conditional"						},
{	"stable-triangle-array-nested-loop.amber",													"stable-triangle-array-nested-loop",												"A fragment shader with array and nested loops"										},
{	"stable-triangle-nested-for-loop-and-true-if.amber",										"stable-triangle-nested-for-loop-and-true-if",										"A fragment shader with nested for loop and always true if"							},
{	"stable-triangle-clamp-conditional-mix.amber",												"stable-triangle-clamp-conditional-mix",											"A fragment shader with mix conditional in a clamp"									},
{	"stable-triangle-nested-conditional-clamped-float.amber",									"stable-triangle-nested-conditional-clamped-float",									"A fragment shader with nested conditional float in clamp"							},
{	"struct-and-unreachable-infinite-loop.amber",												"struct-and-unreachable-infinite-loop",												"Fragment shader with struct and unreachable infinite loop"							},
{	"struct-array-data-as-loop-iterator.amber",													"struct-array-data-as-loop-iterator",												"A fragment shader that uses struct array data for loop iterator value"				},
{	"struct-array-index.amber",																	"struct-array-index",																"A fragment shader with struct array and always true if"							},
{	"struct-controlled-loop.amber",																"struct-controlled-loop",															"Shader with loop controlled by struct"												},
{	"struct-used-as-temporary.amber",															"struct-used-as-temporary",															"A fragment shader that uses a temporary struct variable"							},
{	"switch-case-with-undefined-expression.amber",												"switch-case-with-undefined-expression",											"A fragment shader with undefined expression"										},
{	"switch-if-discard.amber",																	"switch-if-discard",																"A fragment shader with a switch, if, and discard",									"VK_KHR_shader_terminate_invocation"},
{	"switch-inside-while-always-return.amber",													"switch-inside-while-always-return",												"A fragment shader with a switch inside while always return"						},
{	"switch-loop-switch-if.amber",																"switch-loop-switch-if",															"A nested switch-loop-switch"														},
{	"switch-with-empty-if-false.amber",															"switch-with-empty-if-false",														"A fragment shader with always false if in switch statement"						},
{	"switch-with-fall-through-cases.amber",														"switch-with-fall-through-cases",													"A fragment shader with switch cases that fall through"								},
{	"swizzle-struct-init-min.amber",															"swizzle-struct-init-min",															"A fragment shader that uses vector swizzles, struct initializers, and min"			},
{	"transpose-rectangular-matrix.amber",														"transpose-rectangular-matrix",														"Fragment shader that uses 'transpose'"												},
{	"two-2-iteration-loops.amber",																"two-2-iteration-loops",															"Fragment shader with pair of outer loops",											"VK_KHR_shader_terminate_invocation"},
{	"two-for-loops-with-barrier-function.amber",												"two-for-loops-with-barrier-function",												"A compute shader with two barrier functions"										},
{	"two-loops-mat-add.amber",																	"two-loops-mat-add",																"A fragment shader with two for loops over a global matrix"							},
{	"two-loops-matrix.amber",																	"two-loops-matrix",																	"A fragment shader with two loops and some matrices"								},
{	"two-loops-set-struct.amber",																"two-loops-set-struct",																"A fragment shader with two loops that write to a struct"							},
{	"two-loops-with-break.amber",																"two-loops-with-break",																"A fragment shader with two loops with breaks"										},
{	"two-nested-do-whiles.amber",																"two-nested-do-whiles",																"A fragment shader with nested do while"											},
{	"two-nested-for-loops-with-returns.amber",													"two-nested-for-loops-with-returns",												"A compute shader with two nested for loops"										},
{	"two-nested-infinite-loops-discard.amber",													"two-nested-infinite-loops-discard",												"A fragment shader with an always false if function",								"VK_KHR_shader_terminate_invocation"},
{	"undefined-integer-in-function.amber",														"undefined-integer-in-function",													"A fragment shader with nested do while and undefined int"							},
{	"uninit-element-cast-in-loop.amber",														"uninit-element-cast-in-loop",														"A fragment shader with uninitialized element cast in loop"							},
{	"uninitialized-var-decrement-and-add.amber",												"uninitialized-var-decrement-and-add",												"A fragment shader that uses an uninitialized variable"								},
{	"undefined-assign-in-infinite-loop.amber",													"undefined-assign-in-infinite-loop",												"A fragment shader with uninitialized read in infinite loop"						},
{	"unreachable-barrier-in-loops.amber",														"unreachable-barrier-in-loops",														"A compute shader with an unreachable barrier in a loop nest"						},
{	"unreachable-continue-statement.amber",														"unreachable-continue-statement",													"A fragment shader with unreachable continue statement"								},
{	"unreachable-discard-statement-in-if.amber",												"unreachable-discard-statement-in-if",												"A fragment shader with discard keyword and a return",								"VK_KHR_shader_terminate_invocation"},
{	"unreachable-discard-statement.amber",														"unreachable-discard-statement",													"A fragment shader with unreachable discard statement",								"VK_KHR_shader_terminate_invocation"},
{	"unreachable-loops.amber",																	"unreachable-loops",																"Fragment shader that writes red despite unreachable loops"							},
{	"unreachable-loops-in-switch.amber",														"unreachable-loops-in-switch",														"A fragment shader with unreachable loops in a switch"								},
{	"unreachable-return-in-loop.amber",															"unreachable-return-in-loop",														"A fragment shader with an unreachable return in a loop"							},
{	"unreachable-switch-case-with-discards.amber",												"unreachable-switch-case-with-discards",											"A shader with a switch statement containing unreachable discards",					"VK_KHR_shader_terminate_invocation"},
{	"uv-value-comparison-as-boolean.amber",														"uv-value-comparison-as-boolean",													"A fragment shader with uv value comparison as boolean"								},
{	"vec2-modf.amber",																			"vec2-modf",																		"A fragment shader with vec2 in modulus fraction function"							},
{	"vector-values-multiplied-by-fragcoord.amber",												"vector-values-multiplied-by-fragcoord",											"A shader that multiplies a vector by fragcoord"									},
{	"vectors-and-discard-in-function.amber",													"vectors-and-discard-in-function",													"A fragment shader that assigns vector values",										"VK_KHR_shader_terminate_invocation"},
{	"while-function-always-false.amber",														"while-function-always-false",														"A fragment shader with an always false while function"								},
{	"while-inside-switch.amber",																"while-inside-switch",																"A fragment shader that uses a while loop inside a switch",							"VK_KHR_shader_terminate_invocation"},
{	"write-before-break.amber",																	"write-before-break",																"Fragment shader that writes red before loop break"									},
{	"write-red-in-loop-nest.amber",																"write-red-in-loop-nest",															"A fragment shader that writes red in a nest of loops"								},
{	"wrong-color-in-always-false-if.amber",														"wrong-color-in-always-false-if",													"A fragment shader with wrong color write in false if"								},
