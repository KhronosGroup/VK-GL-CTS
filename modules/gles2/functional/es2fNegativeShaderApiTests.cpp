/*-------------------------------------------------------------------------
 * drawElements Quality Program OpenGL ES 2.0 Module
 * -------------------------------------------------
 *
 * Copyright 2014 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 *//*!
 * \file
 * \brief Negative Shader API tests.
 *//*--------------------------------------------------------------------*/

#include "es2fNegativeShaderApiTests.hpp"
#include "es2fApiCase.hpp"
#include "gluShaderProgram.hpp"
#include "gluContextInfo.hpp"

#include "glwDefs.hpp"
#include "glwEnums.hpp"

#include "deStringUtil.hpp"

using namespace glw; // GL types

namespace deqp
{
namespace gles2
{
namespace Functional
{

static const char *vertexShaderSource   = "void main (void) { gl_Position = vec4(0.0); }\n\0";
static const char *fragmentShaderSource = "void main (void) { gl_FragColor = vec4(0.0); }\n\0";

static const char *uniformTestVertSource = "uniform mediump vec4 vTest;\n"
                                           "uniform mediump mat4 vMatrix;\n"
                                           "void main (void)\n"
                                           "{\n"
                                           "    gl_Position = vMatrix * vTest;\n"
                                           "}\n\0";
static const char *uniformTestFragSource = "uniform mediump ivec4 fTest;\n"
                                           "uniform sampler2D fSampler;\n"
                                           "void main (void)\n"
                                           "{\n"
                                           "    gl_FragColor.xy = vec4(fTest).xy;\n"
                                           "    gl_FragColor.zw = texture2D(fSampler, vec2(0.0, 0.0)).zw;\n"
                                           "}\n\0";

using tcu::TestLog;

NegativeShaderApiTests::NegativeShaderApiTests(Context &context)
    : TestCaseGroup(context, "shader", "Negative Shader API Cases")
{
}

NegativeShaderApiTests::~NegativeShaderApiTests(void)
{
}

void NegativeShaderApiTests::init(void)
{
    ES2F_ADD_API_CASE(create_shader, "Invalid glCreateShader() usage", {
        m_log << TestLog::Section("", "GL_INVALID_ENUM is generated if shaderType is not an accepted value.");
        glCreateShader(-1);
        expectError(GL_INVALID_ENUM);
        m_log << TestLog::EndSection;
    });
    ES2F_ADD_API_CASE(shader_source, "Invalid glShaderSource() usage", {
        GLboolean shaderCompilerSupported;
        glGetBooleanv(GL_SHADER_COMPILER, &shaderCompilerSupported);
        if (!shaderCompilerSupported)
            m_log << TestLog::Message << "// Shader compiler not supported, always expect GL_INVALID_OPERATION"
                  << TestLog::EndMessage;
        else
            m_log << TestLog::Message << "// Shader compiler supported" << TestLog::EndMessage;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.");
        glShaderSource(1, 0, 0, 0);
        expectError(shaderCompilerSupported ? GL_INVALID_VALUE : GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if count is less than 0.");
        GLuint shader = glCreateShader(GL_VERTEX_SHADER);
        glShaderSource(shader, -1, 0, 0);
        expectError(shaderCompilerSupported ? GL_INVALID_VALUE : GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if shader is not a shader object.");
        GLuint program = glCreateProgram();
        glShaderSource(program, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glDeleteProgram(program);
        glDeleteShader(shader);
    });
    ES2F_ADD_API_CASE(compile_shader, "Invalid glCompileShader() usage", {
        GLboolean shaderCompilerSupported;
        glGetBooleanv(GL_SHADER_COMPILER, &shaderCompilerSupported);
        if (!shaderCompilerSupported)
            m_log << TestLog::Message << "// Shader compiler not supported, always expect GL_INVALID_OPERATION"
                  << TestLog::EndMessage;
        else
            m_log << TestLog::Message << "// Shader compiler supported" << TestLog::EndMessage;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.");
        glCompileShader(9);
        expectError(shaderCompilerSupported ? GL_INVALID_VALUE : GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if shader is not a shader object.");
        GLuint program = glCreateProgram();
        glCompileShader(program);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glDeleteProgram(program);
    });
    ES2F_ADD_API_CASE(delete_shader, "Invalid glDeleteShader() usage", {
        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if shader is not a value generated by OpenGL.");
        glDeleteShader(9);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;
    });
    ES2F_ADD_API_CASE(shader_binary, "Invalid glShaderBinary() usage", {
        std::vector<int32_t> binaryFormats;
        getSupportedExtensions(GL_NUM_SHADER_BINARY_FORMATS, GL_SHADER_BINARY_FORMATS, binaryFormats);
        bool shaderBinarySupported = !binaryFormats.empty();
        if (!shaderBinarySupported)
            m_log << TestLog::Message << "// Shader binaries not supported." << TestLog::EndMessage;
        else
            m_log << TestLog::Message << "// Shader binaries supported" << TestLog::EndMessage;

        GLuint shaders[2];

        shaders[0]     = glCreateShader(GL_VERTEX_SHADER);
        shaders[1]     = glCreateShader(GL_VERTEX_SHADER);
        GLuint program = glCreateProgram();

        m_log << TestLog::Section("", "GL_INVALID_ENUM is generated if binaryformat is not a supported format returned "
                                      "in GL_SHADER_BINARY_FORMATS.");
        glShaderBinary(1, &shaders[0], -1, 0, 0);
        expectError(GL_INVALID_ENUM);
        m_log << TestLog::EndSection;

        if (shaderBinarySupported)
        {
            m_log << TestLog::Section(
                "", "GL_INVALID_VALUE is generated if any value in shaders is not a value generated by OpenGL.");
            shaders[0] = 137;
            glShaderBinary(1, &shaders[0], binaryFormats[0], 0, 0);
            expectError(shaderBinarySupported ? GL_INVALID_VALUE : GL_INVALID_OPERATION);
            m_log << TestLog::EndSection;

            m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if n or length is negative.");
            shaders[0] = glCreateShader(GL_VERTEX_SHADER);
            glShaderBinary(-1, &shaders[0], binaryFormats[0], 0, 0);
            expectError(GL_INVALID_OPERATION, GL_INVALID_VALUE);
            glShaderBinary(1, &shaders[0], binaryFormats[0], 0, -1);
            expectError(GL_INVALID_OPERATION, GL_INVALID_VALUE);
            m_log << TestLog::EndSection;

            m_log << TestLog::Section(
                "", "GL_INVALID_OPERATION is generated if any value in shaders is not a shader object.");
            glShaderBinary(1, &program, binaryFormats[0], 0, 0);
            expectError(GL_INVALID_OPERATION, GL_INVALID_VALUE);
            m_log << TestLog::EndSection;

            m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if there is more than one vertex shader "
                                          "object handle or more than one fragment shader object handle in shaders.");
            shaders[0] = glCreateShader(GL_VERTEX_SHADER);
            shaders[1] = glCreateShader(GL_VERTEX_SHADER);
            glShaderBinary(2, &shaders[0], binaryFormats[0], 0, 1);
            expectError(GL_INVALID_OPERATION, GL_INVALID_VALUE);
            m_log << TestLog::EndSection;
        }

        glDeleteShader(shaders[0]);
        glDeleteShader(shaders[1]);
        glDeleteProgram(program);

        // \note: The format of the data pointed to by binary does not match binaryformat.
    });
    ES2F_ADD_API_CASE(attach_shader, "Invalid glAttachShader() usage", {
        GLuint shader1 = glCreateShader(GL_VERTEX_SHADER);
        GLuint shader2 = glCreateShader(GL_VERTEX_SHADER);
        GLuint program = glCreateProgram();

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glAttachShader(shader1, shader1);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if shader is not a shader object.");
        glAttachShader(program, program);
        expectError(GL_INVALID_OPERATION);
        glAttachShader(shader1, program);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section(
            "", "GL_INVALID_VALUE is generated if either program or shader is not a value generated by OpenGL.");
        glAttachShader(program, -1);
        expectError(GL_INVALID_VALUE);
        glAttachShader(-1, shader1);
        expectError(GL_INVALID_VALUE);
        glAttachShader(-1, -1);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("",
                                  "GL_INVALID_OPERATION is generated if shader is already attached to program, or if "
                                  "another shader object of the same type as shader is already attached to program.");
        glAttachShader(program, shader1);
        expectError(GL_NO_ERROR);
        glAttachShader(program, shader1);
        expectError(GL_INVALID_OPERATION);
        glAttachShader(program, shader2);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glDeleteProgram(program);
        glDeleteShader(shader1);
        glDeleteShader(shader2);
    });
    ES2F_ADD_API_CASE(detach_shader, "Invalid glDetachShader() usage", {
        GLuint shader  = glCreateShader(GL_VERTEX_SHADER);
        GLuint program = glCreateProgram();

        m_log << TestLog::Section(
            "", "GL_INVALID_VALUE is generated if either program or shader is not a value generated by OpenGL.");
        glDetachShader(-1, shader);
        expectError(GL_INVALID_VALUE);
        glDetachShader(program, -1);
        expectError(GL_INVALID_VALUE);
        glDetachShader(-1, -1);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glDetachShader(shader, shader);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if shader is not a shader object.");
        glDetachShader(program, program);
        expectError(GL_INVALID_OPERATION);
        glDetachShader(shader, program);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if shader is not attached to program.");
        glDetachShader(program, shader);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glDeleteProgram(program);
        glDeleteShader(shader);
    });
    ES2F_ADD_API_CASE(link_program, "Invalid glLinkProgram() usage", {
        GLuint shader = glCreateShader(GL_VERTEX_SHADER);

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.");
        glLinkProgram(-1);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glLinkProgram(shader);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glDeleteShader(shader);
    });
    ES2F_ADD_API_CASE(use_program, "Invalid glUseProgram() usage", {
        GLuint shader = glCreateShader(GL_VERTEX_SHADER);

        m_log << TestLog::Section(
            "", "GL_INVALID_VALUE is generated if program is neither 0 nor a value generated by OpenGL.");
        glUseProgram(-1);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glUseProgram(shader);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glUseProgram(0);
        glDeleteShader(shader);
    });
    ES2F_ADD_API_CASE(delete_program, "Invalid glDeleteProgram() usage", {
        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.");
        glDeleteProgram(-1);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;
    });
    ES2F_ADD_API_CASE(get_active_attrib, "Invalid glGetActiveAttrib() usage", {
        GLuint shader = glCreateShader(GL_VERTEX_SHADER);
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(vertexShaderSource, fragmentShaderSource));
        glUseProgram(program.getProgram());

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.");
        glGetActiveAttrib(-1, 0, 0, 0, 0, 0, 0);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glGetActiveAttrib(shader, 0, 0, 0, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if index is greater than or equal to the number "
                                      "of active attribute variables in program.");
        glGetActiveAttrib(program.getProgram(), 0, 0, 0, 0, 0, 0);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if bufSize is less than 0.");
        glGetActiveAttrib(program.getProgram(), 0, -1, 0, 0, 0, 0);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        glUseProgram(0);
        glDeleteShader(shader);
    });
    ES2F_ADD_API_CASE(get_attrib_location, "Invalid glGetAttribLocation() usage", {
        GLuint programEmpty = glCreateProgram();
        GLuint shader       = glCreateShader(GL_VERTEX_SHADER);
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(vertexShaderSource, fragmentShaderSource));

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program has not been successfully linked.");
        glBindAttribLocation(programEmpty, 0, "test");
        glGetAttribLocation(programEmpty, "test");
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if program is not a program or shader object.");
        glUseProgram(program.getProgram());
        glBindAttribLocation(program.getProgram(), 0, "test");
        expectError(GL_NO_ERROR);
        glGetAttribLocation(program.getProgram(), "test");
        expectError(GL_NO_ERROR);
        glGetAttribLocation(-2, "test");
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glGetAttribLocation(shader, "test");
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glUseProgram(0);
        glDeleteShader(shader);
        glDeleteProgram(programEmpty);
    });
    ES2F_ADD_API_CASE(get_uniform_location, "Invalid glGetUniformLocation() usage", {
        GLuint programEmpty = glCreateProgram();
        GLuint shader       = glCreateShader(GL_VERTEX_SHADER);
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(vertexShaderSource, fragmentShaderSource));

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program has not been successfully linked.");
        glGetUniformLocation(programEmpty, "test");
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.");
        glUseProgram(program.getProgram());
        glGetUniformLocation(-2, "test");
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glGetAttribLocation(shader, "test");
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glUseProgram(0);
        glDeleteProgram(programEmpty);
        glDeleteShader(shader);
    });
    ES2F_ADD_API_CASE(bind_attrib_location, "Invalid glBindAttribLocation() usage", {
        GLuint program  = glCreateProgram();
        GLuint maxIndex = m_context.getContextInfo().getInt(GL_MAX_VERTEX_ATTRIBS);
        GLuint shader   = glCreateShader(GL_VERTEX_SHADER);

        m_log << TestLog::Section(
            "", "GL_INVALID_VALUE is generated if index is greater than or equal to GL_MAX_VERTEX_ATTRIBS.");
        glBindAttribLocation(program, maxIndex, "test");
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("",
                                  "GL_INVALID_OPERATION is generated if name starts with the reserved prefix \"gl_\".");
        glBindAttribLocation(program, maxIndex - 1, "gl_test");
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.");
        glBindAttribLocation(-1, maxIndex - 1, "test");
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glBindAttribLocation(shader, maxIndex - 1, "test");
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glDeleteProgram(program);
        glDeleteShader(shader);
    });
    ES2F_ADD_API_CASE(get_active_uniform, "Invalid glGetActiveUniform() usage", {
        GLuint shader = glCreateShader(GL_VERTEX_SHADER);
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(vertexShaderSource, fragmentShaderSource));

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.");
        glGetActiveUniform(-1, 0, 0, 0, 0, 0, 0);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glGetActiveUniform(shader, 0, 0, 0, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if index is greater than or equal to the number "
                                      "of active attribute variables in program.");
        glUseProgram(program.getProgram());
        glGetActiveUniform(program.getProgram(), 5, 0, 0, 0, 0, 0);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if bufSize is less than 0.");
        glGetActiveUniform(program.getProgram(), 0, -1, 0, 0, 0, 0);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        glUseProgram(0);
        glDeleteShader(shader);
    });
    ES2F_ADD_API_CASE(validate_program, "Invalid glValidateProgram() usage", {
        GLuint shader = glCreateShader(GL_VERTEX_SHADER);

        m_log << TestLog::Section("", "GL_INVALID_VALUE is generated if program is not a value generated by OpenGL.");
        glValidateProgram(-1);
        expectError(GL_INVALID_VALUE);
        m_log << TestLog::EndSection;

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if program is not a program object.");
        glValidateProgram(shader);
        expectError(GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;

        glDeleteShader(shader);
    });

    ES2F_ADD_API_CASE(release_shader_compiler, "Invalid glReleaseShaderCompiler() usage", {
        GLboolean shaderCompilerSupported;
        glGetBooleanv(GL_SHADER_COMPILER, &shaderCompilerSupported);

        m_log << TestLog::Section("", "GL_INVALID_OPERATION is generated if a shader compiler is not supported.");
        glReleaseShaderCompiler();
        expectError(shaderCompilerSupported ? GL_NONE : GL_INVALID_OPERATION);
        m_log << TestLog::EndSection;
    });

    // glUniform*f

    ES2F_ADD_API_CASE(uniformf_invalid_program, "Invalid glUniform{1234}f() usage", {
        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if there is no current program object.");
        glUseProgram(0);
        glUniform1f(-1, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform2f(-1, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform3f(-1, 0.0f, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform4f(-1, 0.0f, 0.0f, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;
    });
    ES2F_ADD_API_CASE(uniformf_incompatible_type, "Invalid glUniform{1234}f() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());
        GLint vUnif    = glGetUniformLocation(program.getProgram(), "vTest");    // vec4
        GLint fUnif    = glGetUniformLocation(program.getProgram(), "fTest");    // ivec4
        GLint fSampler = glGetUniformLocation(program.getProgram(), "fSampler"); // sampler2D

        if (vUnif == -1 || fUnif == -1 || fSampler == -1)
        {
            m_log << TestLog::Message << "// ERROR: Failed to retrieve uniform location" << TestLog::EndMessage;
            m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Failed to retrieve uniform location");
        }

        m_log << tcu::TestLog::Section("",
                                       "GL_INVALID_OPERATION is generated if the size of the uniform variable declared "
                                       "in the shader does not match the size indicated by the glUniform command.");
        glUseProgram(program.getProgram());
        glUniform1f(vUnif, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform2f(vUnif, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform3f(vUnif, 0.0f, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform4f(vUnif, 0.0f, 0.0f, 0.0f, 0.0f);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        m_log << tcu::TestLog::Section(
            "", "GL_INVALID_OPERATION is generated if one of the floating-point variants of this function is used to "
                "load a uniform variable of type int, ivec2, ivec3, or ivec4.");
        glUseProgram(program.getProgram());
        glUniform4f(fUnif, 0.0f, 0.0f, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if a sampler is loaded using a command "
                                           "other than glUniform1i and glUniform1iv.");
        glUseProgram(program.getProgram());
        glUniform1f(fSampler, 0.0f);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniformf_invalid_location, "Invalid glUniform{1234}f() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if location is an invalid uniform "
                                           "location for the current program object and location is not equal to -1.");
        glUseProgram(program.getProgram());
        glUniform1f(-2, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform2f(-2, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform3f(-2, 0.0f, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);
        glUniform4f(-2, 0.0f, 0.0f, 0.0f, 0.0f);
        expectError(GL_INVALID_OPERATION);

        glUseProgram(program.getProgram());
        glUniform1f(-1, 0.0f);
        expectError(GL_NO_ERROR);
        glUniform2f(-1, 0.0f, 0.0f);
        expectError(GL_NO_ERROR);
        glUniform3f(-1, 0.0f, 0.0f, 0.0f);
        expectError(GL_NO_ERROR);
        glUniform4f(-1, 0.0f, 0.0f, 0.0f, 0.0f);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });

    // glUniform*fv

    ES2F_ADD_API_CASE(uniformfv_invalid_program, "Invalid glUniform{1234}fv() usage", {
        std::vector<GLfloat> data(4);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if there is no current program object.");
        glUseProgram(0);
        glUniform1fv(-1, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform2fv(-1, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform3fv(-1, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform4fv(-1, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;
    });
    ES2F_ADD_API_CASE(uniformfv_incompatible_type, "Invalid glUniform{1234}fv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());
        GLint vUnif    = glGetUniformLocation(program.getProgram(), "vTest");    // vec4
        GLint fUnif    = glGetUniformLocation(program.getProgram(), "fTest");    // ivec4
        GLint fSampler = glGetUniformLocation(program.getProgram(), "fSampler"); // sampler2D

        if (vUnif == -1 || fUnif == -1 || fSampler == -1)
        {
            m_log << TestLog::Message << "// ERROR: Failed to retrieve uniform location" << TestLog::EndMessage;
            m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Failed to retrieve uniform location");
        }

        std::vector<GLfloat> data(4);

        m_log << tcu::TestLog::Section("",
                                       "GL_INVALID_OPERATION is generated if the size of the uniform variable declared "
                                       "in the shader does not match the size indicated by the glUniform command.");
        glUseProgram(program.getProgram());
        glUniform1fv(vUnif, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform2fv(vUnif, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform3fv(vUnif, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform4fv(vUnif, 1, &data[0]);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        m_log << tcu::TestLog::Section(
            "", "GL_INVALID_OPERATION is generated if one of the floating-point variants of this function is used to "
                "load a uniform variable of type int, ivec2, ivec3, or ivec4.");
        glUseProgram(program.getProgram());
        glUniform4fv(fUnif, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if a sampler is loaded using a command "
                                           "other than glUniform1i and glUniform1iv.");
        glUseProgram(program.getProgram());
        glUniform1fv(fSampler, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniformfv_invalid_location, "Invalid glUniform{1234}fv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());

        std::vector<GLfloat> data(4);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if location is an invalid uniform "
                                           "location for the current program object and location is not equal to -1.");
        glUseProgram(program.getProgram());
        glUniform1fv(-2, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform2fv(-2, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform3fv(-2, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform4fv(-2, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);

        glUseProgram(program.getProgram());
        glUniform1fv(-1, 1, &data[0]);
        expectError(GL_NO_ERROR);
        glUniform2fv(-1, 1, &data[0]);
        expectError(GL_NO_ERROR);
        glUniform3fv(-1, 1, &data[0]);
        expectError(GL_NO_ERROR);
        glUniform4fv(-1, 1, &data[0]);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniformfv_invalid_count, "Invalid glUniform{1234}fv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());
        GLint vUnif = glGetUniformLocation(program.getProgram(), "vTest"); // vec4

        if (vUnif == -1)
        {
            m_log << TestLog::Message << "// ERROR: Failed to retrieve uniform location" << TestLog::EndMessage;
            m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Failed to retrieve uniform location");
        }

        std::vector<GLfloat> data(8);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if count is greater than 1 and the "
                                           "indicated uniform variable is not an array variable.");
        glUseProgram(program.getProgram());
        glUniform1fv(vUnif, 2, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform2fv(vUnif, 2, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform3fv(vUnif, 2, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform4fv(vUnif, 2, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });

    // glUniform*i

    ES2F_ADD_API_CASE(uniformi_invalid_program, "Invalid glUniform{1234}i() usage", {
        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if there is no current program object.");
        glUseProgram(0);
        glUniform1i(-1, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform2i(-1, 0, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform3i(-1, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform4i(-1, 0, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;
    });
    ES2F_ADD_API_CASE(uniformi_incompatible_type, "Invalid glUniform{1234}i() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());
        GLint vUnif    = glGetUniformLocation(program.getProgram(), "vTest");    // vec4
        GLint fUnif    = glGetUniformLocation(program.getProgram(), "fTest");    // ivec4
        GLint fSampler = glGetUniformLocation(program.getProgram(), "fSampler"); // sampler2D

        if (vUnif == -1 || fUnif == -1 || fSampler == -1)
        {
            m_log << TestLog::Message << "// ERROR: Failed to retrieve uniform location" << TestLog::EndMessage;
            m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Failed to retrieve uniform location");
        }

        m_log << tcu::TestLog::Section("",
                                       "GL_INVALID_OPERATION is generated if the size of the uniform variable declared "
                                       "in the shader does not match the size indicated by the glUniform command.");
        glUseProgram(program.getProgram());
        glUniform1i(fUnif, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform2i(fUnif, 0, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform3i(fUnif, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform4i(fUnif, 0, 0, 0, 0);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        m_log << tcu::TestLog::Section(
            "", "GL_INVALID_OPERATION is generated if one of the integer variants of this function is used to load a "
                "uniform variable of type float, vec2, vec3, or vec4.");
        glUseProgram(program.getProgram());
        glUniform4i(vUnif, 0, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniformi_invalid_location, "Invalid glUniform{1234}i() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if location is an invalid uniform "
                                           "location for the current program object and location is not equal to -1.");
        glUseProgram(program.getProgram());
        glUniform1i(-2, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform2i(-2, 0, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform3i(-2, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);
        glUniform4i(-2, 0, 0, 0, 0);
        expectError(GL_INVALID_OPERATION);

        glUseProgram(program.getProgram());
        glUniform1i(-1, 0);
        expectError(GL_NO_ERROR);
        glUniform2i(-1, 0, 0);
        expectError(GL_NO_ERROR);
        glUniform3i(-1, 0, 0, 0);
        expectError(GL_NO_ERROR);
        glUniform4i(-1, 0, 0, 0, 0);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });

    // glUniform*iv

    ES2F_ADD_API_CASE(uniformiv_invalid_program, "Invalid glUniform{1234}iv() usage", {
        std::vector<GLint> data(4);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if there is no current program object.");
        glUseProgram(0);
        glUniform1iv(-1, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform2iv(-1, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform3iv(-1, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform4iv(-1, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;
    });
    ES2F_ADD_API_CASE(uniformiv_incompatible_type, "Invalid glUniform{1234}iv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());
        GLint vUnif    = glGetUniformLocation(program.getProgram(), "vTest");    // vec4
        GLint fUnif    = glGetUniformLocation(program.getProgram(), "fTest");    // ivec4
        GLint fSampler = glGetUniformLocation(program.getProgram(), "fSampler"); // sampler2D

        if (vUnif == -1 || fUnif == -1 || fSampler == -1)
        {
            m_log << TestLog::Message << "// ERROR: Failed to retrieve uniform location" << TestLog::EndMessage;
            m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Failed to retrieve uniform location");
        }

        std::vector<GLint> data(4);

        m_log << tcu::TestLog::Section("",
                                       "GL_INVALID_OPERATION is generated if the size of the uniform variable declared "
                                       "in the shader does not match the size indicated by the glUniform command.");
        glUseProgram(program.getProgram());
        glUniform1iv(fUnif, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform2iv(fUnif, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform3iv(fUnif, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform4iv(fUnif, 1, &data[0]);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        m_log << tcu::TestLog::Section(
            "", "GL_INVALID_OPERATION is generated if one of the integer variants of this function is used to load a "
                "uniform variable of type float, vec2, vec3, or vec4.");
        glUseProgram(program.getProgram());
        glUniform4iv(vUnif, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniformiv_invalid_location, "Invalid glUniform{1234}iv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());

        std::vector<GLint> data(4);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if location is an invalid uniform "
                                           "location for the current program object and location is not equal to -1.");
        glUseProgram(program.getProgram());
        glUniform1iv(-2, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform2iv(-2, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform3iv(-2, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform4iv(-2, 1, &data[0]);
        expectError(GL_INVALID_OPERATION);

        glUseProgram(program.getProgram());
        glUniform1iv(-1, 1, &data[0]);
        expectError(GL_NO_ERROR);
        glUniform2iv(-1, 1, &data[0]);
        expectError(GL_NO_ERROR);
        glUniform3iv(-1, 1, &data[0]);
        expectError(GL_NO_ERROR);
        glUniform4iv(-1, 1, &data[0]);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniformiv_invalid_count, "Invalid glUniform{1234}iv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());
        GLint fUnif = glGetUniformLocation(program.getProgram(), "fTest"); // ivec4

        if (fUnif == -1)
        {
            m_log << TestLog::Message << "// ERROR: Failed to retrieve uniform location" << TestLog::EndMessage;
            m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Failed to retrieve uniform location");
        }

        std::vector<GLint> data(8);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if count is greater than 1 and the "
                                           "indicated uniform variable is not an array variable.");
        glUseProgram(program.getProgram());
        glUniform1iv(fUnif, 2, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform2iv(fUnif, 2, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform3iv(fUnif, 2, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniform4iv(fUnif, 2, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });

    // glUniformMatrix*fv

    ES2F_ADD_API_CASE(uniform_matrixfv_invalid_program, "Invalid glUniformMatrix{234}fv() usage", {
        std::vector<GLfloat> data(16);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if there is no current program object.");
        glUseProgram(0);
        glUniformMatrix2fv(-1, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniformMatrix3fv(-1, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniformMatrix4fv(-1, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;
    });
    ES2F_ADD_API_CASE(uniform_matrixfv_incompatible_type, "Invalid glUniformMatrix{234}fv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());
        GLint vMatUnif     = glGetUniformLocation(program.getProgram(), "vMatrix");  // mat4
        GLint fSamplerUnif = glGetUniformLocation(program.getProgram(), "fSampler"); // sampler2D

        m_log << program;

        if (vMatUnif == -1 || fSamplerUnif == -1)
        {
            m_log << TestLog::Message << "// ERROR: Failed to retrieve uniform location" << TestLog::EndMessage;
            m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Failed to retrieve uniform location");
        }

        std::vector<GLfloat> data(16);

        m_log << tcu::TestLog::Section("",
                                       "GL_INVALID_OPERATION is generated if the size of the uniform variable declared "
                                       "in the shader does not match the size indicated by the glUniform command.");
        glUseProgram(program.getProgram());
        glUniformMatrix2fv(vMatUnif, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniformMatrix3fv(vMatUnif, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniformMatrix4fv(vMatUnif, 1, GL_FALSE, &data[0]);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if a sampler is loaded using a command "
                                           "other than glUniform1i and glUniform1iv.");
        glUseProgram(program.getProgram());
        glUniformMatrix4fv(fSamplerUnif, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniform_matrixfv_invalid_location, "Invalid glUniformMatrix{234}fv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());

        m_log << program;

        std::vector<GLfloat> data(16);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if location is an invalid uniform "
                                           "location for the current program object and location is not equal to -1.");
        glUseProgram(program.getProgram());
        glUniformMatrix2fv(-2, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniformMatrix3fv(-2, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniformMatrix4fv(-2, 1, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);

        glUseProgram(program.getProgram());
        glUniformMatrix2fv(-1, 1, GL_FALSE, &data[0]);
        expectError(GL_NO_ERROR);
        glUniformMatrix3fv(-1, 1, GL_FALSE, &data[0]);
        expectError(GL_NO_ERROR);
        glUniformMatrix4fv(-1, 1, GL_FALSE, &data[0]);
        expectError(GL_NO_ERROR);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniform_matrixfv_invalid_count, "Invalid glUniformMatrix{234}fv() usage", {
        glu::ShaderProgram program(m_context.getRenderContext(),
                                   glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
        glUseProgram(program.getProgram());
        GLint vMatUnif = glGetUniformLocation(program.getProgram(), "vMatrix"); // mat4

        m_log << program;

        if (vMatUnif == -1)
        {
            m_log << TestLog::Message << "// ERROR: Failed to retrieve uniform location" << TestLog::EndMessage;
            m_testCtx.setTestResult(QP_TEST_RESULT_FAIL, "Failed to retrieve uniform location");
        }

        std::vector<GLfloat> data(32);

        m_log << tcu::TestLog::Section("", "GL_INVALID_OPERATION is generated if count is greater than 1 and the "
                                           "indicated uniform variable is not an array variable.");
        glUseProgram(program.getProgram());
        glUniformMatrix2fv(vMatUnif, 2, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniformMatrix3fv(vMatUnif, 2, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        glUniformMatrix4fv(vMatUnif, 2, GL_FALSE, &data[0]);
        expectError(GL_INVALID_OPERATION);
        m_log << tcu::TestLog::EndSection;

        glUseProgram(0);
    });
    ES2F_ADD_API_CASE(uniform_matrixfv_invalid_transpose, "Invalid glUniformMatrix{234}fv() usage", {
        if (de::beginsWith((const char *)glGetString(GL_VERSION), "OpenGL ES 2.0 "))
        {
            DE_ASSERT(m_context.getRenderContext().getType().getMajorVersion() < 3);
            DE_ASSERT(m_context.getRenderContext().getType().getMinorVersion() == 0);
            DE_ASSERT(m_context.getRenderContext().getType().getProfile() == glu::PROFILE_ES);

            glu::ShaderProgram program(m_context.getRenderContext(),
                                       glu::makeVtxFragSources(uniformTestVertSource, uniformTestFragSource));
            glUseProgram(program.getProgram());

            m_log << program;

            std::vector<GLfloat> data(16);

            m_log << tcu::TestLog::Section("", "GL_INVALID_VALUE is generated if transpose is not GL_FALSE.");
            glUseProgram(program.getProgram());
            glUniformMatrix2fv(0, 1, GL_TRUE, &data[0]);
            expectError(GL_INVALID_VALUE);
            glUniformMatrix3fv(0, 1, GL_TRUE, &data[0]);
            expectError(GL_INVALID_VALUE);
            glUniformMatrix4fv(0, 1, GL_TRUE, &data[0]);
            expectError(GL_INVALID_VALUE);
            m_log << tcu::TestLog::EndSection;

            glUseProgram(0);
        }
    });
}

} // namespace Functional
} // namespace gles2
} // namespace deqp
